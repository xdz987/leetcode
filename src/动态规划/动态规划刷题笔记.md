## 动态规划刷题笔记
## 一、爬楼梯问题
#### 爬楼梯 q70
- 状态：目标楼梯阶数、可选择的步伐
- 选择：走几个台阶
- 推导公式：dp[i]=dp[i-1]+dp[i-2]
- 初始化dp:dp[1]=1,dp[2]=2
- 重点：即为Fibonacci

#### 使用最小花费爬楼梯 q746
- 状态：目标楼梯阶数
- 选择：走几个台阶
- 推导公式：dp[i]=min(dp[i-1],dp[i-2])+cost[i]
- 初始化：dp[0]=cost[0],dp[1]==cost[1]
- 步骤：
    1. 初始化dp[cost.lenth]
    2. 初始化dp[0]dp[1]
        1. 遍历每个台阶
            - 执行推导公式
    3. min(dp[len - 1], dp[len - 2]);
        - 最后一步不用花费，倒走1或2步

## 二、背包问题
### (一)0/1背包——目标和
#### 分割等和子集 q416
#### 方法一：DP[0-1背包]
- 状态：背包的容量、可选择的物品
- 选择：装与不装进背包
    - 取决于物品的重量，能不能恰好将背包装满
- 重点：basecase是当背包重量为0时，遍历任意商品都为true
- 步骤：
    1. 计算目标背包容量
    2. 初始化dp table二维数组[商品数量+1][目标背包容量+1]
    3. 外层循环枚举每种商品，内层循环递增背包容量
        1. 当背包容量放不下时，结果等于枚举至上一商品该重量的结果
        2. 当背包容量放得下时，结果等于枚举至上一商品该重量的结果【或】当前背包容量-当前商品重量是否恰好装满
    4. 返回[商品数量][目标背包重量]

#### 状态压缩：
- 压缩前：dp[商品种类+1][背包重量]
- 压缩后：dp[背包重量]
- 注意：循环背包重量必须从大到小。
    1. 如从小到大，则【背包重量减去当前商品重量的最大价值组合】为【当前商品】
        - 此时背包存在两个当前商品
    2. 如从大到小，则【背包重量减去当前商品重量的最大价值组合】为【上一商品】
        - 此时背包存在一个当前商品

### (二)完全背包——最值
#### 零钱兑换 q322 完全背包
#### 方法一：DFS备忘录
- 重点：由目标金额减去每种面额的硬币，保存最小枚数的组合
- 方案：
    1. 初始化备忘录memo，为长度金额+1，索引对应金额amount的硬币组合枚数
    2. DFS
        1. 当amount<0时返回-1
        2. 当amount==0时返回0枚
        3. 当memo[amount]存在时直接返回
        4. 设res为最大值
        5. 遍历每种额度硬币
            1. dfs每种amount-硬币的可能，保存作count
            2. 当count==-1说明不存在该面额硬币组合的可能性，直接跳过
            3. 否则说明amount可以减去当前额度硬币，返回res与与count+1硬币数，比较的最小值
    3. 将最小值res保存至memo

#### 方法二：DP[完全背包]
- 状态：兑换的金额
- 选择：硬币面额的种类
- 重点：遍历1~目标金额的每种硬币组合，并保存1~目标金额的硬币组合中的最小枚数组合
- 方案：
    1. 初始化DP table，长度为金额+1，索引对应金额
    2. 遍历每种【状态】即金额1~amount
        1. 初始化dptable值为max
        2. 遍历每种硬币额度
            1. 剩余金额balance等于amount-硬币额度
            2. 当剩余金额>=0，说明该硬币组合可行，保存dp[当前金额]=dp[当前金额]与1+dp[剩余金额]的最小值
    3. 返回结果，dp[目标金额]不为最大值时，否则返回-1

### (三)完全背包——组合
#### 零钱兑换2 q518 完全背包组合
#### 方法一：DP[完全背包组合]
- 状态：兑换的金额、硬币的额度
- 选择：是否进行兑换
- 重点：目标是金额兑换硬币的所有组合数，外层循环选【硬币额度】，内存循环为兑换的金额
- 步骤：
    1. 初始化dptable[硬币种类][金额]，初始化当金额为0时，存在1种组合(即0元)
    2. 外层枚举每种硬币，内层递增金额
        1. 当背包装不下时，当前硬币的目标金额组合数等于上一硬币的目标金额组合数
        2. 当背包装的下时，当前硬币目标金额组合数 = 上一硬币的目标金额组合数 + 当前硬币的[目标金额-当前硬币额度]的目标金额组合数
    3. 返回结果

#### 状态压缩
- 目标：恰好达到目标金额的所有硬币组合数
- 压缩前：dp[硬币种类][金额+1]
- 压缩后：dp[金额+1]
    - 由于商品是无限，所以当尽可能保存所有的可能，所以金额枚举从0~目标金额

