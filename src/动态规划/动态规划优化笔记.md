### 一、状态压缩
- 即压缩dp table的内存空间
    1. O(n)->O(1)
    2. O(n^2)->O(n)

#### 什么情况可以状态压缩/压缩dp空间呢？
- 二维数组即O(n^2)情况：最优子问题只涉及到前一行的最优子问题
    - 即在上一行最优子问题，但当涉及到当前上一行当前列之前的最优子问题，那么内存循环需要由大到小，如【0/1背包——最值】
- 二维数组即O(n)情况：最优子问题只涉及到前几个最优子问题
    - 比如斐波那契就是i-1和i-2

### 类型一：商品唯一
#### 示例：
#### 例1：分割等和子集 q416
- 目标：让背包重量恰好装满
- 压缩前：dp[商品种类][背包重量]
- 压缩后：dp[背包重量]
    - dp[背包重量]=装或不装的结果
    1. 不装则不变
    2. 装【或】不装：不装的结果(true或false)【或运算】装的结果(当前背包重量减去当前商品重量的结果)
        - 注意：此时装的结果受【当前背包重量减去当前商品重量】的背包重量结果影响
        1. 此时如果枚举【0到目标背包重量】，那么(当前商品)当前背包重量的操作将耦合(还是当前商品)减去当前商品的背包重量的。（简单说就是大背包重量受小背包重量影响，都是当前商品）
            - 存在两个当前商品
        2. 而如果枚举【目标背包重量到0】，那么(当前商品)当前背包重量减去当前商品的背包重量(上一个商品)将不耦合
            - 存在一个当前商品

#### 例2：0-1背包问题
- 目标：让背包重量装满商品的最大价值组合
- 压缩前：dp[商品种类+1][背包重量]
- 压缩后：dp[背包重量]
    - dp[背包重量]装或不装的结果
    1. 不装则不变
    2. 装【或】不装同(一)

### 类型二：商品无限
#### 例1：q518
- 目标：恰好达到目标金额的所有硬币组合数
- 压缩前：dp[硬币种类][金额+1]
- 压缩后：dp[金额+1]
    - 由于商品是无限，所以当尽可能保存所有的可能
    1. 金额枚举从0~目标金额。此时【当前金额硬币的组合数】为最新的，所以当当前金额可兑换硬币时。当前金额硬币所有组合数=上一硬币金额所有组合数+(当前金额-硬币额度)的所有组合数
        - 后者的(当前金额-硬币额度)的所有组合数【包含】了【当前硬币】为最新所有组合数
            - 硬币可以为>1个
    2. 金额枚举从目标金额~0
        - 后者的当前金币-硬币额度的所有组合数【不包含】【当前硬币】的所有组合数
            - 硬币是唯一的(不符题)


### 二、滚动数组
- 类似循环数组，使用%的方式使得下标始终在一个范围内。
    - 比如斐波那契数列f(n)=f(n-1)+f(n-2)
    - 使用普通变量代替是ppre、pre、cur
    - 使用滚动数组是dp[3]容量
        - i/i-1/i-2：对应i%3
- 既然可以使用普通变量为什么还要用滚动数组呢？
- 普通变量是针对一维数组且依靠几个元素的情况。如果是二维数组依赖前10个元素呢？此时使用滚动数组就可以实现内存空间的简化
- 不过需要注意的是，大量的%操作本身就很耗费性能和内存空间。