## 一、斐波那契类型问题
### (一)斐波那契数列
#### 爬楼梯 q70
- 状态：目标楼梯阶数、可选择的步伐
- 选择：走几个台阶
- 推导公式：dp[i]=dp[i-1]+dp[i-2]
- 初始化dp:dp[1]=1,dp[2]=2
- 重点：==即为Fibonacci==

#### 使用最小花费爬楼梯 q746
- 状态：目标楼梯阶数
- 选择：走几个台阶
- 推导公式：==dp[i]=min(dp[i-1],dp[i-2])+cost[i]==
- 初始化：==dp[0]=cost[0],dp[1]=cost[1]==
- 步骤：
    1. 初始化dp[cost.lenth]
    2. 初始化dp[0]dp[1]
        1. 遍历每个台阶
            - 执行推导公式
    3. min(dp[len - 1], dp[len - 2]);
        - ==最后一步不用花费，倒走1或2步==

#### 分割整数构成字母字符串 q91
- 重点：四种情况，==以下是做拆分理解，代码可以做组合，所以不必分四种情况写==
    1. 当前数字不为0，且前一数字与当前数字可合并即<=26
        - f(i)=f(i-1)+f(i-2)
    2. 当前数字不为0，且前一数字与当前数字不可合并即>26
        - f(i)=f(i-1)
    3. 当前数字为0，且前一数字与当前数字可合并且<26
        - f(i)=f(i-2)
    4. 当前数字为0，且与前一数字不可合并如306，不符合题目
        - f(i)=0
- dp[i]含义：==dp[i]为对s[0,i-1]的dp[i]个解码方法。所以定义dp[n+1]==
- 方案：
    1. 初始化dp、初始化边界dp[0]=1。
        - 默认所有数字情况都为0，对应情况4
    2. 遍历1~n
        1. ==当s[i-1]不为0，添加dp[i]+=dp[i-1];==
            - 对应情况1、2
        2. ==当s[i-2]不为0并且s[i-2]与s[i-1]<=26时，添加dp[i]+=dp[i-1]==
            - 对应情况1、3
    3. 返回dp[n]

#### 只有两个键的键盘 q650
#### 方法一：DP
- 重点：==当i%√j=0的时，可以减少操作数==
    - ==如i=10,j=√4=2，10%2=0，那么可减少次数dp[i]=dp[j]+dp[i/j]==
- dp定义：==当i%j=0时，dp[i]=dp[j]+dp[i/j]==
- dp初始化：====最差需要操作N次即dp[i]=i====
    - 素数一定为N
- 方案：
    1. 初始化dp、初始化边界
    2. 遍历[2,n)
    3. 遍历[2,i]
        1. 当i%j=0时更新dp[i]
    4. 返回dp[n]

#### 方法二：循环/递归
- 与dp思路相同，只是换成循环/递归
- 循环则从大到小，递归则从小到大
- 循环方案：
    1. 初始化res=0，取模d=2
    2. while(n>1)
        1. 循环遍历n%d==0时累加操作数
        2. d++

### (二)打家劫舍系列
- 有点像限定了条件的【前缀和】

#### 打家劫舍 q198
- 重点：劫舍必须隔着房子
- dp表：房子比作商品,按商品数量进行遍历
    - 即只有1间、2间...房子可劫舍
- dp初始化：==只有1间和只有两间的情况，即dp[0]和dp[1]==
- 状态选择：==在劫舍与不劫舍中取最大价值，即max(dp[i-1],dp[i-2]+nums[i]);==
- 方案：
    1. 初始化dp，初始化第一、二间的最大价值
    2. 保存dp[i]最大价值即max(dp[i-1],dp[i-2]+nums[i])
    3. 返回dp[n-1]
- 状态压缩：循环只用到了i,i-1,i-2三个变量

#### 打家劫舍2 q213
- 同q198，只是取去除第一间或去除最后一间最大值即Max([0,n-1],[1,n])

#### 打家劫舍3 q337
#### 方法一：记忆化递归
- 重点：
    1. 使用后序遍历，使得可以遍历到每一颗子树。
        - 如下图为：[3][2,3][1,2,3][4,1,2,3]
        - 打家劫舍：rob(3)、rob(2,3、rob(1,2,3)、rob(4,1,2,3)
    2. 使用记忆化搜索可以避免重复计算子树，实现与【打家劫舍1】一维数组的效果
        - 打家劫舍记忆化：rob(3)、rob(2,res(3))、rob(1,res(2,3)、rob(4,res(1,2,3))
            - 这是斜树的例子，满二叉树的话则存在更多重复的计算
            - 从抽象来看的话，树的底部相当于一维dp的0，树的root相当于一维dp的n
    3. 状态选择：==偷与不偷的最大值==
- dp数组就是map，只是n为树的深度
- 方案：
    1. 判断root是否存在于map，是直接返回
    2. ==val1保存偷爷孙节点的值==
        - 爷即root.val
        - 孙即root.left.left/right和root.right.left/right
    3. ==val2保存偷子节点的值==
        - 即root.left/right
    4. ==保存max(val1,val2)到map中并返回==

![image](http://note.youdao.com/yws/res/46454/94804D0C8F3C46AF806F7B605654859E)
#### 方法二：树型DP
- 思路同方法一基本相同，只是将==偷与不偷的结果由map换成int==
- dp数组的每个元素就是每层的[不偷,偷]数组，长度n依然是树的深度
- 方案：
    1. ==记录偷的结果为root.val+left[0]+right[0]==
        - 其中下标0存放的是不偷的结果，1存放的是偷的结果
    2. ==记录不偷的结果为Math.max(left[0],left[1])+max(right[0],right[1])==
        - 偷的话应当保存子节点的一偷与不偷的最大值
    3. ==后序遍历回到root节点，返回root节点偷与不偷的最大值==

![image](http://note.youdao.com/yws/res/46451/B1801D26C6214A3DBA9155980BB3A75D)

## 二、分割整数问题
- 思想：将一个整数拆分成两个子整数，子整数根据目标（如最大乘积）可选择继续拆分，可抽象成一颗二叉树
- 动态规划三板斧(以最大乘积为例)：
    - 子问题：求每个整数的分割子整数最大乘积
    - 最优子结构：每个数字最大乘积都由子整数相乘而得，子问题之间不耦合，同时后续最大乘积由前子问题（整数）最大乘积推导而出
    - 状态转移：
        - 状态：==每个整数的分割子整数最大相乘值==
        - 选择：==分割一次与多次分割中选择乘积最大的值==
            - 如5：
            1. 3*2
            2. 2*2*1

#### 分割整数的最大乘积 q343
- 方案：
    1. ==初始化dp[n+1]，设有效最小整数的最大乘积即d[2]=1==
    2. 遍历i为[3~n]，计算每个整数最大乘积
        1. 遍历1~i/2，动态保存最大乘积
            1. ==保存分割一次与分割多次中的最大值max==
            2. ==更新dp[i]为max(max(dp[i-j]*j,(i-j)*j),dp[i])==
    3. 返回dp[n]

#### 按平方数来分割整数 q279
- 思想：
    - 子问题：==整数最少完全平方数组成==
    - 最优子结构：每个整数计算过程不影响其他整数
    - 状态转移：==当前子问题由前面某最优子问题组成，即Math.min(dp[i], dp[i - j * j] + 1)==
- 方案：
    1. 遍历1~n
        1. 初始化dp,dp[i] = i;
        2. 遍历完全平方数j*j<i
            - 动态保存最少数量，即dp[i]=min(dp[i],dp[i-j*j]+1)
    2. 返回结果

## 三、矩阵路径问题
### (一)矩阵路径——组合问题
#### 不同路径 q62
- 重点：
    1. ==当只存在一行或一列时，最多只有一条路径，所以初始化dp表第一行/列值均为1==
    2. ==能到达任意右下角路径都等于dp[i-1][j]+dp[i][j-1]==
- 方案：
  1.初始化第一行/列为1
    2. 遍历每一行每一列，设dp[i][j]=上+左（对应着往下和往右走的路径和）
- 路径压缩：dp[j]=dp[j]+dp[j-1]中右边的dp[j]即为【上】的值，dp[j-1]即为已更新的【左】值

#### 不同路径2 q63
- 解决方案：思路同q62，不同：
    1. ==当是第一行/列如果遇到障碍，则之后的路径值全改为0。==
    2. ==计算路径之和时，遇到obstacleGrid[i][j]为1则continue==
        - ==如果是原地替换法，还需要改为0，否则影响计算==
- 原地替换法：
    1. 当是第一行/列如果遇到障碍，则之后的路径值原地全改为0。
    2. 计算路径之和时，遇到1时原地改为0再continue

### (二)矩阵路径——最值问题
#### 最小路径和 q64、剑47
- 重点：==同组合问题，但是是保存当前值grid[i][j]+min(左，上)==
- 方案：同组合问题，只是取路径值小的值，即grid[i][j]+min(左，上)
- 原地修改法：==将grid直接作为dp，即将dp值放入grid中==

## 四、背包问题
![image](http://note.youdao.com/yws/res/46015/404EDD8092504ABA8D9E32FF6E731963)
### 0/1背包
### (一)0/1背包——最值问题
#### 例题：0/1背包原型题
- 背包在有限重量下保存最大价值的商品组合
- 唯一状态：背包容量（对应商品重量）、商品价值
- 状态选择：放不放进背包
- 因为目标为总价值最大，无关商品排列的顺序。但由于商品数量有限，所以商品放在外层循环可避免商品重复装入背包，否则采用标记法也可。

#### DP题解
- 状态：背包的容量、可选择的商品
- 选择：装进背包与否
    - 是否装进背包取决于商品的重量与价值。
    - 即到【包含上一个商品的该背包重量的最大价值】与【包含当前商品的该背包重量的最大价值】谁大
        1. 准确的说是能够容纳的情况下每单位重量的商品价值谁的更大
        2. 当然如果商品选择不多而背包人容量大的话则以能够装满背包为主
- 重点：目标在于最大价值且商品的数量有限(只有一件)，所以外层循环为遍历商品，而内层循环才是背包容量
- 方案：
    1. 初始化dp table二维数组[goods][weight]，意义为在背包重量为weight时，包含前goods个商品最大价值组合
        1. 第一维：前goods个商品
        2. 第二维：当前背包重量weight
    2. 外层循环，枚举每种商品
    3. 内存循环，枚举每个背包重量
        1. 当背包不能装下新商品时，设截止至当前商品的背包最大价值组合等于截止至上一商品的背包最大价值组合
        2. 当背包能装下商品时，比较保存单位重量的最大价值
            1. 当前商品
            2. 截止至上一商品最大价值商品组合
    4. 返回包含N个商品背包重量为W的最大价值组合的值

#### 状态压缩
- 压缩前：dp[商品种类+1][背包重量]
- 压缩后：dp[背包重量]
- 注意：循环背包重量必须从大到小，因为装入背包时涉及【背包重量减去当前商品重量的最大价值组合】即小重量。
    - 如从小到大，则【背包重量减去当前商品重量的最大价值组合】为【当前商品】
        - 此时背包存在两个当前商品
    - 如从大到小，则【背包重量减去当前商品重量的最大价值组合】为【上一商品】
        - 此时背包存在一个当前商品

#### 一和零 q474 0/1双格背包 【特殊题】
- 复杂度：O(strsLen*N*M) O((N+1)*(M+1))
- 双格背包：即多了一层需要判断，dp多个维度做存放。此外与单格背包无任何区别
- 转为0/1背包问题：
    - ==商品：每个01字符串==
    - ==背包重量：dp[m][n]，能够放下0和1的数量==
- 状态选择：==保存放不放01字符串到背包与否，取决于子集的数量是否最大==
- 方案：
    1. ==初始化dp[m+1][n+1]==
        - 已状态压缩
    2. 外层循环遍历每个(商品)
        - 统计str每个(商品)中'0'和'1'的数量
    3. 内存循环遍历计算子集数量
        1. ==当前商品'0'的数量<=m，状态压缩+商品唯一所以逆序==
        2. ==当前商品'1'的数量<=n，状态压缩+商品唯一所以逆序==
            1. 保存最大子集数量即dp[i][j]=max(dp[i][j],dp[i-零的数量][j-1的数量])
    4. 返回dp[m][n]

### (二)0/1背包——元素和
#### 例题：分割等和子集 q416
#### 方法一：0/1背包
- 重点：
    - ==分割等和子集即目标为：取总和的平均数，单总和为奇数时一定无法分割为等和子集==
    - ==将nums[]数组的元素值当作商品重量，[0~target]为背包容量。每次尽可能的容纳商品，放不下背包忽略，放的下背包则判定是否等于target直接返回==
- 方案：
    1. 总和是奇数之间返回false
    2. 以nums[]作为商品，放在外层循环
    3. 以[0,target]作为背包重量放在内层循环
        1. 背包尽可能保存商品，放不下跳过
        2. 放得下判断是否等于target

#### 最后一块石头的重量2 q1049
- ==同q416，只是当总和为奇数时无需返回false，最后将total-2*dp[avg]即为答案==
- 解题：
    1. ==最后一块石头重量，即为两个集合之差==
    2. ==需求最小重量，即两个集合的重量尽可能接近石头总重量的平均数。即求一个集合尽可能接近平均数即可==
- 重点：
    1. ==将石头比作商品，设定目标重量（总重量/2）为背包容量，即[1,总重量/2]==
    2. 背包在能容纳商品的前提下，尽可能存放商品以接近平均数
        - 如75最好结果是73和78，此设计则在背包重量为75的时候取得73
- 方案：
    1. 计算石头总重量/2
    2. 初始dp[总重量/2+1]
    3. 外层循环遍历每块石头
        - 因为是商品有限
    4. 内层循环遍历背包重量
        1. 当背包放的下商品时，保存替换商品与否的最大重量
    5. 返回总重量-dp[target]*2，即两个集合之差

### (三)0/1背包——元素和的组合
#### 目标和 q494
- 重点：将问题转换为0/1背包
    1. ==要使得每个元素前加'+'或'-'，最终使得sum=S。而将'+'和'-'的元素分为两个子集。那么两个子集之和的绝对值差值必定等于S。转换为背包问题，就只需要找到其中一个子集即可==
    2. 将1的思路转换为子集公式存在以下两种（任选一）：
        1. ==target子集由S=sum-(target子集*2)推导出：target子集=(sum-S)/2==
        2. ==target子集=子集+子集-sum=S推导出：target子集=(S+sum)/2==
    3. ==S的正数或负数的组合数是相同的==
    4. 当目标子集和即target=0时，无论存在任意数量商品，都可通过不放进背包而得出1种组合可能，所以==初始化dp[i][0]=1==
    5. ==元素唯一/组合，所以是加上遍历至上一商品的『组合数量』==
        - 这样不会出现两个当前商品的情况
    6. ==与q416分割子集相同，当目标子集((sum-S)%2)为奇数时，无法组合出目标和，返回0==
- 方案：
    1. 计算总数sum，计算target=(sum-S)/2
    2. 当sum<S或(sum-S)%2==1时直接返回0种组合数
    3. 初始化dp[target]，初始化当背包重量为0时，存在1种组合方式
    4. 外层循环遍历商品
    5. 内存循环遍历[0,target]的背包重量
        1. 计算组合数即dp[weight]=dp[weight-1]+dp[weight-nums[goods]]
    6. 返回dp[target]

### 完全背包
### (一)完全背包——最值问题
- 背包与商品谁是外循环(对应排列或组合)都不影响结果

#### 例题：零钱兑换最少硬币 q322
- 在无限硬币的前提下，兑换指定金额的最小数量的零钱
- 唯一状态：背包容量

#### DP题解
- dp边界问题：
    1. ==目标金额为0时存在0种组合方式==
    2. ==无法兑换出到目标金额时为[amount+1,MAX_VALUE-1]，结尾处判断是否等于该值即可知道是否能兑换处amount==
- ==遍历顺序问题：由于硬币无限，所以背包与商品谁内外循环不影响结果==
- ==状态选择：是否选择当前硬币，即min(dp[amount-coin]+1,dp[amount))==
- 状态：需要兑换的额度、硬币面额
- 选择：是否添加改枚硬币
- 重点：目标在于硬币的数量，所以保存额度兑换最小数量硬币
- 关键步骤：
    - 遍历每种硬币额度
        1. 剩余金额balance等于amount-硬币额度
        2. 当剩余金额>=0，说明该硬币排列可行，保存dp[当前金额]=dp[当前金额]与1+dp[剩余金额]的最小

#### 单词拆分 q139
- 重点：
    1. ==以s的每个位置作为背包的重量，字典中每个商品==
    2. ==判断以s[i]为终点位置是否存在word有两种方式==
        1. ==以s作为的每个终点作为背包重量，查找sub(j,i)是否存在于字典==
        2. ==以s作为的每个终点&&字典作为长度作为背包终点，可以不必sub(j,i)每个终点，而只需要sub(i-len,i)即可。==
- ==dp[i]含义：以i为终点的字符串存在于字典==
- ==dp边界：即以i=0为终点的字符串必定为true（为了后续字典取值）==
- 方案：
    1. 初始化dp表，当为空串是为true，即dp[0]=true
    2. 由于商品无限，所以正序遍历每个背包重量/每个终点
        - 复杂化来说已经进行了状态压缩
    3. 遍历每个单词
        1. 状态选择：当word可放入背包/在字典可查到时，保存当前背包结果与前一结果为true的一方
            - 即dp[i]||dp[i-len]
        2. 找到true，可直接break剪枝
    4. 返回dp[n]

### (二)完全背包——组合问题
#### 例题：零钱兑换组合数 q518
- 状态：背包的容量、可选择的物品
- 选择：装进背包与否
- 重点：==目标在于达到金额的所有硬币【组合数】，所以外层循环为遍历【不唯一的】商品(硬币)，而内层循环遍历【唯一】的背包容量(金额)==
- ==dp边界：目标金额为0时存在1种组合==
- ==dp[i]含义：目标金额i存在dp[i]组合方式==
- ==状态转移公式：dp[i]=dp[i]+dp[i-coin]，即目标金额的组合方式等于上一次遍历的组合数+[i-coin]的组合数==
- 方案：
    1. 初始化dp[商品数+1][目标金额+1]
    2. 初始化dp设所有[商品][0]等于1
        - 当金额为0时默认存在一种组合所以等于1
    3. 外层循环枚举每个商品，内层循环递增背包容量
        1. 当背包放不下该商品时，当前商品组合数等于【上一商品】的组合数
        2. 当背包放得下该商品时，当前商品组合数等于【上一商品】商品组合数+【背包重量减去当前商品重量】的商品组合数
            - 因为是组合数，所以关注的是背包重量减去商品重量的重量，而不是商品的重量
    4. 返回[商品][目标背包重量]

#### 状态压缩
- 目标：恰好达到目标金额的所有硬币组合数
- 压缩前：dp[硬币种类][金额+1]
- 压缩后：dp[金额+1]
    - 由于商品是无限，所以当尽可能保存所有的可能，所以金额枚举从0~目标金额

### (三)完全背包——排列问题
#### 组合总和4 q377
- 重点：
    1. ==实为【排列】问题==
    2. ==完全背包的排列问题，则是【外背包重量内商品】==
- ==dp[i]含义：目标重量为i存在dp[i]种排列方式==
- ==dp边界：目标重量i=0存在1种排列方式（即不选商品）==
- 方案：
    1. 初始化dp，当目标数字为0时存在1种排列方式(即不选)
    2. 外循环为"背包重量"
    3. 内循环为"商品"
    4. 当背包放的下商品时，保存排列数
    5. 返回dp[目标背包重量]

## 五、股票买卖问题【多状态转移】
- 贪心思想解法位于贪心题解模块

#### 买卖股票的最佳时机1 q121【双状态转移】
- 子问题：在已知的时间与价格中找到左小右大最大的差值
- 最优子结构：买卖相互不影响
- 状态转移：
    1. 是否选择持有，选择持有的目标是股票价格最便宜
    2. 是否选择卖出，卖出的目标是当天卖出比前一天卖出赚的更多现金

#### 方法一：暴力法优化/贪心
- 重点：不断在卖出前找到股票价格最小的一天，不断以当天价格-最小价格的一天，保存其中最大值

#### 方法二：DP
- 重点：由状态转移得出存在两种选择，所以DP需设定两种情况，买入股票时手上的现金情况，与卖出后股票后手上的现金情况
- 方案：
    - 未持有和售出股票时是，手上的现金设为0
    1. 初始化双dp或者dp[2][n]
        - 两个一维数组对应着持有股票时手上现金和售出股票后手上现金
        - 设dp[0]为持有股票dp
        - 设dp[1]为售出股票dp
    2. 初始化第一天持有股票即dp[0][0]=-price[0]
    3. 遍历[1,n)，
        - 动态保存当天与昨天持有股票时手上现金最大的情况（即股票价格最低）
        - 动态保存当天售出与昨天售出股票时手上现金的最大情况
    4. 返回最后一天售出股票时的值即dp[1][n]
- 状态压缩：股票的持有情况和售出情况都只涉及到一个值的存储，即股票价格最低或者售出利润最大值。可用常亮代替dp表。
    - 代替后即与【贪心算法】一模一样

#### 买卖股票的最佳时机2 q122【双状态转移】
#### 方法一：贪心
- 枚举累加每天相邻交易差值为正数的总和

#### 方法二：DP
- 与一次买卖的差别：需要将先前交易的利润也计入，买入/持有股票的计算。
    - 方式是：
        1. 将先前的利润也放入股票买入/持有的计算的dp中。
        2. 通过卖出股票，会将先前交易利润归入到卖出后手上持有的金额的dp中
- 方案：
    1. 初始化dp[2][n]，dp[0][0]=-price[0]
        - dp[0]持有股票时手上的现金
        - dp[1]售出股票时手上的现金
    2. 遍历[1,n)
        1. 保存前一天与当天持有金额最大值dp[0][i]=max(dp[0][i-1],-price[i]+dp[1][i-1])
        2. 保存当天卖出获得的最大利润dp[1][i]=max(dp[1][i-1],dp[0][i-1]+price[i])
            - 此时股票的价格中加入了前面交易的利润，一起保存
    3. 返回dp[1][n]
- 状态压缩：先计算售出股票时手上的现金，再计算买入/持有股票时手上的现金。
    - 这样当天售出股票可得到前一天持有的情况
    - 而当天买入/持有股票也可获得今天(假如)卖出手上持有的利润
        - 不可能再持有今天的股票，因为假如是更新今天售出后手上持有的金额。那么买入股票取max的-price[i]+soldCash一定不大于前一天的holdCash。所以是为了明天的股票交易而更新

#### 买卖股票的最佳时机3 q123 【五状态转移】
#### 方法一：DP
- 状态转移：
    1. 第一次买入、卖出：始终取得最大利润的一次交易
        - 即与q121的思路一模一样
    2. 第二次买入、卖出：在取得上一次最大交易收益（即第二大）的基础上，再取一次同样最大或第二大的收益交易。
        - 即与q122的基本思路相同，到了第二次买入的时候，不同于q122手上只有最大的一次收益。
    3. 买入结果：上一次交易最大收益+当前交易的最大收益交易，即两次买卖股票的最佳时机
    - 五次状态转移：
        - 不交易：(可直接用0替代即可忽略，但考虑后面还有一题冷冻期)
        - 第一次买入股票：始终保存最小股票价格，或者不交易
        - 第一次卖出股票：始终保存取得最大的收益
        - 第二次买入股票：基于上一次交易的收益（如有进行交易）保存最小股票价格
        - 第二次卖出股票：基于上一次交易的收益（如由进行交易）保存取得最大的收益
- 方案：
    1. 初始化五个状态
        - dp[0][0]不交易=0
        - dp[1][0]第一次股票持有现金=-price[0]
        - dp[2][0]第一次交易后持有现金=0
        - dp[3][0]第二次股票持有现金=-price[0]
        - dp[4][0]第二次交易后持有现金=0
    2. 遍历[1,n)天的股票
        1. 使得dp[0][i]始终不交易状态即=dp[0][i—1]
        2. dp[1][i]取得当前股票最小值/持有最大现金
            - 即max(0,price[i])
        3. dp[2][i]取得出售股票后的最大收益
            - 即max(dp[2][i-1],dp[1][i-1]+price[i])
        4. dp[3][i]取得基于第一次交易收益的持有股票最大现金
            - 即max(dp[3][i-1],dp[2][i-1]-price[i])
        5. dp[4][i]取得基于第一次交易收益的再次股票交易最大收益
            - 即max(dp[4][i-1],dp[3][i-1]+price[i])
    3. 返回dp[4][n]
- 状态压缩：同q121、q122的思路
    - firstHoldCash：始终保存最小的股票价格
    - firstSoldCash：始终保存最大交易收益
    - secondHoldCash：基于第一次交易收益再找最小的股票价格
    - secondSoldCash：基于第一次交易收益保存最大交易收益（即两次）
    - 遍历，先出售股票再更新持有，这样出售最小股票是今天之前的，不会少了前一天的股票价格情况。
        - 如[1,2]先持有再售出为2-2=0，先售出再持有则2-1=1

##### 运行实例：第一次交易始终保存最大交易收益，第二次交易则基于上一次的最大交易收益再保存最大交易收益
![image](http://note.youdao.com/yws/res/46762/7D60B88BC49E4B018FCB6FCDE4253D34)
![image](http://note.youdao.com/yws/res/46759/3D1A044B20C24175B877EED54F7A8557)

#### 买卖股票的最佳时机4 q188【K+1状态转移】
- 与q123完全相同：
    1. 基于q123的状态压缩。由2次交易用到4个基本类型变量和不交易的0。
    2. 变成了k次交易*2+不交易的0，使用数组来存放这种规律那么就是dp[k*2+1]
- dp数组的含义：
    - [0]是不交易
    - [奇数]是第(奇数/2)次持有股票
    - [偶数]是第(偶数/2)次出售股票
- 方案：
    1. 初始化dp[k*2+1]，初始化奇数位(持有股票)为-price[0]
    2. 遍历[1,n)，设为i
    3. 遍历[2,k*2+1)，设为j
        - 与q123一样，避免忽略了前一天的股票价格，所以需要先执行售出计算，再执行当天股票价格计算
        1. 第k次持有股票手上的现金为dp[j]=max(dp[j],dp[j-1]+price[i])
        2. 第k次售出股票手上的现金dp[j-1]=max(dp[j-1],dp[j-2]-price[i])
    4. 返回第k次交易的最大收益即dp[k*2]

#### 买卖股票时机含冷冻期 q309
#### 思路一：【四状态转移】(淘汰)
- 状态转移：
    0. 不交易：
    1. 持有股票手上现金：
        1. 不更新，继续持有之前股票
        2. 更新，换成今天股票
            1. 处于冷冻期
            2. 不处于冷冻期
        - 今天卖出了股票
    2. 卖出股票手上现金，手上没有股票可卖：
        - 前天卖出，昨天是冷冻期没有买入，所以今天手上没有股票
    3. 卖出股票手上现金：
    4. 卖出股票今天处于冷冻期：

#### 思路二：【双状态转移】
- 状态转移：
  0：不交易
    1. 持有股票手上现金：基于【前前天】卖出股票收益下持有股票
    2. 卖出股票手上现金：根据持有股票手上现金与当天股票价格，取得卖出股票的最大收益
- 重点：与q122相同。只是增加冷冻期，意味着持有股票手上的现金是基于前前天卖出股票的收益
- 方案：
    1. 初始化dp[2][n]，dp[0][0]=-price[0];
        - 其中dp[0]：持有股票时手上的现金
        - 其中dp[1]：售出股票时手上的现金
    2. 遍历[1,n)每天股票的价格
        1. 更新持有股票手上现金dp[0][i]=max(dp[0][i-1]，【前前天】股票收益-price[i])
        2. 更新出售股票手上现金dp[1][i]=max(dp[1][i-1],dp[0][i-1]+price[i])
- 状态压缩：同q122，只是增加一个变量保存【前前天】的售出股票手上收益

#### 买卖股票最佳时机含手续费 q714【双状态】
- 状态转移：同q122
- 重点：同q122。只是在售出股票时【减少收益】-fee或者放在买入股票时【增加股票价格】
    - 注意，只能选一个，否则就扣了两次手续费
- 方案：在q122更新售出股票手上持有金额处-fee

## 六、最长xx序列
### (一)最长递增序列【元素递增/减】
- 特点：从多个子序列中取最长子序列

#### 最长连续递增序列 q674
#### 方法一：DP
- 状态选择：[递增，设为初始化1]。
    - 当当前元素大于前一元素时，设当前元素递增数量=前一元素递增数量+1
- 方案：
    1. 初始化dp、初始化边界即最小连续递增长为1
    2. 遍历数组[1,n)
        1. 当相邻递增时，当前元素的递增数量=前一元素的递增数量+1
            1. 更新最大递增序列
        2. 不递增时设当前元素递增数量=1
- 状态压缩：当前元素只与前一元素相关，设一个变量动态更新此值即可

#### 方法二：滑动窗口
- 略

#### 最长递增子序列 q300
#### 方法一：DP
- 复杂度：O(N^2) O(N)
- 状态选择列表：列表为[截止至前面[0~i)的所有连续递增子序列]中当n[i]大于n[j]的
    - 与q674不同点，q674只与前一个连续递增有关，而递增子序列，则是与截止至当前i的递增子序列即[0~i)有关
- 状态选择：遍历[0,i-1)时,设为j，当n[i]大于n[j]时，取基于j的连续子序列最大值max(dp[j]+1)
    - 即nums[i]>nums[j]：dp[i]=max(dp[i],dp[j]+1)
- 状态转移公式：dp[i]=nums[i]>nums[j]:max(dp[0]+1,dp[1]+1..dp[i-1]+1)
- 方案：
    1. 初始化dp数组，初始化边界即最小递增子序列为1
    2. 遍历所有[1,n)
    3. 遍历状态选择列表，即[0,i)
        1. 状态选择：取最大递增序列
        2. 保存截止至任意i的最大递增序列中的最大值，即res=max(res,dp[i])

#### 方法二：DP+二分查找
- 复杂度：O(NlogN) O(N)
- 方案：
    1. 初始化tail[]数组、res=0
    2. 遍历nums[]数组
        1. 开始二分查找，设left=0，right=res
        2. 当left<right，二分查找num位于tail[]数组的位置
    3. 更新tail数组，即tail[left]=num
        - 存在以下情况：
            1. num小于tail最大/右的值且大于tail最小/左值，更新中间的数。如果后续存在比tail更小的数(即情况3)那么更新有意义，否则无意义
            2. num大于tail最大/右的值，增加新值
            3. num为tail的最小/左的值，以该更小的值为起点，可能存在更长递增子序列
    4. 当right==res，说明num比tail的最大值还打，right没有缩小过。res++
        - 存在以下情况
            1. 是第一位数字没有进while
            2. 进了while，但从移动过right指针，说明num比tail[]最右边的数字还大

#### 最长数对链 q646
#### 方法一：贪心
- 方案：
    1. 先对元组数组根据下标[1]进行降序再按[0]降序
    2. pre记录前一个元组，当cur[0]>pre[1]时res++，并更新pre。否则直接跳过该元组

#### 方法二：DP
- 方案：
    1. 先对元组数组根据下标[1]进行降序再按[0]降序
    2. 其他同【最长递增子序列】

### (二)最长公共序列【元素相同】
- 特点：找到最多重复的元素，一个序列计数不断增大

#### 最长重复连续元素 q718
- 状态选择：如果元素相等，则基于上一个元素最长公共序列数+1
- 方案：
    1. 初始化dp，边界为dp[0~n][0]和dp[0][0~m]均为0，即没有重复元素
    2. 遍历nums1（nums1和nums2遍历顺序没有影响）
    3. 遍历nums2
        1. 当元素相等时，等于上一个元素的最长重复元素数量+1
        2. 动态保存最大值
    4. 返回最大值
- 状态压缩：当前元素的值只与上一和和当前行有关，内层循环逆序可压缩至一维数组。
    - 该一维数组d[长度为内层循环数组

##### 路线示意图
![image](http://note.youdao.com/yws/res/47165/EA26880F5C8C459C83A3BBD8AF9307FA)

#### 最长公共子序列 q1143 q1035
- 思路与q718基本相同，不同之处在于元素不相等时，dp[i][j]需要继承/保存max（当前坐标A的上一个元素最长公共子序列数，当前坐标B的上一个最长公共子序列数）
- 状态选择：
    - 元素相等：则基于上一个元素最长公共序列数+1
    - 元素不相等：则取A或B遍历至上一元素的最大公共子序列即dp[i][j]=max(dp[i-1][j],dp[i][j-1])
- 方案：与q718相同，不相等时延续上次公共子序列结果

![image](http://note.youdao.com/yws/res/47289/FC816E893FC3434DBB9BD57DB95FB891)

#### 判断子序和 q392
- 与LCS的区别在于只保存单向的子序列，即A是B的子序列，而B不是A的子序列

#### 方法一：双指针
- 复杂度：O(N+M) O(1)
- 略

#### 方法二：DP
- 复杂度：O(NM) O(NM)
- 不同于公共子序列，不相等时只去主序列上一个计数值
    - 即dp[i][j] = dp[i - 1][j];

![image](http://note.youdao.com/yws/res/47284/00C81E436D2744DD945FBCF67FABA8A7)

#### 两字符串的删除操作 q583
- 同q1143，返回值改为：A.len+B.len - 公共子序列*2

#### 两个字符串的最小ASCII删除和 q712
- 同q1143，不同点：
    1. 将字符相同时的+1换成：+字符的ASCII码
        - 当不相同的时候，dp[i][j]保存max也是保存最大的ASCII值，那么反过来对应的需要删除的字符ASCII值就是最小和
    2. 返回结果该为：两字符ASCII值总和-(2*dp[n][m])

#### 不同的子序列/子序列组合数 q115
- 基于LCS和q392判断子序列的结合
- 复杂度：O(NM) O(M)
- dp[t][s]含义：截止主串t的第i个字符匹配子串s的[0,j)个字符有dp[i][j]种子序列组合方式
- 初始化边界：
    1. 当成子串小到为空串""时，主串删除所有字符得到子序列组合为1个，所以dp[0~n][0]=1
    2. 当主串和子串都为空时，组合数为1，所以dp[0][0]=1
    3. 当主串为空""，子串不为空时，组合数一定Wie0，所以dp[1~n][j]=0
- 状态选择：
    - 字符相等：截止至子串的上一个字符([0,j-1])组合数＋遍历至主串的第i-1个字符时的截止至子串当前字符([0,j])的组合数
        - dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
    - 字符不相等：延续上一个匹配结果，即遍历至主串的第i-1个字符时的截止至子串当前字符([0,j])的组合数
        - dp[i][j]=dp[i-1][j]
- 方案：
    1. 初始化dp数组、初始化边界
    2. 遍历主串
    3. 遍历子串
        1. 字符相等时，组合数相加
        2. 字符不相等时，延续上一组合数结果
    4. 返回子序列组合数即dp[n][m]
- 状态压缩：使用变量保存当前位上一行上一列和当前位上一行的值，dp[n][M]变成dp[M]

![image](http://note.youdao.com/yws/res/47311/CC8C1C8AB116495CB7D3090E34E8F575)
![image](http://note.youdao.com/yws/res/47330/C44115FCE797424FAA586E853DACD21F)

#### 编辑距离 q73
- 基于LCS的思想
- dp[word1][word2]含义：表示word1[0,i)与word2[0,j)的编辑距离为dp[i][j]
    - 编辑距离即word1插入、删除、替换[编辑距离次]等于word2
- 初始化边界：
    1. 当word1和word2都为空时，编辑距离=0
        - dp[0][0]=0
    2. 当word1不为空，word2为空时，不断删除字符，编辑距离等于word1的长度
        - dp[{1~n}][0]={1~n}
    3. 当word1为空，word2不为空时，不断添加字符，编辑距离等于word2的长度
        - dp[0][1~m]={1~m}
- 状态选择：
    - 当字符相等：不进行任何操作，编辑距离不变，延续前一字符编辑距离值
        - 即dp[i][j]=dp[i-1][j-1]
    - 当字符不相等，取所有操作中最小的编辑距离：
        - 添加操作：模拟word1的第(i-1)位置前添加一个字符，添加后即对应word2的j的位置
            - 即dp[i-1][j]+1
        - 替换操作：模拟word1的第(i-1)个字符进行替换，替换时word1与word2的位置不变
            - 即dp[i-1][j-1]+1
        - 删除操作：word1删除等同于word2添加都是1次操作。模拟word2的第(j-1)位置前添加一个字符，添加后对应i的位置
            - 即d[i][j-1]+1
- 方案：
    1. 初始化dp[word1][word2]、初始化边界
    2. 遍历word1字符
    3. 遍历word2字符
        1. 当字符相等时，编辑距离不变
        2. 当字符不相等时，取增/删/改中最小编辑距离
    4. 返回dp[word1][word2]
- 状态压缩：

### (三)最长回文子串
#### 回文子串的数量 q647
#### 方法一：DP
- 复杂度：O(N^2) O(N^2)
- DP[i][j]含义：字符串[i,j]的字符是否为回文串
    - j始终>=i
- 初始化边界：所有子串都不是回文，全部为false
- 状态选择：
    - 两字符相等，且满足以下任意条件则为回文串
        1. j=i即指向同个字符
        2. j=i+1即为相邻字符
        3. i到j中间的串是回文串，根据dp的含义即d[i+1][j-1]为true
    - 两字符不相等：默认false，不进行任何操作
- 遍历顺序：
    - 由于状态选择的3需要判断d[i+1][j-1]是否为回文串，所以遍历时dp[i+1][j-1]需要在dp[i][j]之前先计算。所以采用自下向上的遍历方式
        - 外循环
    - 当然j始终>=i，所以从左往右遍历
        - 内训
- 方案：
    1. 初始化dp、初始化边界
    2. 自下向上遍历字符串
    3. 自作向右遍历[i,n]字符，因为回文子串包含单字符所以从i开始
        1. 状态选择
        2. 回文子串数量res累加
    4. 返回res

#### 方法二：中心拓展法
- 复杂度：O(N^2) O(1)
- 略

#### 方法三：马拉车算法
- 复杂度：O(N) O(1)
- 略

#### 最长回文子序列 q516
- 复杂度：O(N^2) O(N^2)
- DP[i][j]的含义：字符串s的[i,j]的子串最长回文子序列为dp[i][j]
- 初始化边界：每个字符串最短回文子串为1
- 状态选择：
    1. 两字符相等时，最长回文子序列数+2
        - 即据dp的定义dp[i][j]=dp[i+1][j-1]+2
    2. 两个字符不相等时，保存两字符向内子序列中最长的数
        - 即据dp的定义dp[i][j]=max(dp[i-1][j],dp[i][j-1])
        - 例abac。a!=b,位2=3,位3=1，当然取3
- 遍历顺序：状态选择中需要取i+1行的计算结果，所以自下而上
- 方案：
    1. 初始化dp、边界dp[i][i]=1
    2. 自下而上遍历字符串，内循环j+1，所以从n-2开始
    3. 自左而右遍历[i+1,n]字符，单字符不需要计算，所以从i+1开始
        1. 两字符串相等时，等于中间最长子串数+2
        2. 两字符不相等时，取中间左右边界的最长子串数最大值
    4. 自下而上，所以返回dp[0][n-1]

#### 将字符串转为回文串的最小插入次数 q1312
#### DP解法一：取得最小插入数
- 与最长回文子串思想基本一致
- 复杂度：O(N^2) O(N^2)
- DP[i][j]的含义：字符串s的[i,j]的子串构造为回文串最少需要dp[i][j]次插入
- 初始化边界：子串本身就是回文串不需要插入，即默认为0
- 状态选择：
    - 两字符相等：延续子串[i+1,j-1]的插入次数
        - dp[i][j]=dp[i+1][j-1]
    - 两字符不相等：向左或向右插入，中取最少插入次数的一边
        - dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1
- 遍历顺序：由于更新dp[i][j]需要用到计算好的第[i+1]行，所以自下向上遍历
- 方案：
    1. 初始化dp、遍历默认0
    2. 自下而上遍历字符串，内循环j+1，所以从n-2开始
    3. 自左向右遍历你[i+1,n]，单字符不需要计算，所以从i+1开始
        1. 两字符相等时，延续中间最小插入数
        2. 两字符不相等时，取插入左或右成回文的最小操作数
    4. 自下而上，所以返回dp[0][n-1]
- 状态压缩：

#### DP解法二：字符串长度-取得最长回文子序列【通用】
- 思想：如eqabbde
    - 最长回文子序列是eabbe
    - 此时e[q]abb[d]e存在两个字符影响转为回文串
    - 解决方法是：在右边插入q左边插入d。即字符串长度-原串最长回文子序列

### (七)区间计算
#### 最大子序和 q53
#### 方法一：贪心
- 重点：元素和为负数则设立新起点重新累加

#### 方法二：DP
- 状态列表：[当前元素值,当前元素之前的元素和+当前元素之]
- 状态选择：于状态列表中选择最大的值
    - 与贪心思路相同
- 方案：
    1. 初始化dp、边界dp[0]=nums[0]第一个数、res等于第一个数
    2. 遍历1~n个数字
        1. dp[i]保存max(当前数，前面子序和+当前数)
        2. res取最大dp[i]
    3. 返回dp[n-1]
- 状态压缩：当前元素只与当前元素之前的元素和有关，使用变量动态更新之前元素和即可

#### 乘积最大子数组
- 与q53最大子序和思想相似，由于是乘积，所以需要考虑负负的正的情况，采用增加一个dp数组记录最小子序和
- DP含义：
    - dpMax[i]：当[0,i)存在两个负数时，为[0,i)乘积最大字数组
    - dpMin[i]：当[0,i)存在一个负数时，为[0,i)乘积最小子数组
- 初始化边界：最少需要一个元素，所以dpmax[0]=dpMin[0]=nums[0]
- 状态选择：
    - dpMax选择以下最大：
        1. 当前元素
        2. 当前元素*前一乘积最大子数组
        3. 当前元素*前一乘积最小子数组
    - dpMin选择以下最小：
        - 同dpMax取但最小
- 方案：
    1. 初始化dp、初始化边界nums[0]
    2. 遍历[1,n)
        1. 更新dpMax[i]、dpMin[i]
        2. 保存乘积最大子数组
- 状态压缩：只用i-1的值，使用两个变量保存即可

#### 接雨水 q42
#### 方法一：暴力
- 复杂度：O(N^2) O(1)
- 思想：取当前列左边木板最大与右边木板最大，根据水桶效应，再取其中小的木板，减去当前木板高度即为该列的水乘的水
    - 需注意的时不会有负数，所以最小不小于当前木板
    - 转换即min(l_max,r_max)-height[i]
- 边界问题：只有中间的木板能盛水即[1,n-2]
- 方案：
    1. 遍历水桶[1,n-2]块模板，因为只有中间的木板能盛水
        1. 取左边最高木板或当前木板
        2. 取右边最高木板或当前木板
        3. 累加雨水。根据水桶效应，小的木板为装水的上限
    2. 返回雨水量

#### 方法二：暴力&备忘录/动态规划
- 复杂度：O(N) O(N)
- 思想：同暴力意义。只是使用数组提前算好左右木板最大值，即[0,i]与[i,n)

#### 方法三：双指针
- 复杂度：O(N) O(1)
- 思想：同前两个方法思路相同，只是增加了个思路：当左右的木板已经比自己当前木板要高了，那么距离更远的木板多高都对当前木板没有影响，采用双指针实现该思想。
- 方案：
    1. 初始化左右最大值为两端边界、初始双指针为两端
    2. 遍历所有木板
        1. 取得左边最大木板
        2. 取得右边最大木板
        3. 根据木桶效应，累加雨水量并移动指针
    3. 返回雨水量

#### 等差数列划分 q413
#### 方法一：滑动窗口
- 复杂度：O(N) O(1)
- 思想：如为等差数列则纳入窗口，不为等差数列则重设起点。等差数列的划分为等差数列为，如size=5，划分为(5-2+5-3+5-4)
- 方案：
    1. 初始化窗口指针
    2. 遍历所有元素，计算前后相邻元素之差
        1. 如前后相邻元素之差相等，则右扩窗口，并计算等差数列划分数量/连续等差数列组合数
        2. 不相等则重设滑动窗口起点
    3. 返回划分数量

#### 方法二：DP
- 复杂度：O(N) O(1)
- DP[i]含义：当前所属的等差数的长度-2
- DP边界：不为等差即默认0
- 状态选择：
    - 当前后差相等：dp[i]等于上一值+1
    - 前后差不相等：默认为0
- 方案：
    1. 初始化dp、边界=0
    2. 遍历[2,n)
        1. 前后差相等说明为等差数列，更新dp
        2. 累加res
- 状态压缩：使用常量代替前前元素、前元素、次数累加

