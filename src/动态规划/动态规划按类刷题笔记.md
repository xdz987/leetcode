## 一、斐波那契类型问题
### (一)斐波那契数列
#### 爬楼梯 q70
- 状态：目标楼梯阶数、可选择的步伐
- 选择：走几个台阶
- 推导公式：dp[i]=dp[i-1]+dp[i-2]
- 初始化dp:dp[1]=1,dp[2]=2
- 重点：即为Fibonacci

#### 使用最小花费爬楼梯 q746
- 状态：目标楼梯阶数
- 选择：走几个台阶
- 推导公式：dp[i]=min(dp[i-1],dp[i-2])+cost[i]
- 初始化：dp[0]=cost[0],dp[1]==cost[1]
- 步骤：
    1. 初始化dp[cost.lenth]
    2. 初始化dp[0]dp[1]
        1. 遍历每个台阶
            - 执行推导公式
    3. min(dp[len - 1], dp[len - 2]);
        - 最后一步不用花费，倒走1或2步

#### 分割整数构成字母字符串 q91
- 重点：四种情况
    1. 当前数字不为0，且前一数字与当前数字可合并即<=26
        - f(i)=f(i-1)+f(i-2)
    2. 当前数字不为0，且前一数字与当前数字不可合并即>26
        - f(i)=f(i-1)
    3. 当前数字为0，且前一数字与当前数字可合并且<26
        - f(i)=f(i-2)
    4. 当前数字为0，且与前一数字不可合并如306，不符合题目
        - f(i)=0
- 方案：
    1. 初始化dp、初始化边界dp[0]=1。
        - 默认所有数字情况都为0，对应情况4
    2. 遍历1~n
        1. 当s[i-1]不为0，添加dp[i]+=dp[i-1];
            - 对应情况1、2
        2. 当s[i-2]不为0并且s[i-2]与s[i-1]<=26时，添加dp[i]+=dp[i-1]
            - 对应情况1、3
    3. 返回dp[n]

### (二)打家劫舍系列
- 有点像限定了条件的【前缀和】

#### 打家劫舍 q198
- 重点：劫舍必须隔着房子
- dp表：房子比作商品,按商品数量进行遍历
    - 即只有1间、2间...房子可劫舍
- 状态选择：在劫舍与不劫舍中取最大价值，即max(dp[i-1],dp[i-2]+nums[i]);
- 方案：
    1. 初始化dp，初始化第一、二间的最大价值
    2. 初始化dp，初始化第一、二间的最大价值
    3. 保存dp[i]最大价值即max(dp[i-1],dp[i-2]+nums[i])
    4. 返回dp[n-1]
- 状态压缩：循环只用到了i,i-1,i-2三个变量

#### 打家劫舍2 q213
- 同q198，只是取去除第一间或去除最后一间最大值即Max([0,n-1],[1,n])

#### 打家劫舍3 q337
#### 方法一：记忆化递归
- 重点：
    1. 使用后序遍历，使得可以遍历到每一颗子树。
        - 如下图为：[3][2,3][1,2,3][4,1,2,3]
        - 打家劫舍：rob(3)、rob(2,3、rob(1,2,3)、rob(4,1,2,3)
    2. 使用记忆化搜索可以避免重复计算子树，实现与【打家劫舍1】一维数组的效果
        - 打家劫舍记忆化：rob(3)、rob(2,res(3))、rob(1,res(2,3)、rob(4,res(1,2,3))
            - 这是斜树的例子，满二叉树的话则存在更多重复的计算
            - 从抽象来看的话，树的底部相当于一维dp的0，树的root相当于一维dp的n
    3. 状态选择：偷与不偷的最大值
- dp数组就是map，只是n为树的深度
- 方案：
    1. 判断root是否存在于map，是直接返回
    2. val1保存偷爷孙节点的值
        - 爷即root.val
        - 孙即root.left.left/right和root.right.left/right
    3. val2保存偷子节点的值
        - 即root.left/right
    4. 保存max(val1,val2)到map中并返回

![image](http://note.youdao.com/yws/res/46454/94804D0C8F3C46AF806F7B605654859E)
#### 方法二：树型DP
- 思路同方法一基本相同，只是将偷与不偷的结果由map换成int
- dp数组的每个元素就是每层的[不偷,偷]数组，长度n依然是树的深度
- 方案：
    1. 记录偷的结果为root.val+left[0]+right[0]
        - 其中下标0存放的是不偷的结果，1存放的是偷的结果
    2. 记录不偷的结果为Math.max(left[0],left[1])+max(right[0],right[1])
        - 偷的话应当保存子节点的一偷与不偷的最大值
    3. 后序遍历回到root节点，返回root节点偷与不偷的最大值

![image](http://note.youdao.com/yws/res/46451/B1801D26C6214A3DBA9155980BB3A75D)

## 二、分割整数问题
- 思想：将一个整数拆分成两个子整数，子整数根据目标（如最大乘积）可选择继续拆分，可抽象成一颗二叉树
- 动态规划三板斧(以最大乘积为例)：
    - 子问题：求每个整数的分割子整数最大乘积
    - 最优子结构：每个数字最大乘积都由子整数相乘而得，子问题之间不耦合，同时后续最大乘积由前子问题（整数）最大乘积推导而出
    - 状态转移：
        - 状态：每个整数的分割子整数最大相乘值
        - 选择：分割一次与多次分割中选择乘积最大的值
            - 如5：
            1. 3*2
            2. 2*2*1

#### 分割整数的最大乘积 q343
- 方案：
    1. 初始化dp[n+1]，设有效最小整数的最大乘积即d[2]=1
    2. 遍历i为[3~n]，计算每个整数最大乘积
        1. 遍历1~i/2，动态保存最大乘积
            1. 保存分割一次与分割多次中的最大值max
            2. 更新dp[i]为max(max,dp[i])
    3. 返回dp[n]

#### 按平方数来分割整数 q279
- 思想：
    - 子问题：整数最少完全平方数组成
    - 最优子结构：每个整数计算过程不影响其他整数
    - 状态转移：当前子问题由前面某最优子问题组成，即Math.min(dp[i], dp[i - j * j] + 1)
- 方案：
    1. 遍历1~n
        1. 初始化dp,dp[i] = i;
        2. 遍历完全平方数j*j<i
            - 动态保存最少数量，即dp[i]=min(dp[i],dp[i-j*j]+1)
    2. 返回结果

## 三、矩阵路径问题
### (一)矩阵路径——组合问题
#### 不同路径 q62
- 重点：
    1. 当只存在一行或一列时，最多只有一条路径，所以初始化dp表第一行/列值均为1
    2. 能到达任意右下角路径都等于dp[i-1][j]+dp[i][j-1]
- 方案：
  1.初始化第一行/列为1
    2. 遍历每一行每一列，设dp[i][j]=上+左（对应着往下和往右走的路径和）
- 路径压缩：dp[j]=dp[j]+dp[j-1]中右边的dp[j]即为【上】的值，dp[j-1]即为已更新的【左】值

#### 不同路径2 q63
- 解决方案：思路同q62，不同：
    1. 当是第一行/列如果遇到障碍，则之后的路径值全改为0。
    2. 计算路径之和时，遇到1则continue
- 原地替换法：
    1. 当是第一行/列如果遇到障碍，则之后的路径值原地全改为0。
    2. 计算路径之和时，遇到1时原地改为0再continue

### (二)矩阵路径——最值问题
#### 最小路径和 q64
- 重点：同组合问题，但是是保存当前值grid[i][j]+min(左，上)
- 方案：同组合问题，只是取路径值小的值，即grid[i][j]+min(左，上)
- 原地修改法：将grid直接作为dp，即将dp值放入grid中

## 四、背包问题
![image](http://note.youdao.com/yws/res/46015/404EDD8092504ABA8D9E32FF6E731963)

- 0/1背包与完全背包的区别：
    - 商品可重复/无限：完全背包
        1. 最值问题
        2. 组合问题
    - 商品为限定/位移：0/1背包
        1. 组合问题（中找个最值）
- 0/1与完全背包遍历区别：
    - 0/1：内层循环(状态)逆序
    - 完全背包：内层循环(状态)正序

### 0/1背包
### (一)0/1背包——最值问题
#### 例题：0/1背包原型题
- 背包在有限重量下保存最大价值的商品组合
- 唯一状态：背包容量、商品
- 但目标为商品的价值，所以【商品】外层循环枚举为【商品】

#### DP题解
- 状态：背包的容量、可选择的商品
- 选择：装进背包与否
    - 是否装进背包取决于商品的重量与价值。
    - 即到【包含上一个商品的该背包重量的最大价值】与【包含当前商品的该背包重量的最大价值】谁大
        1. 准确的说是能够容纳的情况下每单位重量的商品价值谁的更大
        2. 当然如果商品选择不多而背包人容量大的话则以能够装满背包为主
- 重点：目标在于最大价值且商品的数量有限(只有一件)，所以外层循环为遍历商品，而内层循环才是背包容量
- 方案：
    1. 初始化dp table二维数组[goods][weight]，意义为在背包重量为weight时，包含前goods个商品最大价值组合
        1. 第一维：前goods个商品
        2. 第二维：当前背包重量weight
    2. 外层循环，枚举每种商品
    3. 内存循环，枚举每个背包重量
        1. 当背包不能装下新商品时，设截止至当前商品的背包最大价值组合等于截止至上一商品的背包最大价值组合
        2. 当背包能装下商品时，比较保存单位重量的最大价值
            1. 当前商品
            2. 截止至上一商品最大价值商品组合
    4. 返回包含N个商品背包重量为W的最大价值组合的值

#### 状态压缩
- 压缩前：dp[商品种类+1][背包重量]
- 压缩后：dp[背包重量]
- 注意：循环背包重量必须从大到小，因为装入背包时涉及【背包重量减去当前商品重量的最大价值组合】即小重量。
    - 如从小到大，则【背包重量减去当前商品重量的最大价值组合】为【当前商品】
        - 此时背包存在两个当前商品
    - 如从大到小，则【背包重量减去当前商品重量的最大价值组合】为【上一商品】
        - 此时背包存在一个当前商品

#### 一和零 q474 0/1双格背包 【特殊题】
- 复杂度：O(strsLen*N*M) O((N+1)*(M+1))
- 双格背包：即多了一层需要判断，dp多个维度左存放。此外与单格背包五任何区别
- 方案：
    1. 初始化dp[m+1][n+1]
        - 已状态压缩
    2. 外层循环遍历每个(商品)
        - 统计str每个(商品)中'0'和'1'的数量
    3. 内存循环遍历计算子集数量
        1. 当前商品'0'的数量<=m，状态压缩+商品唯一所以逆序
        2. 当前商品'1'的数量<=n，状态压缩+商品唯一所以逆序
            1. 保存最大子集数量即dp[i][j]=max(dp[i][j],dp[i-零的数量][j-1的数量])
    4. 返回dp[m][n]

### (二)0/1背包——元素和
#### 例题：分割等和子集 q416
#### 方法一：0/1背包
- 重点：将nums[]数组的元素值当作商品重量，[0~target]为背包容量。每次尽可能的容纳商品，放不下背包忽略，放的下背包则判定是否等于target
- 方案：
    1. 总和是奇数之间返回false
    2. 以nums[]作为商品，放在外层循环
    3. 以[0,target]作为背包重量放在内层循环
        1. 背包尽可能保存商品，放不下跳过
        2. 放得下判断是否等于target

#### 最后一块石头的重量2 q1049
- 解题：
    1. 最后一块石头重量，即为两个集合之差
    2. 需求最小重量，即两个集合的重量尽可能接近石头总重量的平均数。即求一个集合尽可能接近平均数即可
- 重点：
    1. 将石头比作商品，设定目标重量（总重量/2）为背包容量，即[1,总重量/2]
    2. 背包在能容纳商品的前提下，尽可能存放商品以接近平均数
        - 如75最好结果是73和78，此设计则在背包重量为75的时候取得73
- 方案：
    1. 计算石头总重量/2
    2. 初始dp[总重量/2+1]
    3. 外层循环遍历每块石头
        - 因为是商品有限
    4. 内层循环遍历背包重量
        1. 当背包放的下商品时，保存替换商品与否的最大重量
    5. 返回总重量-dp[target]*2，即两个集合之差

### (三)0/1背包——元素和的组合
#### 目标和 q419
- 重点：将问题转换为0/1背包
    1. 要使得每个元素前加'+'或'-'，最终使得sum=S。而将'+'和'-'的元素分为两个子集。那么两个子集之和的绝对值差值必定等于S。转换为背包问题，就只需要找到其中一个子集即可
    2. 将1的思路转换为子集公式存在以下两种（任选一）：
        1. target子集由S=sum-(子集*2)推导出：target=(sum-S)/2
        2. target子集=子集+子集-sum=S：target=(S+sum)/2
    3. S的正数或负数的组合数是相同的
    4. 当目标子集和即target=0时，无论存在任意数量商品，都可通过不放进背包而得出1种组合可能，所以初始化dp[i][0]=1
    5. 由于nums[]数组对应背包问题中的商品，那么元素是有限即商品是有限的，即0/1背包问题。所以计算组合数的时候，加的是上一商品重量的组合数
        - 这样不会出现两个当前商品的情况
- 方案：
    1. 计算总数sum，计算target=(sum-S)/2
    2. 当sum<S或(sum-S)%2==1时直接返回0种组合数
    3. 初始化dp[target]，初始化当背包重量为0时，存在0种组合方式
    4. 外层循环遍历商品
    5. 内存循环遍历[0,target]的背包重量
        1. 计算组合数即dp[weight]=dp[weight-1]+dp[weight-nums[goods]]
    6. 返回dp[target]

### 完全背包
### (一)完全背包——最值问题
- 背包与商品谁是外循环(对应排列或组合)都不影响结果

#### 例题：零钱兑换最少硬币 q322
- 再无限硬币的前提下，兑换指定金额的最小数量的零钱
- 唯一状态：背包容量

#### DP题解
- 状态：需要兑换的额度、硬币面额
- 选择：是否添加改枚硬币
- 重点：目标在于硬币的数量，所以保存额度兑换最小数量硬币
- 关键步骤：
    - 遍历每种硬币额度
        1. 剩余金额balance等于amount-硬币额度
        2. 当剩余金额>=0，说明该硬币排列可行，保存dp[当前金额]=dp[当前金额]与1+dp[剩余金额]的最小

#### 单词拆分 q139
- 重点：
    1. 以s的每个位置作为背包的重量，字典中每个商品
- 方案：
    1. 初始化dp表，当为空串是为true，即dp[0]=true
    2. 由于商品无限，所以正序遍历每个背包重量/每个终点
        - 复杂化来说已经进行了状态压缩
    3. 遍历每个单词
        1. 状态选择：当word可放入背包/在字典可查到时，保存当前背包结果与前一结果为true的一方
            - 即dp[i]||dp[i-len]
        2. 找到true，可直接break剪枝
    4. 返回dp[n]

### (二)完全背包——组合问题
#### 例题：零钱兑换组合数 q518
- 状态：背包的容量、可选择的物品
- 选择：装进背包与否
- 重点：目标在于达到金额的所有硬币组合数，所以外层循环为遍历商品(硬币)，而内层循环才是背包容量(金额)
- 方案：
    1. 初始化dp[商品数+1][目标金额+1]
    2. 初始化dp设所有[商品][0]等于1
        - 当金额为0时默认存在一种组合所以等于1
    3. 外层循环枚举每个商品，内层循环递增背包容量
        1. 当背包放不下该商品时，当前商品组合数等于【上一商品】的组合数
        2. 当背包放得下该商品时，当前商品组合数等于【上一商品】商品组合数+【背包重量减去当前商品重量】的商品组合数
            - 因为是组合数，所以关注的是背包重量减去商品重量的重量，而不是商品的重量
    4. 返回[商品][目标背包重量]

#### 状态压缩
- 目标：恰好达到目标金额的所有硬币组合数
- 压缩前：dp[硬币种类][金额+1]
- 压缩后：dp[金额+1]
    - 由于商品是无限，所以当尽可能保存所有的可能，所以金额枚举从0~目标金额

### (三)完全背包——排列问题
#### 组合总和4 q377
- 重点：题目将不同顺序的序列也视为组合，所以其实是求所有排列情况，是排列问题
- 方案：
    1. 初始化dp，当目标数字为0时存在1种排列方式(即不选)
    2. 外循环为"背包重量"
    3. 内循环为"商品"
    4. 当背包放的下商品时，保存排列数
    5. 返回dp[目标背包重量]

## 五、股票买卖问题【多状态转移】
- 贪心思想解法位于贪心题解模块

#### 买卖股票的最佳时机 q121【双状态转移】
- 子问题：在已知的时间与价格中找到左小右大最大的差值
- 最优子结构：买卖相互不影响
- 状态转移：
    1. 是否选择持有，选择持有的目标是股票价格最便宜
    2. 是否选择卖出，卖出的目标是当天卖出比前一天卖出赚的更多现金

#### 方法一：暴力法优化/贪心
- 重点：不断在卖出前找到股票价格最小的一天，不断以当天价格-最小价格的一天，保存其中最大值

#### 方法二：DP
- 重点：由状态转移得出存在两种选择，所以DP需设定两种情况，买入股票时手上的现金情况，与卖出后股票后手上的现金情况
- 方案：
    - 未持有和售出股票时是，手上的现金设为0
    1. 初始化双dp或者dp[2][n]
        - 两个一维数组对应着持有股票时手上现金和售出股票后手上现金
        - 设dp[0]为持有股票dp
        - 设dp[1]为售出股票dp
    2. 初始化第一天持有股票即dp[0][0]=-price[0]
    3. 遍历[1,n)，
        - 动态保存当天与昨天持有股票时手上现金最大的情况（即股票价格最低）
        - 动态保存当天售出与昨天售出股票时手上现金的最大情况
    4. 返回最后一天售出股票时的值即dp[1][n]
- 状态压缩：股票的持有情况和售出情况都只涉及到一个值的存储，即股票价格最低或者售出利润最大值。可用常亮代替dp表。
    - 代替后即与【贪心算法】一模一样

#### 买卖股票的最佳时机 q122【双状态转移】
#### 方法一：贪心
- 枚举累加每天相邻交易差值为正数的总和

#### 方法二：DP
- 与一次买卖的差别：需要将先前交易的利润也计入，买入/持有股票的计算。
    - 方式是：
        1. 将先前的利润也放入股票买入/持有的计算的dp中。
        2. 通过卖出股票，会将先前交易利润归入到卖出后手上持有的金额的dp中
- 方案：
    1. 初始化dp[2][n]，dp[0][0]=-price[0]
        - dp[0]持有股票时手上的现金
        - dp[1]售出股票时手上的现金
    2. 遍历[1,n)
        1. 保存前一天与当天持有金额最大值dp[0][i]=max(dp[0][i-1],-price[i]+dp[1][i-1])
        2. 保存当天卖出获得的最大利润dp[1][i]=max(dp[1][i-1],dp[0][i-1]+price[i])
            - 此时股票的价格中加入了前面交易的利润，一起保存
    3. 返回dp[1][n]
- 状态压缩：先计算售出股票时手上的现金，再计算买入/持有股票时手上的现金。
    - 这样当天售出股票可得到前一天持有的情况
    - 而当天买入/持有股票也可获得今天(假如)卖出手上持有的利润
        - 不可能再持有今天的股票，因为假如是更新今天售出后手上持有的金额。那么买入股票取max的-price[i]+soldCash一定不大于前一天的holdCash。所以是为了明天的股票交易而更新

#### 买卖股票的最佳时机 q123 【五状态转移】
#### 方法一：DP
- 状态转移：
    1. 第一次买入、卖出：始终取得最大利润的一次交易
        - 即与q121的思路一模一样
    2. 第二次买入、卖出：在取得上一次最大交易收益（即第二大）的基础上，再取一次同样最大或第二大的收益交易。
        - 即与q122的基本思路相同，到了第二次买入的时候，不同于q122手上只有最大的一次收益。
    3. 买入结果：上一次交易最大收益+当前交易的最大收益交易，即两次买卖股票的最佳时机
    - 五次状态转移：
        - 不交易：(可直接用0替代即可忽略，但考虑后面还有一题冷冻期)
        - 第一次买入股票：始终保存最小股票价格，或者不交易
        - 第一次卖出股票：始终保存取得最大的收益
        - 第二次买入股票：基于上一次交易的收益（如有进行交易）保存最小股票价格
        - 第二次卖出股票：基于上一次交易的收益（如由进行交易）保存取得最大的收益
- 方案：
    1. 初始化五个状态
        - dp[0][0]不交易=0
        - dp[1][0]第一次股票持有现金=-price[0]
        - dp[2][0]第一次交易后持有现金=0
        - dp[3][0]第二次股票持有现金=-price[0]
        - dp[4][0]第二次交易后持有现金=0
    2. 遍历[1,n)天的股票
        1. 使得dp[0][i]始终不交易状态即=dp[0][i—1]
        2. dp[1][i]取得当前股票最小值/持有最大现金
            - 即max(0,price[i])
        3. dp[2][i]取得出售股票后的最大收益
            - 即max(dp[2][i-1],dp[1][i-1]+price[i])
        4. dp[3][i]取得基于第一次交易收益的持有股票最大现金
            - 即max(dp[3][i-1],dp[2][i-1]-price[i])
        5. dp[4][i]取得基于第一次交易收益的再次股票交易最大收益
            - 即max(dp[4][i-1],dp[3][i-1]+price[i])
    3. 返回dp[4][n]
- 状态压缩：同q121、q122的思路
    - firstHoldCash：始终保存最小的股票价格
    - firstSoldCash：始终保存最大交易收益
    - secondHoldCash：基于第一次交易收益再找最小的股票价格
    - secondSoldCash：基于第一次交易收益保存最大交易收益（即两次）
    - 遍历，先出售股票再更新持有，这样出售最小股票是今天之前的，不会少了前一天的股票价格情况。
        - 如[1,2]先持有再售出为2-2=0，先售出再持有则2-1=1

##### 运行实例：第一次交易始终保存最大交易收益，第二次交易则基于上一次的最大交易收益再保存最大交易收益
![image](http://note.youdao.com/yws/res/46762/7D60B88BC49E4B018FCB6FCDE4253D34)
![image](http://note.youdao.com/yws/res/46759/3D1A044B20C24175B877EED54F7A8557)