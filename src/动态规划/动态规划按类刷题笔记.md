## 一、斐波那契数列问题
#### 爬楼梯 q70
- 状态：目标楼梯阶数、可选择的步伐
- 选择：走几个台阶
- 推导公式：dp[i]=dp[i-1]+dp[i-2]
- 初始化dp:dp[1]=1,dp[2]=2
- 重点：即为Fibonacci

#### 使用最小花费爬楼梯 q746
- 状态：目标楼梯阶数
- 选择：走几个台阶
- 推导公式：dp[i]=min(dp[i-1],dp[i-2])+cost[i]
- 初始化：dp[0]=cost[0],dp[1]==cost[1]
- 步骤：
    1. 初始化dp[cost.lenth]
    2. 初始化dp[0]dp[1]
        1. 遍历每个台阶
            - 执行推导公式
    3. min(dp[len - 1], dp[len - 2]);
        - 最后一步不用花费，倒走1或2步

#### 分割整数构成字母字符串 q91
- 重点：四种情况
    1. 当前数字不为0，且前一数字与当前数字可合并即<=26
        - f(i)=f(i-1)+f(i-2)
    2. 当前数字不为0，且前一数字与当前数字不可合并即>26
        - f(i)=f(i-1)
    3. 当前数字为0，且前一数字与当前数字可合并且<26
        - f(i)=f(i-2)
    4. 当前数字为0，且与前一数字不可合并如306，不符合题目
        - f(i)=0
- 方案：
    1. 初始化dp、初始化边界dp[0]=1。
        - 默认所有数字情况都为0，对应情况4
    2. 遍历1~n
        1. 当s[i-1]不为0，添加dp[i]+=dp[i-1];
            - 对应情况1、2
        2. 当s[i-2]不为0并且s[i-2]与s[i-1]<=26时，添加dp[i]+=dp[i-1]
            - 对应情况1、3
    3. 返回dp[n]

## 二、分割整数问题
- 思想：将一个整数拆分成两个子整数，子整数根据目标（如最大乘积）可选择继续拆分，可抽象成一颗二叉树
- 动态规划三板斧(以最大乘积为例)：
    - 子问题：求每个整数的分割子整数最大乘积
    - 最优子结构：每个数字最大乘积都由子整数相乘而得，子问题之间不耦合，同时后续最大乘积由前子问题（整数）最大乘积推导而出
    - 状态转移：
        - 状态：每个整数的分割子整数最大相乘值
        - 选择：分割一次与多次分割中选择乘积最大的值
            - 如5：
            1. 3*2
            2. 2*2*1

#### 分割整数的最大乘积 q343
- 方案：
    1. 初始化dp[n+1]，设有效最小整数的最大乘积即d[2]=1
    2. 遍历i为[3~n]，计算每个整数最大乘积
        1. 遍历1~i/2，动态保存最大乘积
            1. 保存分割一次与分割多次中的最大值max
            2. 更新dp[i]为max(max,dp[i])
    3. 返回dp[n]

#### 按平方数来分割整数 q279
- 思想：
    - 子问题：整数最少完全平方数组成
    - 最优子结构：每个整数计算过程不影响其他整数
    - 状态转移：当前子问题由前面某最优子问题组成，即Math.min(dp[i], dp[i - j * j] + 1)
- 方案：
    1. 遍历1~n
        1. 初始化dp,dp[i] = i;
        2. 遍历完全平方数j*j<i
            - 动态保存最少数量，即dp[i]=min(dp[i],dp[i-j*j]+1)
    2. 返回结果

## 三、矩阵路径问题
### (一)矩阵路径——组合问题
#### 不同路径 q62
- 重点：
    1. 当只存在一行或一列时，最多只有一条路径，所以初始化dp表第一行/列值均为1
    2. 能到达任意右下角路径都等于dp[i-1][j]+dp[i][j-1]
- 方案：
  1.初始化第一行/列为1
    2. 遍历每一行每一列，设dp[i][j]=上+左（对应着往下和往右走的路径和）
- 路径压缩：dp[j]=dp[j]+dp[j-1]中右边的dp[j]即为【上】的值，dp[j-1]即为已更新的【左】值

#### 不同路径2 q63
- 解决方案：思路同q62，不同：
    1. 当是第一行/列如果遇到障碍，则之后的路径值全改为0。
    2. 计算路径之和时，遇到1则continue
- 原地替换法：
    1. 当是第一行/列如果遇到障碍，则之后的路径值原地全改为0。
    2. 计算路径之和时，遇到1时原地改为0再continue

### (二)矩阵路径——最值问题
#### 最小路径和 q64
- 重点：同组合问题，但是是保存当前值grid[i][j]+min(左，上)
- 方案：同组合问题，只是取路径值小的值，即grid[i][j]+min(左，上)
- 原地修改法：将grid直接作为dp，即将dp值放入grid中

## 四、背包问题
![image](http://note.youdao.com/yws/res/46015/404EDD8092504ABA8D9E32FF6E731963)

- 0/1背包与完全背包的区别：
    - 商品可重复/无限：完全背包
        1. 最值问题
        2. 组合问题
    - 商品为限定/位移：0/1背包
        1. 组合问题（中找个最值）
- 0/1与完全背包遍历区别：
    - 0/1：内层循环(状态)逆序
    - 完全背包：内层循环(状态)正序

### 0/1背包
### (一)0/1背包——最值问题
#### 例题：0/1背包原型题
- 背包在有限重量下保存最大价值的商品组合
- 唯一状态：背包容量、商品
- 但目标为商品的价值，所以【商品】外层循环枚举为【商品】

#### DP题解
- 状态：背包的容量、可选择的商品
- 选择：装进背包与否
    - 是否装进背包取决于商品的重量与价值。
    - 即到【包含上一个商品的该背包重量的最大价值】与【包含当前商品的该背包重量的最大价值】谁大
        1. 准确的说是能够容纳的情况下每单位重量的商品价值谁的更大
        2. 当然如果商品选择不多而背包人容量大的话则以能够装满背包为主
- 重点：目标在于最大价值且商品的数量有限(只有一件)，所以外层循环为遍历商品，而内层循环才是背包容量
- 方案：
    1. 初始化dp table二维数组[goods][weight]，意义为在背包重量为weight时，包含前goods个商品最大价值组合
        1. 第一维：前goods个商品
        2. 第二维：当前背包重量weight
    2. 外层循环，枚举每种商品
    3. 内存循环，枚举每个背包重量
        1. 当背包不能装下新商品时，设截止至当前商品的背包最大价值组合等于截止至上一商品的背包最大价值组合
        2. 当背包能装下商品时，比较保存单位重量的最大价值
            1. 当前商品
            2. 截止至上一商品最大价值商品组合
    4. 返回包含N个商品背包重量为W的最大价值组合的值

#### 状态压缩
- 压缩前：dp[商品种类+1][背包重量]
- 压缩后：dp[背包重量]
- 注意：循环背包重量必须从大到小，因为装入背包时涉及【背包重量减去当前商品重量的最大价值组合】即小重量。
    - 如从小到大，则【背包重量减去当前商品重量的最大价值组合】为【当前商品】
        - 此时背包存在两个当前商品
    - 如从大到小，则【背包重量减去当前商品重量的最大价值组合】为【上一商品】
        - 此时背包存在一个当前商品

### (二)0/1背包——元素和
#### 例题：分割等和子集 q416
#### 方法一：0/1背包
- 重点：将nums[]数组的元素值当作商品重量，[0~target]为背包容量。每次尽可能的容纳商品，放不下背包忽略，放的下背包则判定是否等于target
- 方案：
    1. 总和是奇数之间返回false
    2. 以nums[]作为商品，放在外层循环
    3. 以[0,target]作为背包重量放在内层循环
        1. 背包尽可能保存商品，放不下跳过
        2. 放得下判断是否等于target

#### 最后一块石头的重量2 q1049
- 解题：
    1. 最后一块石头重量，即为两个集合之差
    2. 需求最小重量，即两个集合的重量尽可能接近石头总重量的平均数。即求一个集合尽可能接近平均数即可
- 重点：
    1. 将石头比作商品，设定目标重量（总重量/2）为背包容量，即[1,总重量/2]
    2. 背包在能容纳商品的前提下，尽可能存放商品以接近平均数
        - 如75最好结果是73和78，此设计则在背包重量为75的时候取得73
- 方案：
    1. 计算石头总重量/2
    2. 初始dp[总重量/2+1]
    3. 外层循环遍历每块石头
        - 因为是商品有限
    4. 内层循环遍历背包重量
        1. 当背包放的下商品时，保存替换商品与否的最大重量
    5. 返回总重量-dp[target]*2，即两个集合之差

### 完全背包
### (一)完全背包——最值问题
#### 例题：零钱兑换最少硬币 q322
- 再无限硬币的前提下，兑换指定金额的最小数量的零钱
- 唯一状态：背包容量

#### DP题解
- 状态：需要兑换的额度、硬币面额
- 选择：是否添加改枚硬币
- 重点：目标在于硬币的数量，所以保存额度兑换最小数量硬币
- 关键步骤：
    - 遍历每种硬币额度
        1. 剩余金额balance等于amount-硬币额度
        2. 当剩余金额>=0，说明该硬币组合可行，保存dp[当前金额]=dp[当前金额]与1+dp[剩余金额]的最小

### (二)完全背包——组合问题
#### 例题：零钱兑换组合数 q518
- 与0-1背包的区别：商品数量是无限的
- 唯一状态：背包容量、商品

#### DP题解：
- 状态：背包的容量、可选择的物品
- 选择：装进背包与否
- 重点：目标在于达到金额的所有硬币组合数，所以外层循环为遍历商品(硬币)，而内层循环才是背包容量(金额)
- 方案：
    1. 初始化dp[商品数+1][目标金额+1]
    2. 初始化dp设所有[商品][0]等于1
        - 当金额为0时默认存在一种组合所以等于1
    3. 外层循环枚举每个商品，内层循环递增背包容量
        1. 当背包放不下该商品时，当前商品组合数等于【上一商品】的组合数
        2. 当背包放得下该商品时，当前商品组合数等于【上一商品】商品组合数+【背包重量减去当前商品重量】的商品组合数
            - 因为是组合数，所以关注的是背包重量减去商品重量的重量，而不是商品的重量
    4. 返回[商品数][目标背包重量]

#### 状态压缩
- 目标：恰好达到目标金额的所有硬币组合数
- 压缩前：dp[硬币种类][金额+1]
- 压缩后：dp[金额+1]
    - 由于商品是无限，所以当尽可能保存所有的可能，所以金额枚举从0~目标金额