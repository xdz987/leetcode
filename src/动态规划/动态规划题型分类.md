## 一、矩阵路径问题
### (一)矩阵路径——组合问题
#### 不同路径 q62
- 重点：
    1. 当只存在一行或一列时，最多只有一条路径，所以初始化dp表第一行/列值均为1
    2. 能到达任意右下角路径都等于dp[i-1][j]+dp[i][j-1]
- 方案：
  1.初始化第一行/列为1
    2. 遍历每一行每一列，设dp[i][j]=上+左（对应着往下和往右走的路径和）
- 路径压缩：dp[j]=dp[j]+dp[j-1]中右边的dp[j]即为【上】的值，dp[j-1]即为已更新的【左】值

#### 不通路径2 q63
- 解决方案：思路同q62，不同：
    1. 当是第一行/列如果遇到障碍，则之后的路径值全改为0。
    2. 计算路径之和时，遇到1则continue
- 原地替换法：
    1. 当是第一行/列如果遇到障碍，则之后的路径值原地全改为0。
    2. 计算路径之和时，遇到1时原地改为0再continue

### (二)矩阵路径——最值问题
#### 最小路径和 q64
- 重点：同组合问题，但是是保存当前值grid[i][j]+min(左，上)
- 方案：同组合问题，只是取路径值小的值，即grid[i][j]+min(左，上)
- 原地修改法：将grid直接作为dp，即将dp值放入grid中

## 二、背包问题
- 0/1背包与完全背包的区别：
    - 商品可重复/无限：完全背包
        1. 最值问题
        2. 组合问题
    - 商品为限定/位移：0/1背包
        1. 组合问题（中找个最值）
- 0/1与完全背包遍历区别：
    - 0/1：内层循环(状态)逆序
    - 完全背包：内层循环(状态)正序

### 0/1背包
### (一)0/1背包——最值问题
#### 例题：0/1背包原型题
- 背包在有限重量下保存最大价值的商品组合
- 唯一状态：背包容量、商品
- 但目标为商品的价值，所以【商品】外层循环枚举为【商品】

#### DP题解
- 状态：背包的容量、可选择的商品
- 选择：装进背包与否
    - 是否装进背包取决于商品的重量与价值。
    - 即到【包含上一个商品的该背包重量的最大价值】与【包含当前商品的该背包重量的最大价值】谁大
        1. 准确的说是能够容纳的情况下每单位重量的商品价值谁的更大
        2. 当然如果商品选择不多而背包人容量大的话则以能够装满背包为主
- 重点：目标在于最大价值且商品的数量有限(只有一件)，所以外层循环为遍历商品，而内层循环才是背包容量
- 方案：
    1. 初始化dp table二维数组[goods][weight]，意义为在背包重量为weight时，包含前goods个商品最大价值组合
        1. 第一维：前goods个商品
        2. 第二维：当前背包重量weight
    2. 外层循环，枚举每种商品
    3. 内存循环，枚举每个背包重量
        1. 当背包不能装下新商品时，设截止至当前商品的背包最大价值组合等于截止至上一商品的背包最大价值组合
        2. 当背包能装下商品时，比较保存单位重量的最大价值
            1. 当前商品
            2. 截止至上一商品最大价值商品组合
    4. 返回包含N个商品背包重量为W的最大价值组合的值

#### 状态压缩
- 压缩前：dp[商品种类+1][背包重量]
- 压缩后：dp[背包重量]
- 注意：循环背包重量必须从大到小，因为装入背包时涉及【背包重量减去当前商品重量的最大价值组合】即小重量。
    - 如从小到大，则【背包重量减去当前商品重量的最大价值组合】为【当前商品】
        - 此时背包存在两个当前商品
    - 如从大到小，则【背包重量减去当前商品重量的最大价值组合】为【上一商品】
        - 此时背包存在一个当前商品

### (二)0/1背包——查值问题
#### 例题：分割等和子集 q416
#### 方法一：0/1背包
- 重点：将nums[]数组的元素值当作商品重量，[0~target]为背包容量。每次尽可能的容纳商品，放不下背包忽略，放的下背包则判定是否等于target
- 方案：
    1. 总和是奇数之间返回false
    2. 以nums[]作为商品，放在外层循环
    3. 以[0,target]作为背包重量放在内层循环
        1. 背包尽可能保存商品，放不下跳过
        2. 放得下判断是否等于target

### 完全背包
### (一)完全背包——最值问题
#### 例题：零钱兑换最少硬币 q322
- 再无限硬币的前提下，兑换指定金额的最小数量的零钱
- 唯一状态：背包容量

#### DP题解
- 状态：需要兑换的额度、硬币面额
- 选择：是否添加改枚硬币
- 重点：目标在于硬币的数量，所以保存额度兑换最小数量硬币
- 关键步骤：
    - 遍历每种硬币额度
        1. 剩余金额balance等于amount-硬币额度
        2. 当剩余金额>=0，说明该硬币组合可行，保存dp[当前金额]=dp[当前金额]与1+dp[剩余金额]的最小

### (二)完全背包——组合问题
#### 例题：零钱兑换组合数 q518
- 与0-1背包的区别：商品数量是无限的
- 唯一状态：背包容量、商品

#### DP题解：
- 状态：背包的容量、可选择的物品
- 选择：装进背包与否
- 重点：目标在于达到金额的所有硬币组合数，所以外层循环为遍历商品(硬币)，而内层循环才是背包容量(金额)
- 方案：
    1. 初始化dp[商品数+1][目标金额+1]
    2. 初始化dp设所有[商品][0]等于1
        - 当金额为0时默认存在一种组合所以等于1
    3. 外层循环枚举每个商品，内层循环递增背包容量
        1. 当背包放不下该商品时，当前商品组合数等于【上一商品】的组合数
        2. 当背包放得下该商品时，当前商品组合数等于【上一商品】商品组合数+【背包重量减去当前商品重量】的商品组合数
            - 因为是组合数，所以关注的是背包重量减去商品重量的重量，而不是商品的重量
    4. 返回[商品数][目标背包重量]

#### 状态压缩
- 目标：恰好达到目标金额的所有硬币组合数
- 压缩前：dp[硬币种类][金额+1]
- 压缩后：dp[金额+1]
    - 由于商品是无限，所以当尽可能保存所有的可能，所以金额枚举从0~目标金额