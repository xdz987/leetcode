## 一、路径问题


## 二、背包问题
### (一)0/1背包问题
#### 例题：q416
 - 背包在有限重量下保存最大价值的商品组合
 - 唯一状态：背包容量、商品
 - 但目标为商品的价值，所以【商品】外层循环枚举为【商品】

#### DP题解
 - 状态：背包的容量、可选择的商品
 - 选择：装进背包与否
    - 是否装进背包取决于商品的重量与价值。
    - 即到【包含上一个商品的该背包重量的最大价值】与【包含当前商品的该背包重量的最大价值】谁大
        1. 准确的说是能够容纳的情况下每单位重量的商品价值谁的更大
        2. 当然如果商品选择不多而背包人容量大的话则以能够装满背包为主
 - 重点：目标在于最大价值且商品的数量有限(只有一件)，所以外层循环为遍历商品，而内层循环才是背包容量
 - 方案：
    1. 初始化dp table二维数组[goods][weight]，意义为在背包重量为weight时，包含前goods个商品最大价值组合
        1. 第一维：前goods个商品
        2. 第二维：当前背包重量weight
    2. 外层循环，枚举每种商品
    3. 内存循环，枚举每个背包重量
        1. 当背包不能装下新商品时，设截止至当前商品的背包最大价值组合等于截止至上一商品的背包最大价值组合
        2. 当背包能装下商品时，比较保存单位重量的最大价值
            1. 当前商品
            2. 截止至上一商品最大价值商品组合
    4. 返回包含N个商品背包重量为W的最大价值组合的值

#### 状态压缩
 - 压缩前：dp[商品种类+1][背包重量]
 - 压缩后：dp[背包重量]
 - 注意：循环背包重量必须从大到小，因为装入背包时涉及【背包重量减去当前商品重量的最大价值组合】即小重量。
    - 如从小到大，则【背包重量减去当前商品重量的最大价值组合】为【当前商品】
        - 此时背包存在两个当前商品
    - 如从大到小，则【背包重量减去当前商品重量的最大价值组合】为【上一商品】
        - 此时背包存在一个当前商品

### (二)完全背包问题
#### 例题：q322
 - 再无限硬币的前提下，兑换指定金额的最小数量的零钱
 - 唯一状态：背包容量

#### DP题解
 - 状态：需要兑换的额度、硬币面额
 - 选择：是否添加改枚硬币
 - 重点：目标在于硬币的数量，所以保存额度兑换最小数量硬币
 - 关键步骤：
    - 遍历每种硬币额度
        1. 剩余金额balance等于amount-硬币额度
        2. 当剩余金额>=0，说明该硬币组合可行，保存dp[当前金额]=dp[当前金额]与1+dp[剩余金额]的最小

### (三)完全背包的组合问题
#### 例题：q518
 - 与0-1背包的区别：商品数量是无限的
 - 唯一状态：背包容量、商品

#### DP题解：
 - 状态：背包的容量、可选择的物品
 - 选择：装进背包与否
 - 重点：目标在于达到金额的所有硬币组合数，所以外层循环为遍历商品(硬币)，而内层循环才是背包容量(金额)
 - 方案：
    1. 初始化dp[商品数+1][目标金额+1]
    2. 初始化dp设所有[商品][0]等于1
        - 当金额为0时默认存在一种组合所以等于1
    3. 外层循环枚举每个商品，内层循环递增背包容量
        1. 当背包放不下该商品时，当前商品组合数等于【上一商品】的组合数
        2. 当背包放得下该商品时，当前商品组合数等于【上一商品】商品组合数+【背包重量减去当前商品重量】的商品组合数
            - 因为是组合数，所以关注的是背包重量减去商品重量的重量，而不是商品的重量
    4. 返回[商品数][目标背包重量]

#### 状态压缩
- 目标：恰好达到目标金额的所有硬币组合数
 - 压缩前：dp[硬币种类][金额+1]
 - 压缩后：dp[金额+1]
    - 由于商品是无限，所以当尽可能保存所有的可能，所以金额枚举从0~目标金额