## 数组tag总结
### q303 设计
- 重点：要求一次实例化 多次调用
  - 即要求尽可能的节省运行时间
- 方案：实例化时就进行计算并存储结果

### q766 找规律
- 重点：每条对角线相等=>行或列均成相等规则
- 上下行比较

##### 如图，此类矩阵存在以下性质
![image](E0857B829B57418090547DFDC6DDDF36)

### q566 重塑矩阵
- 重点：将不同长宽的矩阵进行重新赋值
- 方案：判断长x宽是否相等
  - 第x个 / 新宽 ==>行坐标
  - 第x个 % 新宽 ==>纵坐标

### q283 双指针
- 重点：实际0元素可以不移动留到最后填充
- 方案：双指针。指针1为循环判断数组元素是否为0元素，指针2将非0元素向左覆盖，最后填充数组右边为0
- 移动≠“移动操作”

### q697 集合中元素出现次数
- 重点：容器复合使用
- 方案：
  1. 三个map，分别元素key及对应存储度、第一次出现位置、最后一次出现位置
  2. 一个map+数组，存储元素key，而数组前三位赋予度、第一次出现位置、最后一次出现位置的存储意义

### q485 "双指针"
- 重点：动态更新变量 临时最大值+计数器
- 方案：循环中，动态保存当前最大连续1的值+当前连续1的计数器

### q645 数组去重 标记法
- 重点：两个重复数但其索引下标不同
- 方案：
  - 额外数组
  1. 使用一个额外数组，以原数组元素作为索引判定是否为重复，查到重复的数
  2. 再循环额外数组，通过查0(形式)找到其索引值，索引即为丢失的值(因为元素为1~n且数组的长度为n)

### q287 数组去重 抽屉原理 二分查找
- 方案：
  - 同q645额外数组
    - 时O(n) 空O(n)
  - 二分查找+抽屉原理
  1. 二分查找，查找依据是左边小于mid的数量是否大于mid，则重复数在左边
  2. 反之则说明重复数在右边
  3. 最后返回left即为重复数
    - 时O(nlogn) 空O(1)

```
抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。
```

### q378 矩阵二分查找(位置)
- 重点：(1)有序矩阵可存在重复数(2)注意是位置值还是元素值
  - 注意是查第k位置的数字，而不是查数字k
- 方案：利用有序矩阵的性质：行列升序
  1. left为左上，right为右下，取mid
  2. 从左下到右上与中间数比较，调整横纵坐标，始终定位到mid位于列的位置，而该位置的上方则都是小mid数(累加数字作为确定k位置的依据)
  3. 累加数量小于k，说明在左上，反之在右下
  4. 最后left即为第k位置的数字

##### 如图，从左下到右上(行升序)，实际为查找mid位于列的位置(列升序)
![image](AC888FC0BB3340859EAB16C42FA1ECE4)

### q667 找规律 构建法
- 重点：数组相邻差值
- 方案：前面元素直接构建符合k个相邻不同差值的数，后面元素直接填充
  1. [|a1-a2|,|a2-a3|,...]，可发现1~n个数中，最多可得相邻不同差值数量为n-1个
  2. 填充规则为，由于为绝对值，k个值由大至小为**k~1**
    - [1,k,2,k-1,3,k-4,...,k/2,k/2-1]
    - 即k/2个升序放奇数位置 与 k/2个降序放偶数位
    - **注意数组下标从0开始**
  3. 填充第k+1位置往后所有数，值为k+1+1开始到n，PS：原先|1-(k+1)|才能到k的最大值

##### 规律如下
```
当n = 50， k = 20时：
[1,21,2,20,3,19,4,18,5,17,6,16,7,15,8,14,9,13,10,12,11,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
当n = 50，k = 17时：
[1,18,2,17,3,16,4,15,5,14,6,13,7,12,8,11,9,10,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
```

### q565 数组嵌套 标记法
- 重点：构成嵌套环的每个元素的路径是相同的，而最长路径也相同
- 方案：
  - 暴力法
    1. 循环每个元素，以每个元素为起点进行深入嵌套并计数
    2. 当循环到元素值等于起点元素则终止
    3. 保存计数最大的值
  - 标记法1：优化暴力法，**增加标记数组**
    - 在步骤2中增加visited数组，已访问的设为true
  - 标记法2：优化暴力法，**已访标记于原数组**
    - 在步骤2中设定已访问的元素位为一个标记值(Integer.MAX_VALUE)

### q769 找规律 数组分割
- 重点：第i个元素等于前i个元素最大值，则说明到此的元素可分割
  - 排序只能发生在切完的块内，同时块的位置无法改变
- 方案：
  1. 设定一个变量不断的保存到i为止的最大值
  2. 循环判断i是否等于该最大值，等于则说明到此为可分割，累计

### q240 升序矩阵 矩查查找(值) 减而治之
- 重点：升序矩阵
- 方案：
  - 暴力法：遍历矩阵
  - 二分法：每行或列都采用二分查找，或同时采用
  - 减而治之：
    1. 从左下或右上出发，逐渐查找目标值
      - 只能左下或右上，因为此角往反方向遍历时，行或列的递增或递减为相反，这样才可以减少遍历

- 比较：
  1. 区别于q378，q378的矩阵二分查找是通过 累计小于mid的数量与第k小及位置进行比较，从而得出第k小位于哪一边，最后的查找结果是该位置的值是多少
  2. 而q240，则是根据值来查找是否存在于矩阵
  