## 二分查找刷题总结 
### (一)基本二分查找
#### q69 基本二分查找
 - 重点：由于舍去小数，所以存在不相等的情况，则动态保存二分查中 左段的值 以获得最大可能值(如平方根为2.8，到2时保存2，尝试3失败，则值为2)
 - 方案:
    - 基本二分查找
    1. 边界优化，(x/2)+1的平方必定大于等于x，边界即(1,x/2+1)

#### q162 基本二分查找
 - 重点：nums[-1]=nums[n]=-∞，意味着一定存在峰值，即使到了数组区间的两端，此时判断nums[mid]比较左mid-1或右mid+1，谁大谁那边区间始终会存在个峰值(即使到数组的两端)
 - 方案：
    - 基本二分查找
    1. 边界为[0,length-1]，即元素的范围
    2. 判断mid>mid+1，则说明峰值在mid这边即左边，则right=mid
    3. 如mid<mid+1，则说明峰值在mid+1这边即右边，则left=mid+1

#### q74 基本二分查找
 - 重点：元素为升序且后一行大于前一行，可将矩阵看作升序的一维数组
 - 方案：
    - 基本二分查找
    - 1. 边界为[0,m*n],mid对应的元素值为matrix[mid/长,mid%长]


#### q287 抽屉原理 基本二分查找
- 重点：抽屉
- 方案：
    - 同q645额外数组
        - 时O(n) 空O(n)
    - 二分查找+抽屉原理
    1. 二分查找，查找依据是左边小于mid的数量是否大于mid，则重复数在左边
    2. 反之则说明重复数在右边
    3. 最后返回left即为重复数
        - 时O(nlogn) 空O(1)

```
抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。
```

#### q33 旋转数组 基本二分查找 两种边界(并行执行)
 - 重点：数组的第一位元素大于右边段的所有元素，可以nums[0]比较mid来判断mid位于左段还是有段位置
 - 方案：
    - 基本二分查找：
    1. 在收缩左右边界即left和right时，先判断mid位于哪一段(高或低)。再判断target是否位于哪一段内，从而收缩left和rights

##### 每轮循环mid只会存在以下两种状态，要么位于高段要么位于低段
![image](http://note.youdao.com/yws/res/31720/D36369A5D9BF43F9A16E04BFA64A6440)

#### q81 旋转数组 基本二分查找
 - 重点：当左半部分的第前N个元素与有半部分的后N个元素重复时，无法判断边界。采用直接去重的方式
 - 方案：
    - 基本二分查找：
    1. 在循环判断mid属于哪个区间前，先判断nums[left]==nums[mid]，相等则left++，达到去重的效果
    2. 边界的判断由0和length-1改为left和right

### (二)边界二分查找
#### q875 左侧边界二分查找
 - 重点：边界，要求越慢越好，所以为1~max_pile
 - 方案：
    - 暴力法[超时]：尝试1~maxK的速度
    - 左侧边界二分查找：
        1. 对1~maxK个速度进行左测二分查找
        2. 判定条件为能否在K速度下于H小时内吃完
        3. 力求最慢吃完，所以是左侧边界二分查找

#### q1011 左侧边界二分查找
 - 重点：边界，D最大为1，且船最低要载最大的货物，即边界max~total
 - 方案：
    - 左侧边界二分查找：
        1. 对船的最低到最高运载能力进行二分查找
        2. 判定条件为在D日内以某承载量将所有货物运载完成
        3. 力求最低运载能力，所以是左侧边界二分查找

#### q34 左/右侧边界二分查找 (前后执行)
 - 重点：是否存在target，才进行第二次二分查找
 - 方案：
    - 左/右侧边界二分查找:
    1. 左侧边界二分查找到最左边重复值索引 边界[0,length]
    2. 判断left==length或num[left]!=target，说明没有查到target,则直接return [-1,-1]
    3. 右侧边界二分查找到最右边重复值索引 边界[最左侧重复值索引,length]

#### q153 旋转数组 左侧边界二分查找 两种边界(并行执行)
 - 重点：
    1. 数组的第一位元素大于右边段的所有元素，位于左边段的元素可直接跳过，因为肯定不是min值
    2. 要查找的min值即处在旋转数组的中心点上，可在右段中判断mid是否小于mid-1，是则mid为最小值，而mid-1为最大值
 - 方案：
    - 左侧边界二分查找 两种边界：
    1. 判断mid值是否小于第一个元素。
    2. 是则mid在右侧，判断mid是否小于mid-1，是则说明为旋转数组中心点，否则压缩右侧边界。
    2. 否则直接压缩左侧边界，即left=mid+1，因为是要找最小值

#### q154 旋转数组 左侧边界二分查找
 - q153的延续，允许重复元素，影响：
    1. 第一个元素由**大于变成大于等于**右边段所有元素
    2. 旋转数组的中心点的性质，由mid**小于变成小于等于**mid-1则mid为最小值
 - 重点：以nums[right]为基准，逐渐向旋转数组中心靠拢
 - 方案：
    - 左侧边界二分查找：
    1. 以nums[right]元素为基准，大于该元素说明为左段直接左侧边界，小于则压缩右侧边界进行调整，等于则向左一个个调整



#### q378 矩阵左侧边界二分查找
 - 重点：(1)有序矩阵可存在重复数(2)注意是位置值还是元素值
    - 注意是查第k位置的数字，而不是查数字k
 - 方案：利用有序矩阵的性质：行列升序
    1. left为左上，right为右下，取mid
    2. 从左下到右上与中间数比较，调整横纵坐标，始终定位到mid位于列的位置，而该位置的上方则都是小mid数(累加数字作为确定k位置的依据)
    3. 累加数量小于k，说明在左上，反之在右下
    4. 最后left即为第k位置的数字

##### 如图，从左下到右上(行升序)，实际为查找mid位于列的位置(列升序)
![image](https://note.youdao.com/yws/res/30761/AC888FC0BB3340859EAB16C42FA1ECE4)

#### 剑53 左侧边界二分查找
 - 方案
    1. 先使用左侧二分找到等于target的最左侧值下标
    2. 再从该下标向右遍历等于target的值，res++，直到不相等直接break

#### 剑53.2 二分查找
 - 方案：
    1. nums[mid]==mid则表示不存在数在右边，left=mid+1
    2. 反之则right=mid-1;

