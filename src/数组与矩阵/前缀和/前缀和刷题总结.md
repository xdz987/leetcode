## 前缀和刷题总结
#### q1 前缀和
 - 重点：空间换时间，保存查询过的值，判断需要的值是否再保存中
 - 方案：
    - 前缀和:
    1. 初始化容器Map保存已经查询过的值
    2. 查询target-num[i]是否存在于保存的值中
        - 存在，返回[map.get(target-num[i])，i]
    3. 将num[i]保存至map

#### q560 前缀和
 - 变数：
    1. 额外字典sum，sum.put(0,1)
    2. res，保存结果
 - 执行：
    - 将计算前缀和的过程结合进题目要求
    - 原为sum[i]-sum[j]=移项为sum[j]=sum[i]-k
        1. 设i>j的
        2. 例5-2=3，即sum[i]-k=sum[j]，sum[j]的值一定比sum[i的值小]，即sum[j]已经跃过了(不一定存在此前缀和)
    1. 循环原数组
    2. sumi+=num[i]，即前缀和
    3. sumj=sumi-k，sumj为符合条件的前缀和
        - 满足条件需要两个前缀和的值，sumi是一定存在的，则只需要判断sumj是否存在
    4. 判断sumj是否存在于字典sum，存在则res+=字典value
    5. 将sumi保存进前缀和
    6. 返回结果

#### q1248 可变窗口 数学 前缀和
 - 重点：优美子数组左右偶数数量影响组合次数
 - 方案：
    - 滑动窗口：
    1. 初始化窗口边界、窗口状态计数器valid、结果res
    2. 滑动窗口
    3. 直到valid奇数的数量等于k，则累加计算包含k个奇数与左右偶数的优美子数组(左边偶数作为起点，右边偶数作为终点)：
        1. 左边起点，则是从窗口的第一个奇数到窗口外前一个奇数的之间偶数数量+1(可一个偶数不取所以+1)
        2. 右边终点，则是从窗口的最后一个奇数到窗口外后一个奇数之间偶数数量+1(可以一个偶数不取所有+1)
    4. res+=(左边起点)*(右边偶数)
        - 因为一个起点对应N个终点，所以是起点*终点
    5. 缩小窗口left++，valid--(因为3.1后left指针已指向窗口的第一个奇数)
        - 3.2后right指向窗口外右边的第一个奇数或者结尾元素
    6. 返回res
    - 前缀和：
    1. 初始化前缀和容器数组preSum、结果res、奇数总数sum
    2. preSum[0]=1，第一个优美子数组+1
    3. 循环每个原数组元素
        - 当元素为奇数，则sum++
        - 记录每个奇数的前缀和，即preSum[sum]++
        - 当sum>=k，即满足条件，则res+=preSum[sum-k]
            - 即res加优美子数组的每个起点总数*1(终点)

