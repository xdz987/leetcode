## 双指针刷题总结
### (一)快慢指针
#### q283 双指针
 - 重点：实际0元素可以不移动留到最后填充
 - 方案：双指针。指针1为循环判断数组元素是否为0元素，指针2将非0元素向左覆盖，最后填充数组右边为0
 - 移动≠“移动操作”

#### q141 快慢指针 链表
 - 重点：设定fast的速度是slow的两倍，那么如果存在环时fast和slow始终会相遇
 - 方案：
    - 快慢指针
    1. 设定fast=slow=head
    2. fast=fast.next.next，而slow=slow.next即速度为slow两倍
    3. 当fast==slow即存在环

#### q142 快慢指针 链表
 - 提示：是q141的延伸
 - 重点：当fast和slow相遇时，head->起点->相遇点的距离 = 起点->相遇点->起点的距离
 - 方案：
    - 快慢指针：
    1. 找到环后fast=slow
    2. 设slow=head，然后slow和fast同时向前走
    3. 当fast=slow时，则说明为环的起点

#### q19 快慢指针 链表
 - 重点：fast先走n步，再fast和slow同时走，到链表终点时slow即为倒数第n结点
 - 方案
    - 快慢指针：
    1. fast指针先走n步
    2. 如果fast为null，则说明到了head，直接返回head.next，即删除了head结点
    3. 再fast和slow同时走到终点，删除slow=slow.next即删除slow结点

### (二)左右指针
#### q344 左右指针
 - 重点：左右指针元素交换，向中靠拢
 - 方案：
    - 左右指针：
    1. 边界为[0,length-1],交换left和right元素
    2. left++,right--

#### q645 左右指针
 - 提示：q344的基础增加个元音字母判断
 - 重点：增加判断元素是否为元音字母a,e,i,o,u及大写
 - 方案：
    - 左右指针：
    1. 边界为left,right为[0,length-1]
    2. 当left为元音字母时，再判断right是否为元音字母，只有都为元音字母才进行交换
    3. 否则left不是则left++，right不是则right--

#### q167 左右指针
 - 重点：左右指针对应的值相加比较target以调整left和right
 - 方案：
    - 左右指针：
    1. 设边界为left,right[0,length-1]
    2. sum等于left和right的值
    3. 比较sum与target的大小，sum大则right--，小则left--，最后找到匹配target的下标

#### q680 左右指针
 - 重点：双重左右指针，第一层判断left,right是否相等，第二层判断是否为回文字符串
 - 方案：
    - 左右指针：
    1. 边界为left,right[0,length-1]，判定left值是否等于right值
    2. 不等则去除左边或去除右边字符，判断是否为回文字符串
    3. 辅助函数判断是否为回文字符串则是，左右指针left==right与否，相等则left++right--，否则不是回文字符串

#### q633 左右指针
 - 重点：可将b的范围缩小到√c内，否则可能存在越界问题，即b*b可能超过int的范围
 - 方案：
    - 左右指针
    1. 设边界为[0,√c]
    2. 变量sum=a方+b方，当sum<c时，a++;当sum>c时b--;
