## 双指针刷题总结
### (一)快慢指针
#### q141 快慢指针 链表
 - 重点：设定fast的速度是slow的两倍，那么如果存在环时fast和slow始终会相遇
 - 方案：
    - 快慢指针
    1. 设定fast=slow=head
    2. fast=fast.next.next，而slow=slow.next即速度为slow两倍
    3. 当fast==slow即存在环

#### q142 快慢指针 链表
 - 提示：是q141的延伸
 - 重点：当fast和slow相遇时，head->起点->相遇点的距离 = 起点->相遇点->起点的距离
 - 方案：
    - 快慢指针：
    1. 找到环后fast=slow
    2. 设slow=head，然后slow和fast同时向前走
    3. 当fast=slow时，则说明为环的起点

#### q19 快慢指针 链表
 - 重点：fast先走n步，再fast和slow同时走，到链表终点时slow即为倒数第n结点
 - 方案
    - 快慢指针：
    1. fast指针先走n步
    2. 如果fast为null，则说明到了head，直接返回head.next，即删除了head结点
    3. 再fast和slow同时走到终点，删除slow=slow.next即删除slow结点

### (二)左右指针
#### q344 左右指针
 - 重点：左右指针元素交换，向中靠拢
 - 方案：
    - 左右指针：
    1. 边界为[0,length-1],交换left和right元素
    2. left++,right--

#### q645 左右指针
 - 提示：q344的基础增加个元音字母判断
 - 重点：增加判断元素是否为元音字母a,e,i,o,u及大写
 - 方案：
    - 左右指针：
    1. 边界为left,right为[0,length-1]
    2. 当left为元音字母时，再判断right是否为元音字母，只有都为元音字母才进行交换
    3. 否则left不是则left++，right不是则right--

#### q167 左右指针
 - 重点：左右指针对应的值相加比较target以调整left和right
 - 方案：
    - 左右指针：
    1. 设边界为left,right[0,length-1]
    2. sum等于left和right的值
    3. 比较sum与target的大小，sum大则right--，小则left--，最后找到匹配target的下标

#### q680 左右指针
 - 重点：双重左右指针，第一层判断left,right是否相等，第二层判断是否为回文字符串
 - 方案：
    - 左右指针：
    1. 边界为left,right[0,length-1]，判定left值是否等于right值
    2. 不等则去除左边或去除右边字符，判断是否为回文字符串
    3. 辅助函数判断是否为回文字符串则是，左右指针left==right与否，相等则left++right--，否则不是回文字符串

#### q633 左右指针
 - 重点：可将b的范围缩小到√c内，否则可能存在越界问题，即b*b可能超过int的范围
 - 方案：
    - 左右指针
    1. 设边界为[0,√c]
    2. 变量sum=a方+b方，当sum<c时，a++;当sum>c时b--;

#### q11 左右指针
 - 重点：左右谁先移动指针的条件谁的值小则移动
 - 方案：
    - 暴力法(超时)
        - 略
    - 左右指针：
    1. 边界left,right为[0,length-1]
    2. area=(right-left)*Math.min(height[left],height[right])
    3. 比较height[left]<height[right]
        - true，left++
        - false，right--

### (三)同向条件双指针
 - 指针根据一定条件才可行走

#### q283 同向条件双指针
 - 重点：实际0元素可以不移动留到最后填充
 - 方案：双指针。指针1为循环判断数组元素是否为0元素，指针2将非0元素向左覆盖，最后填充数组右边为0
 - 移动≠“移动操作”

#### q88 同向条件双指针
 - 重点：m,n为非0元素数量，从后往前判断nums1与nums2最大值得比较，并填充至nums1的最右侧
 - 方案：
    - 同向条件双指针
    1. p1指向m-1,p2指向n-1,p3指向n+m-1
    2. 从n+m-1即最后一个位置进行填充
    3. 循环比较，比较nums1[p1]与nums2[p2]的大小，大的填充进入nums1[p3]，当p1或p2小于0也退出循环
    4. 补充填充p1或p2中较小元素(无需比较)

#### q392 同向条件双指针 贪心匹配
 - 重点：贪心匹配 子序列
 - 方案：
    - 同向条件双指针
    1. 双指针的边界为[0,s.length]和[0,t.length]
    2. 遍历t的字符，同时设立指针sp指向s的起始字符，当s的字符相等则指向下一位字符
    3. 最后sp=s.length则匹配所有字符，s即为子序列

#### q524 同向条件双指针 贪心匹配
 - 提示：q392的延续
     1. 题目描述稍有问题，是从字典中找到字符串s的子序列，且为所有元素中最长的&字典顺序最小
     2. 即对子序列，并判断字符串是否最长，如同为最长再判断谁的字典顺序最小
 - 重点：贪心匹配 子序列
 - 方案：
    -同向条件双指针
    1. 判断元素是否为子序列，保存result
    2. 判断当前子序列长度是否大于result或者相等时字典顺序是否小于result，满足则保存result

