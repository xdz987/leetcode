### 一、链表节点批量操作
#### 单链表反转 q206 剑24
#### 方式一：递归——后序
- ==递归思想：每一层递归的函数都有各自的变量，传进的head.next作为每一层递归函数的参数，对应head地址即对应链表的每个节点。==
- ==基于递归思想：对每一层递归的节点，都将其next指针【以成对的方式进行反转】==
- ==递归函数的变量传递：每层递归返回当前节点的地址做保存于last变量，后一层递归的变量将前一层递归的变量进行了覆盖。==
    1. 返回当前地址做保存于last变量，又每层都有个last
    2. 根据变量的赋值传递，第一层递归对应最左边的last，最底层递归对应最右边的last，最右边的last值是最后一个节点的地址
    3. 最后递归返回时，使得每层递归函数的last变量都等于最后一层递归函数last的值即最后一个节点的地址
    - 即last(1)=last(2)=last(3)...=last(N)=ListNode(tail)
- ==题解：深入递归到达最后一对节点/两个节点，然后不断返回，执行反转操作。==
    - ==因为反转是成对的操作，所以head.nexst不能=null，否则返回==
    1. 当head||head.next为null返回head
    2. 反转【每对】节点
        - 后一节点指向当前节点
        - 当前节点指向null
    3. 递归返回值last指向最后一个节点
    4. 反转【每对节点】
        - 后一节点指向当前节点
            - 在上一层递归中后一节点是指向null的，在这一层递归指针又指向了前一个节点
        - 当前节点指向null
    4. 底层递归不断返回last【覆盖】上一层的值，最后第一层递归的last即为最底层递归的last。即反转链表后的头节点

#### 方式二：迭代实现
- 同【递归-前序】方式
- ==题解：通过记录pre节点地址，使得每个cur节点都可将next指向pre==
    1. 遍历链表
    2. 记录pre节点，将当前节点指向pre节点，动态更新pre节点。
    3. 最后head指向null结束循环，此时pre指向最后一个节点，即返回pre

#### 链表反转前N个 自定义题
#### 方式一：迭代实现
- 重点：
    1. 备份head为saveHead
    2. ==【同单链表反转】前n个节点进行单链表反转==
        - 此时pre即为新head
        - ==saveHead反转的截断点，head即为不反转的截断点，将saveHead联通head即可==
    2. 返回pre

#### 方式二：递归——后序
- 题解：
    - ==同【同单链表反转】，只是当n递减到1时递归叶结束==
    - ==将head.next原先指向为空，改为指向不反转链表的头节点。即前序时head.next。动态保存后继节点successor=head.next==
- 方案：
    1. 以节点长度n=1作为base case，并以全局的方式保存该节点的后继节点，返回该节点
    2. 从n递归到1，再1-n的每个结点指向前一节点，前一节点指向后继几点(保存好的)

#### 单链表范围反转 q92
- 效率：递归>定位截断反转法>定位头插法

#### 方式一：递归_定位截断反转法
- ==题解：定位到截断位置，执行进行前N个节点反转函数，并将反转后的头结点接到截断位置。==
    1. ==后序递归，定位到截断位置，即left=1==
        - 反转的总节点数不变，所以right与left同步-1
    2. ==将截短的节点作为反转头节点参数==
    3. ==将反转后头节点续接到原截断节点的next==
- 方案：
    1. 当m=1时，即反转前N个节点
    2. 当m>1时，则head.next快进到base case。如m=2，n=4。那么head.next即为m=2-1，而n即数量则减1，相对上来看等同于反转前N个节点

#### 方式二：迭代_定位截断反转法
- ==题解：同方式一==
- 方案：
    1. 定位到m的前倾与n的位置
    2. 将0~m，和n~length进行分段拆分，对m~n的节点进行单链表反转
    3. 反转完成再链接到原来链表中

![image](http://note.youdao.com/yws/res/33691/661A1A5A02B348CEBFCDB0DFD16BCDA7)

#### 方式三：迭代_定位头插法 O(n)
- 方案：
    1. 定位到需要反转的最左节点的前倾
    2. 将m~n的节点进行反转，反转的方法类似队列
        - 从左到右重新将节点从左边放入队列，一轮循环后即反转

#### q21 归并两个有序链表
#### 方式一：递归
- ==思想：将递归赋值给最一层的变量，最后return时返回到第一层变量==
- ==题解：==
    - ==注意：不需要创建头节点来存储归并结果，通过比较返回l1和l2中头结点.val小的即为【结果头节点】==
    - 步骤
        1. ==当l1为null返回l2==
        2. ==当l2为null返回l1==
        3. ==当l1.val>l2.val，设当前节点为l2，递归(l1,l2.next)==
        4. ==当l1.val<l2.val，设当前节点为l1，递归(l1.next,l2)==

#### 方式二：迭代
- ==题解：==
    1. ==创建虚拟头节点保存归并head的地址，设立归并head保存归并结果==
    2. 当l1&&l2都不为null，不断保存小值至head
    3. 返回虚拟头结点.next

#### 两两交换链表中的节点 q24
#### 方式一：递归
- ==题解：==
    1. ==当head或head.next为null直接返回head==
        - ==单个节点不需要交换==
    2. ==设后一个节点为新头节点，交换当前与后一节点。==
    3. ==将完成交换后的后一节点.next指向递归，传递值为原先的后后节==点

#### 方式二：迭代
- ==题解：==
    1. ==设立newHead，设立虚拟头节点dummy保存newHead地址==
    2. 由于两两交换，循环head和head.next如不为null
    3. ==将newHead.next指向第二个元素，交换第一个第二个元素。head与newHead指向第三个元素，准备下轮循环==
    4. 返回dummy.next

#### 链表求和 q445
#### 方法一：迭代-栈+链表
- ==即模拟两数相加==
- ==题解：使用栈存储l1和l2，使得顺序变成最小位先出栈==
    1. ==遍历，两栈或不为null或carry!=0==
    2. ==sum=n1+n2+carry，carry=sum/10，当前位值为sum%10==
    3. ==设立虚拟头结点，头插法==
- 栈结构性能：LinkedList>Stack

#### 方法二：反转链表+头插法
- 重点：
    1. 对l1和L2进行反转
    2. 模拟十进制相加：L1不为空或l2不为空或carry!=0

#### 链表求和 q2
- ==【同q445】==
    - ==栈换成链表==
    - ==直接前面即为低位，所以不需要头插法==

#### 回文链表 q234
- 快慢指针 反转链表
- ==题解：==
    1. ==快慢指针找打链表相对中点。同时将相对中点的往前一节点的所有链表反转==
    2. ==当fast为null，说明链表节点数量为奇数为。调整slow=slow.next使得比较的链表节点数相同==
    3. ==比较反转的链表与slow是否所有节点值相等==
        1. ==全部相等返回true==
        2. ==否则返回flase==

#### 分割链表 q725
- ==题解：边界处理==
    1. 遍历链表计算节点总数
    2. 计算每段链表节点数
        - sum/k
        - sum%k
    3. ==将每段链表头节点放入数组，到达边界后将边界设为null==

#### 奇偶链表 q328
- ==题解：==
    1. ==设odd=head,even=head.next，保存even头部==
    2. ==odd和even同时间隔着向后连接==
        - odd.next = odd.next.next
        - even.next = even.next.next
    3. ==odd.next拼接even头部==
    4. ==返回head即可==
- 方案：
    1. 先使得odd与head节点地址等于同一地址(第一个节点，奇数开头)。even与evenHead节点地址等于同一地址(第二个节点，偶数开头)
    2. 2. 遍历使得odd和head的next变量都指向第三个节点地址，之后使得odd.next指向第五...九、十一节点地址，而head节点地址不变。最后head为奇数第一节点，odd为奇数最后节点
    3. 3. 遍历使得even和evenHead的next变量都指向第四节点地址，之后even.next指向第六...十、十二节点地址，而evenHead节点地址不变。最后evenHead为偶数第一节点(2)，even为最后节点或null
    4. 4. 拼接奇偶链表，将odd的尾结点指向even的头节点，之后返回odd的头结点，即奇偶链表

#### 从尾到头打印节点 剑06
- ==重点：先算节点数，再初始化数组，倒着放进数组即可==

#### 删除链表节点 剑18
- ==题解：==
    1. ==设置虚拟头节点保存head地址，同时设其为pre节点==
    2. ==遍历链表，相等则使得pre跳过下一个节点==
    3. ==通过虚拟头节点返回真实头节点地址==

#### 含random链表的深拷贝 剑35
#### 方法一：拼接与拆分
- ==题解：通过将新链表所有节点统一放置到旧链表的右边。此时可以通过random.next查找到新链表对应旧链表的random==
    1. ==遍历链表，在每个节点右边创建新节点，赋值val属性==
    2. ==遍历链表，为新链表节点赋值random属性，通过random.next获取==
    3. ==创建虚拟头结点，遍历链表。将旧链表剥离，返回新链表头节点==
- 方案：
    1. 在原链表的每个节点后新增一个相同val的节点
    2. 再讲新节点的random=原节点random.next
    3. 将新旧链表分离

#### 方法二：哈希表
- ==题解：通过哈希映射(旧节点地址，新节点地址)，实现记录旧节点于链表的相对位置==
    1. ==遍历链表，将旧节点映射新节点，保存val，但空置next和random属性==
        - 建立旧节点与新节点的对称位置
    2. 遍历链表
        - ==get(node).next通过get(node.next)取得对称的新节点位置==
        - random同上
- 方案：
    1. 使用哈希表复制新节点[node.val,新节点]
    2. 再遍历Head，哈希表的新节点则根据node.val(与原Head对应)赋值random
    3. 返回哈希表头节点

#### 移除链表元素 q203
#### 方式一：迭代
- ==题解：设立虚拟头节点，记录节点前驱pre==
    1. 当当前节点值等于val时，使得pre跳过当前节点
    2. 最后返回虚拟头结点.next
- 方案：设立pre指针并备份，遍历原链表相等则跳过

#### 方式二：递归
- ==题解：后序遍历==
    1. ==当前递归层的节点即head.next等于递归的结果==
    2. ==递归结果返回值：==
        1. ==当当前层节点即head.val等于val时跳过该层节点，即返回head.next==
        2. ==不相等返回head==

#### 旋转链表 q61
- ==题解：==
    - ==截断的位置：第n-(k%n)的下个节点==
        - 从序数从1开始计算
    1. ==备份头节点地址==
    2. ==计算节点数量==
    3. ==将链表设为环==
    4. ==计算截断位置为第n-(k%n)节点==
    5. ==以第n-(k%n)节点的下个节点为头节点，第n-(k%n)节点为尾节点指向null==

#### 分隔链表 q86
- ==题解：==
    1. ==设立small和big虚拟头节点==
    2. ==遍历head链表，小于x放入small，否则放入big==
    3. ==最后big.next指向null，small指向bigHead==
    4. ==返回smallHead==
- 方案：
    - 拆分合并：
    1. 将链表中小于x的节点连接成新链表，并将原链表中小于x的节点删除
    2. 两链表合并

#### 合并k个有序链表 q23
- ==题解：不断地合并两个链表，直到链表数量等于一个==
    - ==如何合并？==
        - ==采用归并思想，避免“头重脚轻”现象==
            - 如[1,2,3,4]
            - 线性思想12,3,4->123,4->1234
            - 归并思想12,34->1234
    - ==合并的动作？==
        - ==即建立虚拟头节点，按照升序规则，将两链表依次插入==
    - 题解：
        1. 递归“分”链表，第一层为[0,n-1]，按照mid“分”，直到最底一层为单个链表即left=right。
        2. 到达最低一层后开始merge链表并向上返回。即设立虚拟头节点，将两链表元素按照升序插入
        3. 返回值有最底层的链表合并结果，不断合并到第一层即为所有链表合并结果

#### k个一组翻转链表 q25
#### 方式一：X次反转前K个节点
- ==题解：==
    1. ==设立虚拟头节点不断连接反转后的链表。==
    2. ==不断的反转前K个节点，反转完成后返回{反转后的头节点，反转后的尾结点}==
    3. ==虚拟头结点链接【反转后的头结点】，下一次反转前K个节点的起点即为上一次反转返回的【反转后的尾节点】==
    4. ==当尾结点为或者尾结点.next为空，停止反转，返回虚拟头节点.next==
    - ==当最后一次反转时，节点数count<K时，递归反转回来参数以count作k==

#### 方式二：X次截断-反转-链接
- 遇到问题：
    1. 循环的节点变量与翻转的逻辑分离，但翻转的逻辑中却使用到了循环的节点变量，导致以下问题：
        1. 翻转发生变化，循环的节点也发生变化。(浅拷贝问题)。同时影响了翻转的逻辑与循环的执行
- 重点：反转截断处的四个切面
- 方案：
    - 截断-翻转-链接
    1. 初始化虚拟头结点、需翻转节点段的前一节点pre、需翻转的最后一个节点end
    2. 将end作为while循环的变量
    3. 如达到k个一组则进行翻转，否则break
    4. 翻转
        1. 断开-翻转-链接
        2. 初始化下次翻转的变量

### (二)：单节点查找/操作：快慢指针
- 主要解决链表中的问题，比如典型的判定链表中是否包含环。

#### 环形链表 q141
- ==题解：设立快慢指针==
    - ==当fast=null或fast.next为null说明到达终点，不存在环==
    - ==当在循环中发现fast=slow，说明为环，直接返回true==
- 方案：
    1. fast=slow=head
    2. fast指针的速度是slow指针的两倍，即slow=slow.next，fast=fast.next.next
    3. 当不存在环时，指针会到达终点即null，即判断fast.next&&fast.next.next是否为null
    4. 当存在环时，则fast=slow，因为fast超过了slow整数圈后相遇

#### 环形链表2 q142
- ==题意：已知链表含有环，返回环的起点==
- ==题解：head到环起点=相遇点到环起点为相等==
    1. 快慢指针找到环
    2. head与相遇点指针同时走，当head等于像雨点指针时，即为环的起点

![image](http://note.youdao.com/yws/res/32042/2C8321228AEC47BC85A96C31C34B1663)
![image](http://note.youdao.com/yws/res/32040/6AF6D51324FB4BF4B6E9148BF1482B18)

#### 删除链表的倒数第n个节点 q19
- ==题解：==
    1. ==先让fast指针走n步(如走完n步到达终点null，则说明倒数n个节点为第一个节点)==
        - ==走n步到达的是第n+1个节点，因为n是步数不是第x个节点==
    2. ==再fast和slow指针同时出发，到达终点时slow指针即为倒数第n-1个节点==
    3. ==删除第n个节点，即slow.next=slow.next.next==
    4. ==返回head==

#### 找到两链表的交点 q160
- ==题解：==
    - ==a与b拥有部分共同的链表c，而由a+b=b+a路程是相同的==
    - ==换算为(a1+c1)+(b1+c)=(b1+c)+(a1+c)==
    - ==即a1+c+b1+c=b1+c+a1+c，可看出两个链表同时执行到达第二个c时为同一起点==
        - ==第一个c时，因为a1≠b1所以不能确定是否为交点。但a1+c+b1=b1+c+a1所以第二个c必定为交点==
    - ==题解：==
        1. ==初始化l1,l2为headA和headB==
        2. ==当l2执行完后连接headB继续执行，l2执行完连接headA继续执行。==
        3. ==当l1=l2时即为交点==
- 重点：
    1. 当两链表长度相同时，双指针同时走会直接再c1相遇
    2. 当两链表长度不等时，双指针会在走过自己的一轮，而走对方的路线(a再走b，b再走a)是在c点相遇
        - 因为a+b+c=b+a+c，两指针都走完ab，会同时走c

![image](http://note.youdao.com/yws/res/33758/11AA688AC3964D5082372B12EDCE2202)

#### 删除有序链表重复元素 q83
- ==题解：当前节点值等于下一个节点值时，跳过下一个节点，节点不变。否则指针前行==