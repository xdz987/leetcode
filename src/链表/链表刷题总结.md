- 节点赋值与比较的含义

```
(浅拷贝)地址赋值：A=B(令A.val=1，此时B.val=1)
(深拷贝)内容赋值：A.val=B.val,A.next=B.next
修改A节点的指向：A.next = B(A.next存放B的地址)
AB指向同一节点,A或B经过N轮后,为链表终点，另一则为链表起点，即：
    1). A=B
    2). A=C，A=A.next.next...
    3). B.next.next...最终等于A节点

删除下一节点：A.next = A.next.next
截断：A.next = null

判断节点是否同一节点：A == B
判断节点指向是否相同：A.next == B.next
判断B节点是否为A节点的后继：A.next == B
```

- 节点交换/反转要素
    - 浅拷贝问题
1. 需要两个额外变量
    1. 一个用于记录前一节点即pre
    2. 一个用于用于操作当前节点(避免浅拷贝问题)

```
pre=null;

//当前节点需要转向
current = cur;

//游标指向下一个
cur = cur.next;

//当前节点转向
current.next = pre;
//临时变量pre向前
pre = current;
```

### (一)链表节点批量操作
#### 反转链表
##### 1. 单链表反转
- 重点：反转指针的指向
1. 递归实现
    1. base case是指向链表的最后一个结点
    2. 从head到最后一个节点不断递归，最后再往回传递，使得后一个指向前一个，最后最前一个指向null完成反转
```
ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}
```
2. 迭代实现
    1. 注意点将next变量与结点的next意义分离
        - 前者的next变量用于交换指针，是动态变化的
    2. 完成反转的while结束条件是cur=null，即已经没有下一个元素可以进行反转

```
public ListNode reverseList(ListNode head) {
    ListNode pre = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        //---上面完成初始化：前中后---
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```
##### 2. 单链表反转前N个
1. 递归实现
    1. 以节点长度n=1作为base case，并以全局的方式保存该节点的后继节点，返回该节点
    2. 从n递归到1，再1-n的每个结点指向前一节点，前一节点指向后继几点(保存好的)
```
递归实现
ListNode successor = null; //后继节点
public ListNode reverseN(ListNode head, int n) {
    if (n == 1) {
        //记录第n+1节点
        successor = head.next;
        return head;
    }
    // 以head.next为起点，需要反转前n-1个节点
    ListNode last = reverseN(head.next, n - 1);

    // 后一节点指向前一节点
    head.next.next = head;
    // 前一节点指向后继节点
    head.next = successor;

    // 返回新的head
    return last;
}
```

2. 迭代实现
    1. 前n个节点进行单链表反转，记录位置
    2. 最后将反转完成的头节点链接到第n+1个节点

```
//迭代实现
public ListNode reverseN(ListNode head, int n) {
    //(1)初始化前pre 中cur 后next指针。pre和cur进行节点交换，next作记录作用记录下一个节点
    ListNode pre = null;
    ListNode cur = head;
    int i = 1;

    //(2)循环交换指针 前与中交换
    while (i <= n) {
        //记录下一个指针
        ListNode next = cur.next;

        //交换指针
        cur.next = pre;
        pre = cur;
        cur = next;
        i++;
    }
    //(3)交换完成后，head则作为前n个节点的最后一个节点，连接n+1节点，完成反转
    head.next = cur;
    return pre;
}
```
##### 3. 单链表范围反转
- 效率：递归>定位截断反转法>定位头插法
1. 递归实现
    1. 当m=1时，即反转前N个节点
    2. 当m>1时，则head.next快进到base case。如m=2，n=4。那么head.next即为m=2-1，而n即数量则减1，相对上来看等同于反转前N个节点
```
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (left == 1) {
        return reverseN(head, right);
    }

    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, left - 1, right - 1);
    return head;
}
```

2. 迭代实现-定位截断反转法 O(2n)
    1. 定位到m的前倾与n的位置
    2. 将0~m，和n~length进行分段拆分，对m~n的节点进行单链表反转
    3. 反转完成再链接到原来链表中

![image](http://note.youdao.com/yws/res/33691/661A1A5A02B348CEBFCDB0DFD16BCDA7)
3. 迭代实现-定位头插法 O(n)
    1. 定位到需要反转的最左节点的前倾
    2. 将m~n的节点进行反转，反转的方法类似队列
        - 从左到右重新将节点从左边放入队列，一轮循环后即反转

```
//迭代实现2 定位头插法
public ListNode reverseBetween(ListNode head, int left, int right) {
    // 增加一个虚拟头节点，使得当left=1时即第一个节点也有前倾，从而不需要增加额外的逻辑判断
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;

    //(1)定位到需要反转的最左节点的前倾
    ListNode pre = dummyNode;
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    ListNode cur = pre.next;
    //(2)开始反转。把需要反转的节点当做一个队列，从左到右重新将节点从左边放入队列，一轮循环后即反转
    for (int i = left + 1; i <= right; i++) {
        ListNode next = cur.next;

        //重新链接
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }

    return dummyNode.next;
}
```

#### q21 归并两个有序链表
#### 方式一：递归
- ==思想：将递归赋值给最一层的变量，最后return时返回到第一层变量==
- ==题解：==
    - ==注意：不需要创建头节点来存储归并结果，通过比较返回l1和l2中头结点.val小的即为【结果头节点】==
    - 步骤
        1. ==当l1为null返回l2==
        2. ==当l2为null返回l1==
        3. ==当l1.val>l2.val，设当前节点为l2，递归(l1,l2.next)==
        4. ==当l1.val<l2.val，设当前节点为l1，递归(l1.next,l2)==

#### 方式二：迭代
- 题解：
    1. ==创建虚拟头节点保存归并head的地址，设立归并head保存归并结果==
    2. 当l1&&l2都不为null，不断保存小值至head
    3. 返回虚拟头结点.next

#### q24 两两交换链表中的节点
#### 方式一：递归
- ==题解：==
    1. ==当head或head.next为null直接返回head==
        - ==单个节点不需要交换==
    2. ==设后一个节点为新头节点，交换当前与后一节点。==
    3. ==将完成交换后的后一节点.next指向递归，传递值为原先的后后节==点

#### 方式二：迭代
- 题解：
    1. ==设立newHead，设立虚拟头节点dummy保存newHead地址==
    2. 由于两两交换，循环head和head.next如不为null
    3. ==将newHead.next指向第二个元素，交换第一个第二个元素。head与newHead指向第三个元素，准备下轮循环==
    4. 返回dummy.next

#### q445 链表求和
#### 方法一：迭代-栈+链表
- ==即模拟两数相加==
- ==题解：使用栈存储l1和l2，使得顺序变成最小位先出栈==
    1. ==遍历，两栈或不为null或carry!=0==
    2. ==sum=n1+n2+carry，carry=sum/10，当前位值为sum%10==
    3. ==设立虚拟头结点，头插法==
- 栈结构性能：LinkedList>Stack

#### 链表求和 q2
- ==【同q445】==
    - 栈换成链表
    - 直接前面即为低位，所以不需要头插法

#### q234 回文链表 快慢指针 反转链表
- 题解：
    1. ==快慢指针找打链表相对中点。同时将相对中点的往前一节点的所有链表反转==
    2. ==当fast为null，说明链表节点数量为奇数为。调整slow=slow.next使得比较的链表节点数相同==
    3. ==比较反转的链表与slow是否所有节点值相等==
        1. ==全部相等返回true==
        2. ==否则返回flase==

#### q725 分割链表
- ==题解：边界处理==
    1. 遍历链表计算节点总数
    2. 计算每段链表节点数
        - sum/k
        - sum%k
    3. ==将每段链表头节点放入数组，到达边界后将边界设为null==

#### q328 奇偶链表
- ==题解：==
    1. ==设odd=head,even=head.next，保存even头部==
    2. ==odd和even同时间隔着向后连接==
        - odd.next = odd.next.next
        - even.next = even.next.next
    3. ==odd.next拼接even头部==
    4. ==返回head即可==
- 方案：
    1. 先使得odd与head节点地址等于同一地址(第一个节点，奇数开头)。even与evenHead节点地址等于同一地址(第二个节点，偶数开头)
    2. 2. 遍历使得odd和head的next变量都指向第三个节点地址，之后使得odd.next指向第五...九、十一节点地址，而head节点地址不变。最后head为奇数第一节点，odd为奇数最后节点
    3. 3. 遍历使得even和evenHead的next变量都指向第四节点地址，之后even.next指向第六...十、十二节点地址，而evenHead节点地址不变。最后evenHead为偶数第一节点(2)，even为最后节点或null
    4. 4. 拼接奇偶链表，将odd的尾结点指向even的头节点，之后返回odd的头结点，即奇偶链表

#### 剑06 从尾到头打印节点
- ==重点：先算节点数，再初始化数组，倒着放进数组即可==

#### 剑18 删除链表节点
- ==题解：==
    1. ==设置虚拟头节点保存head地址，同时设其为pre节点==
    2. ==遍历链表，相等则使得pre跳过下一个节点==
    3. ==通过虚拟头节点返回真实头节点地址==

#### 剑35 含random链表的深拷贝
- 方案：
    - 拼接与拆分
    1. 在原链表的每个节点后新增一个相同val的节点
    2. 再讲新节点的random=原节点random.next
    3. 将新旧链表分离
    - 哈希表
    1. 使用哈希表复制新节点[node.val,新节点]
    2. 再遍历Head，哈希表的新节点则根据node.val(与原Head对应)赋值random
    3. 返回哈希表头节点

#### q92 移除链表元素
- 方案：设立pre指针并备份，遍历原链表相等则跳过

#### q61 旋转链表
- 方案：
    - 标记法
    1. 计算节点数n并设为环
    2. 在第倒数k%n节点处断开(尾结点设为null)
    - 递归法：
    1. 判断head.val等于head.next.val
        1. 相等则head.next都跳过，直到最后一个重复数，调用递归传入head.next即跳过最后一个重复数
        2. 不相等则head.next=递归传入head.next
        3. 最后跳过所有重复节点，递归返回头结点

#### q86 分隔链表
- 方案：
    - 拆分合并：
    1. 将链表中小于x的节点连接成新链表，并将原链表中小于x的节点删除
    2. 两链表合并

#### q23 合并k个有序链表
- 方案：
    - 归并-合并
    1. 归并链表数组
    2. 合并两链表

#### q25 k个一组翻转链表
- 遇到问题：
    1. 循环的节点变量与翻转的逻辑分离，但翻转的逻辑中却使用到了循环的节点变量，导致以下问题：
        1. 翻转发生变化，循环的节点也发生变化。(浅拷贝问题)。同时影响了翻转的逻辑与循环的执行
- 重点：反转截断处的四个切面
- 方案：
    - 截断-翻转-链接
    1. 初始化虚拟头结点、需翻转节点段的前一节点pre、需翻转的最后一个节点end
    2. 将end作为while循环的变量
    3. 如达到k个一组则进行翻转，否则break
    4. 翻转
        1. 断开-翻转-链接
        2. 初始化下次翻转的变量

### (二)：单节点查找/操作：快慢指针
- 主要解决链表中的问题，比如典型的判定链表中是否包含环。

### 应用
#### 1. 判断链表是否含有环
- 方案：
    - (一)设立快慢指针
    1. fast=slow=head
    2. fast指针的速度是slow指针的两倍，即slow=slow.next，fast=fast.next.next
    3. 当不存在环时，指针会到达终点即null，即判断fast.next&&fast.next.next是否为null
    4. 当存在环时，则fast=slow，因为fast超过了slow整数圈后相遇

```
boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;

        if (fast == slow) return true;
    }
    return false;
}
```
#### 2. 已知链表含有环，返回环的起点
- 提示：在1.找到代码的基础增加一段即可
- 方案：
    - (一)设立快慢指针找到环
    - (二)head到环起点=相遇点到环起点为相等
    1. 查找是否有环
    2. 让快慢指针其中一个指向head，与另一指针以同一速率出发即可找到环起点

![image](http://note.youdao.com/yws/res/32042/2C8321228AEC47BC85A96C31C34B1663)
![image](http://note.youdao.com/yws/res/32040/6AF6D51324FB4BF4B6E9148BF1482B18)

```
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    // 上面的代码类似 hasCycle 函数
    if (fast == null || fast.next == null) {
        // fast 遇到空指针说明没有环
        return null;
    }

    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

#### 3. 寻找链表的中点
- 方案：
    - (一)设立快慢指针
    1. 快指针的速度是慢指针的两倍，当fast指针到达终点时，slow指针即为中点
        - 当节点的数量为奇数为绝对中点，当节点的数量为偶数时，为偏右终点(如1~8中点为5)

```
ListNode middleNode(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    // slow 就在中间位置
    return slow;
}
```

#### 4. 删除链表的倒数第n个节点
- 方案：
    - (一)设立快慢指针，快指针先走
    - (二)快慢指针同时走
    1. 先让fast指针走n步(如走完n步到达终点null，则说明倒数n个节点为第一个节点)
    2. 再fast和slow指针同时出发，到达终点时slow指针即为倒数第n个节点
    3. 删除第n个节点

```
ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast, slow;
    fast = slow = head;
    // 快指针先前进 n 步
    while (n-- > 0) {
        fast = fast.next;
    }
    if (fast == null) {
        // 如果此时快指针走到头了，
        // 说明倒数第 n 个节点就是第一个节点
        return head.next;
    }
    // 让慢指针和快指针同步向前
    while (fast != null && fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // slow.next 就是倒数第 n 个节点，删除它
    slow.next = slow.next.next;
    return head;
}
```

#### q160 找到两链表的交点
![image](http://note.youdao.com/yws/res/33758/11AA688AC3964D5082372B12EDCE2202)
- 重点：a+b+c=b+a+c
    1. 当两链表长度相同时，双指针同时走会直接再c1相遇
    2. 当两链表长度不等时，双指针会在走过自己的一轮，而走对方的路线(a再走b，b再走a)是在c点相遇
        - 因为a+b+c=b+a+c，两指针都走完ab，会同时走c
#### q83 删除有序链表重复元素
- 方案：
    1. 循环判断是否重复
    2. 重复则head.next=head.next.next跳过重复元素，head不变
    3. 不重复则head=head.next
