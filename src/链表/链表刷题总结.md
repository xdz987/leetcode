### 一、链表节点批量操作
#### 单链表反转 q206 剑24
#### 方式一：递归——后序
- ==递归思想：每一层递归的函数都有各自的变量，传进的head.next作为每一层递归函数的参数，对应head地址即对应链表的每个节点。==
- ==基于递归思想：对每一层递归的节点，都将其next指针【以成对的方式进行反转】==
- ==递归函数的变量传递：每层递归返回当前节点的地址做保存于last变量，后一层递归的变量将前一层递归的变量进行了覆盖。==
    1. 返回当前地址做保存于last变量，又每层都有个last
    2. 根据变量的赋值传递，第一层递归对应最左边的last，最底层递归对应最右边的last，最右边的last值是最后一个节点的地址
    3. 最后递归返回时，使得每层递归函数的last变量都等于最后一层递归函数last的值即最后一个节点的地址
    - 即last(1)=last(2)=last(3)...=last(N)=ListNode(tail)
- ==题解：深入递归到达最后一对节点/两个节点，然后不断返回，执行反转操作。==
    - ==因为反转是成对的操作，所以head.nexst不能=null，否则返回==
    1. 当head||head.next为null返回head
    2. 反转【每对】节点
        - 后一节点指向当前节点
        - 当前节点指向null
    3. 递归返回值last指向最后一个节点
    4. 反转【每对节点】
        - 后一节点指向当前节点
            - 在上一层递归中后一节点是指向null的，在这一层递归指针又指向了前一个节点
        - 当前节点指向null
    4. 底层递归不断返回last【覆盖】上一层的值，最后第一层递归的last即为最底层递归的last。即反转链表后的头节点

#### 方式二：迭代实现
- 同【递归-前序】方式
- ==题解：通过记录pre节点地址，使得每个cur节点都可将next指向pre==
    1. 遍历链表
    2. 记录pre节点，将当前节点指向pre节点，动态更新pre节点。
    3. 最后head指向null结束循环，此时pre指向最后一个节点，即返回pre

#### 链表反转前N个 自定义题
#### 方式一：迭代实现
- 重点：
    1. 备份head为saveHead
    2. ==【同单链表反转】前n个节点进行单链表反转==
        - 此时pre即为新head
        - ==saveHead反转的截断点，head即为不反转的截断点，将saveHead联通head即可==
    2. 返回pre

#### 方式二：递归——后序
- 题解：
    - ==同【同单链表反转】，只是当n递减到1时递归叶结束==
    - ==将head.next原先指向为空，改为指向不反转链表的头节点。即前序时head.next。动态保存后继节点successor=head.next==
- 方案：
    1. 以节点长度n=1作为base case，并以全局的方式保存该节点的后继节点，返回该节点
    2. 从n递归到1，再1-n的每个结点指向前一节点，前一节点指向后继几点(保存好的)

#### 单链表范围反转 q92
- 效率：递归>定位截断反转法>定位头插法

#### 方式一：递归实现
1. 当m=1时，即反转前N个节点
2. 当m>1时，则head.next快进到base case。如m=2，n=4。那么head.next即为m=2-1，而n即数量则减1，相对上来看等同于反转前N个节点
```
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (left == 1) {
        return reverseN(head, right);
    }

    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, left - 1, right - 1);
    return head;
}
```

#### 方式二：迭代实现-定位截断反转法 O(2n)
1. 定位到m的前倾与n的位置
2. 将0~m，和n~length进行分段拆分，对m~n的节点进行单链表反转
3. 反转完成再链接到原来链表中

![image](http://note.youdao.com/yws/res/33691/661A1A5A02B348CEBFCDB0DFD16BCDA7)

#### 方式三：迭代实现-定位头插法 O(n)
1. 定位到需要反转的最左节点的前倾
2. 将m~n的节点进行反转，反转的方法类似队列
   - 从左到右重新将节点从左边放入队列，一轮循环后即反转

```
//迭代实现2 定位头插法
public ListNode reverseBetween(ListNode head, int left, int right) {
    // 增加一个虚拟头节点，使得当left=1时即第一个节点也有前倾，从而不需要增加额外的逻辑判断
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;

    //(1)定位到需要反转的最左节点的前倾
    ListNode pre = dummyNode;
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    ListNode cur = pre.next;
    //(2)开始反转。把需要反转的节点当做一个队列，从左到右重新将节点从左边放入队列，一轮循环后即反转
    for (int i = left + 1; i <= right; i++) {
        ListNode next = cur.next;

        //重新链接
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }

    return dummyNode.next;
}
```

#### q21 归并两个有序链表
#### 方式一：递归
- ==思想：将递归赋值给最一层的变量，最后return时返回到第一层变量==
- ==题解：==
    - ==注意：不需要创建头节点来存储归并结果，通过比较返回l1和l2中头结点.val小的即为【结果头节点】==
    - 步骤
        1. ==当l1为null返回l2==
        2. ==当l2为null返回l1==
        3. ==当l1.val>l2.val，设当前节点为l2，递归(l1,l2.next)==
        4. ==当l1.val<l2.val，设当前节点为l1，递归(l1.next,l2)==

#### 方式二：迭代
- ==题解：==
    1. ==创建虚拟头节点保存归并head的地址，设立归并head保存归并结果==
    2. 当l1&&l2都不为null，不断保存小值至head
    3. 返回虚拟头结点.next

#### 两两交换链表中的节点 q24
#### 方式一：递归
- ==题解：==
    1. ==当head或head.next为null直接返回head==
        - ==单个节点不需要交换==
    2. ==设后一个节点为新头节点，交换当前与后一节点。==
    3. ==将完成交换后的后一节点.next指向递归，传递值为原先的后后节==点

#### 方式二：迭代
- ==题解：==
    1. ==设立newHead，设立虚拟头节点dummy保存newHead地址==
    2. 由于两两交换，循环head和head.next如不为null
    3. ==将newHead.next指向第二个元素，交换第一个第二个元素。head与newHead指向第三个元素，准备下轮循环==
    4. 返回dummy.next

#### 链表求和 q445
#### 方法一：迭代-栈+链表
- ==即模拟两数相加==
- ==题解：使用栈存储l1和l2，使得顺序变成最小位先出栈==
    1. ==遍历，两栈或不为null或carry!=0==
    2. ==sum=n1+n2+carry，carry=sum/10，当前位值为sum%10==
    3. ==设立虚拟头结点，头插法==
- 栈结构性能：LinkedList>Stack

#### 链表求和 q2
- ==【同q445】==
    - ==栈换成链表==
    - ==直接前面即为低位，所以不需要头插法==

#### 回文链表 q234
- 快慢指针 反转链表
- ==题解：==
    1. ==快慢指针找打链表相对中点。同时将相对中点的往前一节点的所有链表反转==
    2. ==当fast为null，说明链表节点数量为奇数为。调整slow=slow.next使得比较的链表节点数相同==
    3. ==比较反转的链表与slow是否所有节点值相等==
        1. ==全部相等返回true==
        2. ==否则返回flase==

#### 分割链表 q725
- ==题解：边界处理==
    1. 遍历链表计算节点总数
    2. 计算每段链表节点数
        - sum/k
        - sum%k
    3. ==将每段链表头节点放入数组，到达边界后将边界设为null==

#### 奇偶链表 q328
- ==题解：==
    1. ==设odd=head,even=head.next，保存even头部==
    2. ==odd和even同时间隔着向后连接==
        - odd.next = odd.next.next
        - even.next = even.next.next
    3. ==odd.next拼接even头部==
    4. ==返回head即可==
- 方案：
    1. 先使得odd与head节点地址等于同一地址(第一个节点，奇数开头)。even与evenHead节点地址等于同一地址(第二个节点，偶数开头)
    2. 2. 遍历使得odd和head的next变量都指向第三个节点地址，之后使得odd.next指向第五...九、十一节点地址，而head节点地址不变。最后head为奇数第一节点，odd为奇数最后节点
    3. 3. 遍历使得even和evenHead的next变量都指向第四节点地址，之后even.next指向第六...十、十二节点地址，而evenHead节点地址不变。最后evenHead为偶数第一节点(2)，even为最后节点或null
    4. 4. 拼接奇偶链表，将odd的尾结点指向even的头节点，之后返回odd的头结点，即奇偶链表

#### 从尾到头打印节点 剑06
- ==重点：先算节点数，再初始化数组，倒着放进数组即可==

#### 删除链表节点 剑18
- ==题解：==
    1. ==设置虚拟头节点保存head地址，同时设其为pre节点==
    2. ==遍历链表，相等则使得pre跳过下一个节点==
    3. ==通过虚拟头节点返回真实头节点地址==

#### 含random链表的深拷贝 剑35
#### 方法一：拼接与拆分
- ==题解：通过将新链表所有节点统一放置到旧链表的右边。此时可以通过random.next查找到新链表对应旧链表的random==
    1. ==遍历链表，在每个节点右边创建新节点，赋值val属性==
    2. ==遍历链表，为新链表节点赋值random属性，通过random.next获取==
    3. ==创建虚拟头结点，遍历链表。将旧链表剥离，返回新链表头节点==
- 方案：
    1. 在原链表的每个节点后新增一个相同val的节点
    2. 再讲新节点的random=原节点random.next
    3. 将新旧链表分离

#### 方法二：哈希表
- ==题解：通过哈希映射(旧节点地址，新节点地址)，实现记录旧节点于链表的相对位置==
    1. ==遍历链表，将旧节点映射新节点，保存val，但空置next和random属性==
        - 建立旧节点与新节点的对称位置
    2. 遍历链表
        - ==get(node).next通过get(node.next)取得对称的新节点位置==
        - random同上
- 方案：
    1. 使用哈希表复制新节点[node.val,新节点]
    2. 再遍历Head，哈希表的新节点则根据node.val(与原Head对应)赋值random
    3. 返回哈希表头节点

#### 移除链表元素 q203
- 方案：设立pre指针并备份，遍历原链表相等则跳过

#### 旋转链表 q61
- 方案：
    - 标记法
    1. 计算节点数n并设为环
    2. 在第倒数k%n节点处断开(尾结点设为null)
    - 递归法：
    1. 判断head.val等于head.next.val
        1. 相等则head.next都跳过，直到最后一个重复数，调用递归传入head.next即跳过最后一个重复数
        2. 不相等则head.next=递归传入head.next
        3. 最后跳过所有重复节点，递归返回头结点

#### 分隔链表 q86
- 方案：
    - 拆分合并：
    1. 将链表中小于x的节点连接成新链表，并将原链表中小于x的节点删除
    2. 两链表合并

#### 合并k个有序链表 q23
- 方案：
    - 归并-合并
    1. 归并链表数组
    2. 合并两链表

#### k个一组翻转链表 q25
- 遇到问题：
    1. 循环的节点变量与翻转的逻辑分离，但翻转的逻辑中却使用到了循环的节点变量，导致以下问题：
        1. 翻转发生变化，循环的节点也发生变化。(浅拷贝问题)。同时影响了翻转的逻辑与循环的执行
- 重点：反转截断处的四个切面
- 方案：
    - 截断-翻转-链接
    1. 初始化虚拟头结点、需翻转节点段的前一节点pre、需翻转的最后一个节点end
    2. 将end作为while循环的变量
    3. 如达到k个一组则进行翻转，否则break
    4. 翻转
        1. 断开-翻转-链接
        2. 初始化下次翻转的变量

### (二)：单节点查找/操作：快慢指针
- 主要解决链表中的问题，比如典型的判定链表中是否包含环。

#### 环形链表 q141
#### 方法一：快慢指针
- 方案：
    1. fast=slow=head
    2. fast指针的速度是slow指针的两倍，即slow=slow.next，fast=fast.next.next
    3. 当不存在环时，指针会到达终点即null，即判断fast.next&&fast.next.next是否为null
    4. 当存在环时，则fast=slow，因为fast超过了slow整数圈后相遇

```
boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;

        if (fast == slow) return true;
    }
    return false;
}
```
#### 环形链表2 q1142
- 已知链表含有环，返回环的起点
- 方案：
    1. 快慢指针找到环
    2. head到环起点=相遇点到环起点为相等
        1. 查找是否有环
        2. 让快慢指针其中一个指向head，与另一指针以同一速率出发即可找到环起点

![image](http://note.youdao.com/yws/res/32042/2C8321228AEC47BC85A96C31C34B1663)
![image](http://note.youdao.com/yws/res/32040/6AF6D51324FB4BF4B6E9148BF1482B18)

```
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    // 上面的代码类似 hasCycle 函数
    if (fast == null || fast.next == null) {
        // fast 遇到空指针说明没有环
        return null;
    }

    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

#### 删除链表的倒数第n个节点 q19
- 方案：
    - (一)设立快慢指针，快指针先走
    - (二)快慢指针同时走
    1. 先让fast指针走n步(如走完n步到达终点null，则说明倒数n个节点为第一个节点)
    2. 再fast和slow指针同时出发，到达终点时slow指针即为倒数第n个节点
    3. 删除第n个节点

```
ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast, slow;
    fast = slow = head;
    // 快指针先前进 n 步
    while (n-- > 0) {
        fast = fast.next;
    }
    if (fast == null) {
        // 如果此时快指针走到头了，
        // 说明倒数第 n 个节点就是第一个节点
        return head.next;
    }
    // 让慢指针和快指针同步向前
    while (fast != null && fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // slow.next 就是倒数第 n 个节点，删除它
    slow.next = slow.next.next;
    return head;
}
```

#### 找到两链表的交点 q160
![image](http://note.youdao.com/yws/res/33758/11AA688AC3964D5082372B12EDCE2202)
- 重点：a+b+c=b+a+c
    1. 当两链表长度相同时，双指针同时走会直接再c1相遇
    2. 当两链表长度不等时，双指针会在走过自己的一轮，而走对方的路线(a再走b，b再走a)是在c点相遇
        - 因为a+b+c=b+a+c，两指针都走完ab，会同时走c

#### 删除有序链表重复元素 q83
- 方案：
    1. 循环判断是否重复
    2. 重复则head.next=head.next.next跳过重复元素，head不变
    3. 不重复则head=head.next
