 - 节点赋值与比较的含义

```
(浅拷贝)地址赋值：A=B(令A.val=1，此时B.val=1)
(深拷贝)内容赋值：A.val=B.val,A.next=B.next
修改A节点的指向：A.next = B(A.next存放B的地址)
AB指向同一节点,A或B经过N轮后,为链表终点，另一则为链表起点，即：
    1). A=B
    2). A=C，A=A.next.next...
    3). B.next.next...最终等于A节点

删除下一节点：A.next = A.next.next
截断：A.next = null

判断节点是否同一节点：A == B
判断节点指向是否相同：A.next == B.next
判断B节点是否为A节点的后继：A.next == B
```

 - 节点交换/反转要素
    - 浅拷贝问题
 1. 需要两个额外变量
    1. 一个用于记录前一节点即pre
    2. 一个用于用于操作当前节点(避免浅拷贝问题)

```
pre=null;

//当前节点需要转向
current = cur;

//游标指向下一个
cur = cur.next;

//当前节点转向
current.next = pre;
//临时变量pre向前
pre = current;
```

### (一)链表节点批量操作
#### 反转链表
##### 1. 单链表反转
 - 重点：反转指针的指向
 1. 递归实现
    1. base case是指向链表的最后一个结点
    2. 从head到最后一个节点不断递归，最后再往回传递，使得后一个指向前一个，最后最前一个指向null完成反转
```
ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}
```
 2. 迭代实现
    1. 注意点将next变量与结点的next意义分离
        - 前者的next变量用于交换指针，是动态变化的
    2. 完成反转的while结束条件是cur=null，即已经没有下一个元素可以进行反转

```
public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            //---上面完成初始化：前中后---
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
```
##### 2. 单链表反转前N个
 1. 递归实现
    1. 以节点长度n=1作为base case，并以全局的方式保存该节点的后继节点，返回该节点
    2. 从n递归到1，再1-n的每个结点指向前一节点，前一节点指向后继几点(保存好的)
```
递归实现
ListNode successor = null; //后继节点
public ListNode reverseN(ListNode head, int n) {
    if (n == 1) {
        //记录第n+1节点
        successor = head.next;
        return head;
    }
    // 以head.next为起点，需要反转前n-1个节点
    ListNode last = reverseN(head.next, n - 1);

    // 后一节点指向前一节点
    head.next.next = head;
    // 前一节点指向后继节点
    head.next = successor;

    // 返回新的head
    return last;
}
```

 2. 迭代实现
    1. 前n个节点进行单链表反转，记录位置
    2. 最后将反转完成的头节点链接到第n+1个节点

```
//迭代实现
public ListNode reverseN(ListNode head, int n) {
    //(1)初始化前pre 中cur 后next指针。pre和cur进行节点交换，next作记录作用记录下一个节点
    ListNode pre = null;
    ListNode cur = head;
    int i = 1;

    //(2)循环交换指针 前与中交换
    while (i <= n) {
        //记录下一个指针
        ListNode next = cur.next;

        //交换指针
        cur.next = pre;
        pre = cur;
        cur = next;
        i++;
    }
    //(3)交换完成后，head则作为前n个节点的最后一个节点，连接n+1节点，完成反转
    head.next = cur;
    return pre;
}
```
##### 3. 单链表范围反转
 1. 递归实现
    1. 当m=1时，即反转前N个节点
    2. 当m>1时，则head.next快进到base case。如m=2，n=4。那么head.next即为m=2-1，而n即数量则减1，相对上来看等同于反转前N个节点
```
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (left == 1) {
        return reverseN(head, right);
    }

    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, left - 1, right - 1);
    return head;
}
```

 2. 迭代实现-定位截断反转法 O(2n)
    1. 定位到m的前倾与n的位置
    2. 将0~m，和n~length进行分段拆分，对m~n的节点进行单链表反转
    3. 反转完成再链接到原来链表中

![image](http://note.youdao.com/yws/res/33691/661A1A5A02B348CEBFCDB0DFD16BCDA7)
 3. 迭代实现-定位头插法 O(n)
    1. 定位到需要反转的最左节点的前倾
    2. 将m~n的节点进行反转，反转的方法类似队列
        - 从左到右重新将节点从左边放入队列，一轮循环后即反转

```
//迭代实现2 定位头插法
public ListNode reverseBetween(ListNode head, int left, int right) {
    // 增加一个虚拟头节点，使得当left=1时即第一个节点也有前倾，从而不需要增加额外的逻辑判断
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;

    //(1)定位到需要反转的最左节点的前倾
    ListNode pre = dummyNode;
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    ListNode cur = pre.next;
    //(2)开始反转。把需要反转的节点当做一个队列，从左到右重新将节点从左边放入队列，一轮循环后即反转
    for (int i = left + 1; i <= right; i++) {
        ListNode next = cur.next;

        //重新链接
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }

    return dummyNode.next;
}
```

#### q21 归并两个有序链表
 - 方案
     - 递归：不断递归比较，传入小的节点并往回保存
     - 迭代
     1. 创建一个新node作保存
     2. 循环遍历l1和l2，新node保存更小的那个，直到l1或l2为null
     3. 将另一个不为null(剩下的都是大数)的连接到新node

#### q24 两两交换链表中的节点
 - 重点：
    1. 设置虚拟头结点保存Head并作为第一个节点的前倾
    2. 交换节点之间的指针完成两两交换

#### q445 q2 链表求和 栈
 - 重点：使用栈存储数字，先进后出，计算后存入新节点
    - LinkedList>Stack
 - 方案：
    1. 初始化并构建l1和l2的栈
    2. 设置int carry用于进位
    3. 计算sum=栈1pop+栈2pop+carry(上一轮)
        - 栈为empty则0
    4. 新节点为sum%10，并插入头部
    5. carry=sum/10

#### q9 回文链表 快慢指针 反转链表
 - 方案：
    1. 快慢指针找到中点，并将前半节点反转
    2. 比较前一半节点与后一半节点是否相等

#### q725 分割链表
 - 方案：
    1. 先计算链表数量n
    2. 再计算每个分割的链表数量size，与多出的节点mod
    3. 填充每段链表

#### q328 奇偶链表
 - 方案：
     1. 先使得odd与head节点地址等于同一地址(第一个节点，奇数开头)。even与evenHead节点地址等于同一地址(第二个节点，偶数开头)
     2. 2. 遍历使得odd和head的next变量都指向第三个节点地址，之后使得odd.next指向第五...九、十一节点地址，而head节点地址不变。最后head为奇数第一节点，odd为奇数最后节点
     3. 3. 遍历使得even和evenHead的next变量都指向第四节点地址，之后even.next指向第六...十、十二节点地址，而evenHead节点地址不变。最后evenHead为偶数第一节点(2)，even为最后节点或null
     4. 4. 拼接奇偶链表，将odd的尾结点指向even的头节点，之后返回odd的头结点，即奇偶链表

#### 剑06 从尾到头打印节点
 - 重点：先算节点数，再初始化数组，倒着放进数组即可

#### 剑18 删除链表节点
 - 方案： 
    1. 设置虚拟头节点保存head地址，同时设其为pre节点
    2. 遍历链表，相等则使得pre跳过下一个节点
    3. 通过虚拟头节点返回真实头节点地址

### (二)：单节点查找/操作：快慢指针
 - 主要解决链表中的问题，比如典型的判定链表中是否包含环。

### 应用
#### 1. 判断链表是否含有环
 - 方案：
    - (一)设立快慢指针
    1. fast=slow=head
    2. fast指针的速度是slow指针的两倍，即slow=slow.next，fast=fast.next.next
    3. 当不存在环时，指针会到达终点即null，即判断fast.next&&fast.next.next是否为null
    4. 当存在环时，则fast=slow，因为fast超过了slow整数圈后相遇

```
boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;

        if (fast == slow) return true;
    }
    return false;
}
```
#### 2. 已知链表含有环，返回环的起点
 - 提示：在1.找到代码的基础增加一段即可
 - 方案：
    - (一)设立快慢指针找到环
    - (二)head到环起点=相遇点到环起点为相等
    1. 查找是否有环
    2. 让快慢指针其中一个指向head，与另一指针以同一速率出发即可找到环起点

![image](http://note.youdao.com/yws/res/32042/2C8321228AEC47BC85A96C31C34B1663)
![image](http://note.youdao.com/yws/res/32040/6AF6D51324FB4BF4B6E9148BF1482B18)

```
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    // 上面的代码类似 hasCycle 函数
    if (fast == null || fast.next == null) {
        // fast 遇到空指针说明没有环
        return null;
    }

    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

#### 3. 寻找链表的中点
 - 方案：
    - (一)设立快慢指针
    1. 快指针的速度是慢指针的两倍，当fast指针到达终点时，slow指针即为中点
        - 当节点的数量为奇数为绝对中点，当节点的数量为偶数时，为偏右终点(如1~8中点为5)

```
ListNode middleNode(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    // slow 就在中间位置
    return slow;
}
```

#### 4. 删除链表的倒数第n个节点
 - 方案：
    - (一)设立快慢指针，快指针先走
    - (二)快慢指针同时走
    1. 先让fast指针走n步(如走完n步到达终点null，则说明倒数n个节点为第一个节点)
    2. 再fast和slow指针同时出发，到达终点时slow指针即为倒数第n个节点
    3. 删除第n个节点

```
ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast, slow;
    fast = slow = head;
    // 快指针先前进 n 步
    while (n-- > 0) {
        fast = fast.next;
    }
    if (fast == null) {
        // 如果此时快指针走到头了，
        // 说明倒数第 n 个节点就是第一个节点
        return head.next;
    }
    // 让慢指针和快指针同步向前
    while (fast != null && fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // slow.next 就是倒数第 n 个节点，删除它
    slow.next = slow.next.next;
    return head;
}
```

#### q160 找到两链表的交点
![image](http://note.youdao.com/yws/res/33758/11AA688AC3964D5082372B12EDCE2202)
 - 重点：a+b+c=b+a+c
    1. 当两链表长度相同时，双指针同时走会直接再c1相遇
    2. 当两链表长度不等时，双指针会在走过自己的一轮，而走对方的路线(a再走b，b再走a)是在c点相遇
        - 因为a+b+c=b+a+c，两指针都走完ab，会同时走c
#### q83 删除有序链表重复元素
 - 方案：
    1. 循环判断是否重复
    2. 重复则head.next=head.next.next跳过重复元素，head不变
    3. 不重复则head=head.next
