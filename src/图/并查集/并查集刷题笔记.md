## 一、DFS的替代方案
#### 被围绕的区域 q130
#### 方案一：并查集
 - 前置知识：
     1. 将二维坐标映射到一维坐标
        - 一维坐标等于x*n+y，其中x为行y为列
     2. 方向控制，二维数组{{1,0}, {0,1}, {0,-1}, {-1,0}}
        - 按序分别对应着下、右、左，上
            - 不为矩阵的边否则越界，有几个方向脱离矩阵范围
        - 比如(1,1)某坐标的加“下”(即{1,0})变成(2,1)，即为(1,1)的下面

##### 方向控制例子
```
// 方向数组初始化
int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};

//某坐标的“上下左右”(即周围)是否含有“0”元素
for (int k = 0; k < 4; k++) {
    int x = i + d[k][0];
    int y = j + d[k][1];
    if (board[x][y] == 'O')
        uf.union(x * n + y, i * n + j);
}
```
 - 重点：枚举每个元素，如该元素为O，则联通其周围(即上下左右)的O，最后将未联通dummy的O转换为X即可。
    1. 最后可得，边界的O联通了dummy，靠近边界O的O也相互联通
    2. 其它O相互联通，这些O即转为X
 - 方案：
    1. 设并查集数组长度为m乘n+1(即区域的行乘列，加一是留位给虚拟祖先)
    2. 将区域的四个边中的O与虚拟祖先dummy联通
    3. 暴力枚举区域内(除了四个边)的每个元素是否为O，是则联通此元素周围存在的O
    4. 最后将所有不与虚拟祖先联通的O转换为X

##### 虚拟祖先联通示意图
![image](http://note.youdao.com/yws/res/36810/3C6A09B1FBCA40A58304160A6DE9F767)