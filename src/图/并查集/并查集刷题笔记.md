## 一、DFS的替代方案
### 被围绕的区域 q130
#### 方案一：并查集
 - 前置知识：
     1. 将二维坐标映射到一维坐标
        - 一维坐标等于x*n+y，其中x为行y为列
     2. 方向控制，二维数组{{1,0}, {0,1}, {0,-1}, {-1,0}}
        - 按序分别对应着下、右、左，上
            - 不为矩阵的边否则越界，有几个方向脱离矩阵范围
        - 比如(1,1)某坐标的加“下”(即{1,0})变成(2,1)，即为(1,1)的下面

##### 方向控制例子
```
// 方向数组初始化
int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};

//某坐标的“上下左右”(即周围)是否含有“0”元素
for (int k = 0; k < 4; k++) {
    int x = i + d[k][0];
    int y = j + d[k][1];
    if (board[x][y] == 'O')
        uf.union(x * n + y, i * n + j);
}
```
 - 重点：枚举每个元素，如该元素为O，则联通其周围(即上下左右)的O，最后将未联通dummy的O转换为X即可。
    1. 最后可得，边界的O联通了dummy，靠近边界O的O也相互联通
    2. 其它O相互联通，这些O即转为X
 - 方案：
    1. 设并查集数组长度为m乘n+1(即区域的行乘列，加一是留位给虚拟祖先)
    2. 将区域的四个边中的O与虚拟祖先dummy联通
    3. 暴力枚举区域内(除了四个边)的每个元素是否为O，是则联通此元素周围存在的O
    4. 最后将所有不与虚拟祖先联通的O转换为X

##### 虚拟祖先联通示意图
![image](http://note.youdao.com/yws/res/36810/3C6A09B1FBCA40A58304160A6DE9F767)
#### 方案二：DFS
 - 重点：将边界(四个边)上的O，以及与边界上O联通的O，以及与以上联通的O。都设为一个占位符(#也行)，之和将所有O改为X，#改为O
 - 方案：
    1. 迭代区域的四条边，如为O，则进行DFS递归，替换为#
        - DFS将向该O的“上下左右”进行递归，为O的则替换为#，并继续递归
            - base case为越界并不为O
    2. 枚举每个元素，O改为X，#改为O

#### 性能DFS > 并查集

### 等式方程的可满足性 q990
 - 重点：等式的字母与不等式的字母一定不连通
 - 方案：
    1. 枚举每个等式，将所有相等的字母链接到同个祖先
    2. 枚举每个不等式，将不等的字母测试是否为同一祖先
        - 如所有不等式都不连通，则tre
        - 如存在联通，则说明逻辑冲突

### 冗余连接1 q684
#### 方法一：并查集
 - 前置：
    1. 边集数组
    2. 如果一棵树有N个节点，则这棵树有N-1条边
        - 题目条件已知为N条边
 - 重点：设一开始所有顶点不连通，之和遍历边集数组，如边不连通，则进行联通，如已经联通，则说明是附加的边，直接返回
 - 方案：
    1. 将每个顶点放入并查集数组
    2. 遍历边集数组
        1. 如果边的两顶点不连通，则进行联通
        2. 如边的两个顶点联通，则说明该边是附加边，直接返回

### 账号合并 q721
#### 方案一：并查集
 - 重点：并查集的parent是账号id，形参为List的形式需转换为Map形式方便进行并查操作
    - 因为账号id与邮箱是非平级关系
 - 方案：
    1. 首先将数据整理成<邮箱,账号id>的形式，以账号id作为并查集的parent。将具有相同邮箱的账号id进行联通
        - 因为是Map存储，所以具有相同邮箱的只需要存储一次，重复的忽略
    2. 其次将数据整理成<账号id，邮箱列表>的形式，此时将联通的账号id的邮箱列表整理在一起
    3. 最后将邮箱按ASCII字符排序，并整理成返回值要求

### 交换字符中的元素 q1202
#### 方案一：并查集+手动排序字符
 - 重点：将可交换的字符进行联通
 - 方案：
    1. 并查集容量为字符串s.length
    2. 对能够进行交换的字符进行联通
    3. 将同一祖先的字符整理成Map形式
        - <祖先字符索引，字符索引列表>
    4. 将同一祖先的字符按照“字典序最小”排序
        - 先将s转换为字符数组ss
        1. 遍历寻字符祖先map
        2. 将该祖先下的字符添加到一个List，并将该次循环的祖先下所有字符填充为'#'于字符数组ss
        3. 对list进行排序
        4. 回填排好序的字符到字符数组ss
    5. 返回字符数组ss转换字符串

#### 方案二：并查集+小顶堆(jdk自带)
 - 方案：
    1. 并查集容量为字符串s.length
    2. 对能够进行交换的字符进行联通
    3. 将同一祖先的字符的索引整理成Map
        - <祖先字符索引，小顶堆(队列)<祖先下的字符列表>>
    4. 整理返回数据
        - 关于小顶堆：例如并查集中某祖先3-->[5,3,4,6]，而再map中则是祖先3-->小顶堆[a,c,e,b]（即字符完全对应索引，但最小字符在顶部）

#### 性能优劣：小顶堆 > 手动排序

### 省份数量 q548
 - 题意：二维矩阵实为城市对应表，即对称矩阵，为正方形即n=m。题目要求返回最后的联通分量数

#### 方法一：并查集
 - 重点：设初始化省份数量(联通分量)为城市数量，城市进行一次联通则说明省份数量-1
 - 方案：
    1. 对城市进行联通
    2. 返回联通分量数量即为省份数量

#### 方法二：DFS
 - 重点：利用题意的对称矩阵特性，遍历行(每个城市)，如为1，则遍历该城市的列
    - 不断的联通，并设为visited已访问过。一次DFS递归即为一个省份

#### 方法三：BFS
 - 重点：类似于DFS，第一行为主循环，将第一行的每个城市push进队列(DFS)，判断[i][j]为1的则visited为ture，并继续放入队列(DFS)

##### DFS/BFS走势如图，主循环遍历所有城市，DFS该A城市直接相通的B城市visited为true，并DFS B城市，不断DFS/BFS

![image](http://note.youdao.com/yws/res/37135/AE7DFBA4F2844AFC839CAEA134D1C407)

#### 性能比较：DFS>并查集>BFS
 - DFS：100% 17%
 - BFS：14% 92%
 - 并查集：45% 59%

### 婴儿名字 面1707
#### 超时版：并查集-僵硬版
 - 方案：
    1. 以names数组的下标作为parent进行初始化
    2. 联通synonyms数组对应的name
        - 只有synonyms[i]的两个名字都存在于names才需要联通
    3. 累加联通的同义name，并保存最小字典顺序的name
    4. 将数据整理成题目要求

#### 方法一：并查集—灵活版
 - 重点：
 1. 按字典顺序union：原版size[]数组加权union是为了平衡parent树。但此题采用字典顺序比较，使得root节点始终是最小字典顺序name，起到[小顶堆]的作用
 2. 附加频率属性：题目将name与频率进行了耦合，并不方便运算，而此题设计将频率分离出来并附加到parent对应节点下进行保存
 3. 前缀和：采用前缀和的方式优点在于，最后遍历name时，可以通过root是否等于name自己的判断，起到过滤root子节点(有重复名且非最小字典的name)的作用，节约计算
 - 方案：
    1. 初始化并查集，以name为parent的key
        - name<String,String>
        - freq<String,Integer>
    2. 根据synonyms[]数组联通name，并对synonyms姓名不存在于name的姓名补充进parent
    3. 统计真实姓名频率，只有parent中祖先是自己的name需要统计

### 岛屿数量 q200
 - 题意：岛屿可以是很多陆地"1"组成，不是单个1

#### 方法一：并查集
 - 重点：设初始化联通分量为1的数量，最后返回联通后的联通分量即为小岛数量
 - 方案：
    1. 初始化并查集、联通分量为"1"的数量
    2. 遍历每个元素，联通每个元素"1"与其"上下左右"的"1"
    3. 返回联通分量数量

#### 方法二：DFS
 - 重点：找到为"1"陆地，向上下左右DFS，basecase为越界、已访问、"0"水，设已访问过的"1"为"0"
 - 方案：
    1. 遍历所有节点
        1. 当节点为"1"即陆地时向上下左右DFS
        2. DFS结束，岛屿数量+1
    2. DFS：越界、"0"水返回，否则设为已访问即为"0"，并继续向上下左右DFS

#### 方法三：BFS
 - 重点：基本同方法二，只是DFS使用队列替代
 - 方案：
    1. 遍历所有节点
        1. 当节点为"1"push坐标进度列
        2. 循环判断队列是否为空
            1. pop队列坐标，设为'0'已访问
            2. 遍历该坐标上下左右不越界、且为'1'，将坐
            push进度列
        3. 岛屿数量+1
    2. 返回岛屿数量

#### 时间优劣：DFS>并查集>BFS
#### 空间优劣：并查集>DFS>BFS


