## 一、DFS的替代方案
### 被围绕的区域 q130
#### 方案一：并查集
 - 前置知识：
     1. 将二维坐标映射到一维坐标
        - 一维坐标等于x*n+y，其中x为行y为列
     2. 方向控制，二维数组{{1,0}, {0,1}, {0,-1}, {-1,0}}
        - 按序分别对应着下、右、左，上
            - 不为矩阵的边否则越界，有几个方向脱离矩阵范围
        - 比如(1,1)某坐标的加“下”(即{1,0})变成(2,1)，即为(1,1)的下面

##### 方向控制例子
```
// 方向数组初始化
int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};

//某坐标的“上下左右”(即周围)是否含有“0”元素
for (int k = 0; k < 4; k++) {
    int x = i + d[k][0];
    int y = j + d[k][1];
    if (board[x][y] == 'O')
        uf.union(x * n + y, i * n + j);
}
```
 - 重点：枚举每个元素，如该元素为O，则联通其周围(即上下左右)的O，最后将未联通dummy的O转换为X即可。
    1. 最后可得，边界的O联通了dummy，靠近边界O的O也相互联通
    2. 其它O相互联通，这些O即转为X
 - 方案：
    1. 设并查集数组长度为m乘n+1(即区域的行乘列，加一是留位给虚拟祖先)
    2. 将区域的四个边中的O与虚拟祖先dummy联通
    3. 暴力枚举区域内(除了四个边)的每个元素是否为O，是则联通此元素周围存在的O
    4. 最后将所有不与虚拟祖先联通的O转换为X

##### 虚拟祖先联通示意图
![image](http://note.youdao.com/yws/res/36810/3C6A09B1FBCA40A58304160A6DE9F767)
#### 方案二：DFS
 - 重点：将边界(四个边)上的O，以及与边界上O联通的O，以及与以上联通的O。都设为一个占位符(#也行)，之和将所有O改为X，#改为O
 - 方案：
    1. 迭代区域的四条边，如为O，则进行DFS递归，替换为#
        - DFS将向该O的“上下左右”进行递归，为O的则替换为#，并继续递归
            - base case为越界并不为O
    2. 枚举每个元素，O改为X，#改为O

#### 性能DFS > 并查集

### 等式方程的可满足性 q990
 - 重点：等式的字母与不等式的字母一定不连通
 - 方案：
    1. 枚举每个等式，将所有相等的字母链接到同个祖先
    2. 枚举每个不等式，将不等的字母测试是否为同一祖先
        - 如所有不等式都不连通，则tre
        - 如存在联通，则说明逻辑冲突

### 冗余连接1 q684
#### 方法一：并查集
 - 前置：
    1. 边集数组
    2. 如果一棵树有N个节点，则这棵树有N-1条边
        - 题目条件已知为N条边
 - 重点：设一开始所有顶点不连通，之和遍历边集数组，如边不连通，则进行联通，如已经联通，则说明是附加的边，直接返回
 - 方案：
    1. 将每个顶点放入并查集数组
    2. 遍历边集数组
        1. 如果边的两顶点不连通，则进行联通
        2. 如边的两个顶点联通，则说明该边是附加边，直接返回

### 账号合并 q721
#### 方案一：并查集
 - 重点：并查集的parent是账号id，形参为List的形式需转换为Map形式方便进行并查操作
    - 因为账号id与邮箱是非平级关系
 - 方案：
    1. 首先将数据整理成<邮箱,账号id>的形式，以账号id作为并查集的parent。将具有相同邮箱的账号id进行联通
        - 因为是Map存储，所以具有相同邮箱的只需要存储一次，重复的忽略
    2. 其次将数据整理成<账号id，邮箱列表>的形式，此时将联通的账号id的邮箱列表整理在一起
    3. 最后将邮箱按ASCII字符排序，并整理成返回值要求

### 交换字符中的元素 q1202
#### 方案一：并查集+手动排序字符
 - 重点：将可交换的字符进行联通
 - 方案：
    1. 并查集容量为字符串s.length
    2. 对能够进行交换的字符进行联通
    3. 将同一祖先的字符整理成Map形式
        - <祖先字符索引，字符索引列表>
    4. 将同一祖先的字符按照“字典序最小”排序
        - 先将s转换为字符数组ss
        1. 遍历寻字符祖先map
        2. 将该祖先下的字符添加到一个List，并将该次循环的祖先下所有字符填充为'#'于字符数组ss
        3. 对list进行排序
        4. 回填排好序的字符到字符数组ss
    5. 返回字符数组ss转换字符串

#### 方案二：并查集+小顶堆(jdk自带)
 - 方案：
    1. 并查集容量为字符串s.length
    2. 对能够进行交换的字符进行联通
    3. 将同一祖先的字符的索引整理成Map
        - <祖先字符索引，小顶堆(队列)<祖先下的字符列表>>
    4. 整理返回数据
        - 关于小顶堆：例如并查集中某祖先3-->[5,3,4,6]，而再map中则是祖先3-->小顶堆[a,c,e,b]（即字符完全对应索引，但最小字符在顶部）

#### 性能优劣：小顶堆 > 手动排序

