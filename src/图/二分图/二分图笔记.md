### 一、算法思想
- 二分图：图中的顶点由两个集合组成，且所有边的两个顶点正好分别处在两个集合里

![image](http://note.youdao.com/yws/res/44259/1F4B9E6322074115BF6F3EFD94F9389C)
- 算法功能：判断图是否为二分图

### 二、算法实现
- 复杂度：O(N+M) O(N)
   - 其中N是无向图的顶点数，M是无向图的边数
   - 三种方法都是

#### (一)BFS+标记数组
- 思想：类似于颜色标记法。将cur顶点设为颜色1，cur邻接顶点则设为颜色-1，最后形成间隔顶点颜色相同，达到二分图效果。当存在颜色相同时，则说明交叉了不是二分图，返回false，否则所有顶点完成二分染色，返会true。
- 步骤：
   1. 初始化标记数组、队列
   2. 遍历所有顶点
      - 因为不一定所有顶点都联通
      1. 不为0即已访问，continue
      2. 将i顶点offer进队列
      3. 设flags[i]为颜色"1"
      4. 遍历队列如果不为空
         1. 弹出顶点命名v
         2. 遍历顶点v邻接的所有顶点    1. 如果邻接顶点颜色等于顶点v，则说明不是二分图，直接返回false
            2. 如果未访问过，则设为与顶点v相反的颜色（即1/-1变-1/1），并offer进队列
   3. 到此说明为二分图，返回true

#### (二)DFS
- 思想：与BFS相似，将要染色的目标颜色作为递归参数color。染过色的则返回与color的比较结果，未染过色的则染色，并遍历所有邻接顶点传递相反color颜色作为参数
- 步骤：同BFS，要染的颜色作为color传入递归函数。basease为已染过色后返回比较color结果

#### (三)并查集
- 思想：二分图即一分的顶点一定与另一分的顶点不联通。遍历顶点i的邻接顶点，将i的邻接顶点相互联通（i顶点不联通）。如果在合并前就发现已经联通，则说明交叉了，即不是二分图。

![image](http://note.youdao.com/yws/res/44352/A97BF09F29CF473396531C501622720A)
- 步骤：
   1. 初始化并查集
   2. 将i的邻接顶点相互联通（i顶点不联通）
      1. 遍历顶点i的邻接顶点
         1. 如果顶点i与任意邻接顶点合并联通，那么说明交叉，返回false
         2. 将邻接顶点进行合并，即顶点i的第[0]个邻接顶点和其他邻接顶点
            - 因为[0]必定存在
   3. 到此说明不存在交叉，为二分图

#### 性能：DFS>并查集>BFS
- 分析：
   1. BFS用到了队列，性能上不如递归
   2. 并查集初始化耗费一定性能，当数据量越大时才凸显优势

#### 可能的二分法 q886
- 重点：
   1. 编号从1开始，所有N需+1
   2. 将分成按dislikes分组根据二分图算的思想转换为图的数据结构(这里是邻接表)
   3. 【其他同q785】

#### 同样三种方法