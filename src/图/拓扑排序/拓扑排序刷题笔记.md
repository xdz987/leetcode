## 拓扑排序刷题笔记
#### 课程表 q207
#### 方法一：BFS+入度表
- ==步骤：==
    - ==组成：==
        - ==入度表：每个元素的入度数量==
        - ==邻接表：索引下标等同于对应元素，每个下标创建一个单向链表==
        - ==队列：将没有前置课程即入度为0的课程加入队列进行操作==
    - ==解题：==
        1. ==初始化入度表、邻接表==
        2. ==将课程入度为0的放入队列==
        3. ==遍历队列，将元素出队，未修课程-1。并将以该课程为前置的课程入度-1，如为0添加进队列==
        4. ==返回未修课程=0==
- 复杂度：O(N+M) O(N+M)
- 重点：通过入度来判断是否完成了前置课程，从而添加进队列进行del
- 方案：
    1. 初始化邻接表、入度表
    2. 将入度为0的课程【下标】（没有前置课程）放入队列
    3. 遍历queue如果不为空
        1. 将队列中的课程del
        2. del节点后剩余课程总数-1
        3. 遍历邻接节点，将其邻接节点入度-1
            1. inDegrees[cur]--;
            2. 如果入度=0，入队
    4. 返回剩余课程总数==0

#### 方法二：DFS+标记表
- ==步骤：==
    - ==组成：==
        - ==邻接表：【同BFS】==
        - ==标记表：标记元素是否访问==
    - ==解题：==
        1. ==初始化邻接表、标记表==
        2. ==dfs判断邻接表是否存在环==
            - ==访问过的设为1，以该课程为起点继续dfs==
                - ==如果还为1则为环==
                - ==如果为-1则返回true==
            - ==该课程的单链表访问完成，将该课程flag设为-1==
- 复杂度：O(N+M) O(N+M)
- 重点：通过DFS来遍历以某节点作为起点的所有邻接节点，通过flags[]来判断是否为当前节点的DFS还是邻接节点的DFS、以及访问与否，以此判断环是否存在，从而判断不存在环即可拓扑排序。
- 方案：
    1. 初始化邻接表、标记表
    2. 遍历每个节点作为起点DFS
        - 某节点DFS为false立马返回false
    3. 到此说明所有节点DFS都为true直接返回结果true
    - DFS：
        1. 当flags[i]=-1返回true
        2. 当flags[i]=1返回false
        3. 设flags[i]=0
        4. 遍历flags[i]的每个邻接节点作为DFS遍历
            - DFS结果为false直接返回false
        5. 邻接节点遍历完成，设flags[i]=-1
        6. 以i作为起点的DFS不存在环，返回true

#### 效率：DFS>BFS
- 分析：
    - DFS一不满足条件立即返回false
    - BFS需要遍历完所有节点才能判定是否能够进行拓扑排序，返回true/false

#### 课程表2 q210
- 思路同q207

#### 方法一：BFS+入度表
- 重点：入队列的条件是入度为0，那么res在入队时记录即可

#### 方法二：DFS+标记表
- 重点：
    1. 当DFS把当前节点flags[i]设为-1时才说明此条学习路线成立。所以rs在此记录。
    2. 由于是从最终课程往前前置课程倒着记录，所以最后res需要反转

