## 拓扑排序刷题笔记
#### 课程表 q207
#### 方法一：BFS+入度表
- 复杂度：O(N+M) O(N+M)
- 重点：通过入度来判断是否完成了前置课程，从而添加进队列进行del
- 方案：
    1. 初始化邻接表、入度表
    2. 将入度为0的课程【下标】（没有前置课程）放入队列
    3. 遍历queue如果不为空
        1. 将队列中的课程del
        2. del节点后剩余课程总数-1
        3. 遍历邻接节点，将其邻接节点入度-1
            1. inDegrees[cur]--;
            2. 如果入度=0，入队
    4. 返回剩余课程总数==0

#### 方法二：DFS+标记表
- 复杂度：O(N+M) O(N+M)
- 重点：通过DFS来遍历以某节点作为起点的所有邻接节点，通过flags[]来判断是否为当前节点的DFS还是邻接节点的DFS、以及访问与否，以此判断环是否存在，从而判断不存在环即可拓扑排序。
- 方案：
    1. 初始化邻接表、标记表
    2. 遍历每个节点作为起点DFS
        - 某节点DFS为false立马返回false
    3. 到此说明所有节点DFS都为true直接返回结果true
    - DFS：
        1. 当flags[i]=-1返回true
        2. 当flags[i]=1返回false
        3. 设flags[i]=0
        4. 遍历flags[i]的每个邻接节点作为DFS遍历
            - DFS结果为false直接返回false
        5. 邻接节点遍历完成，设flags[i]=-1
        6. 以i作为起点的DFS不存在环，返回true

#### 效率：DFS>BFS
- 分析：
    - DFS一不满足条件立即返回false
    - BFS需要遍历完所有节点才能判定是否能够进行拓扑排序，返回true/false

#### 课程表2 q210
- 思路同q207

#### 方法一：BFS+入度表
- 重点：入队列的条件是入度为0，那么res在入队时记录即可

#### 方法二：DFS+标记表
- 重点：
    1. 当DFS把当前节点flags[i]设为-1时才说明此条学习路线成立。所以rs在此记录。
    2. 由于是从最终课程往前前置课程倒着记录，所以最后res需要反转

