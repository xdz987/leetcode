## 排序
将无序的数据进行排序，通常应用于数组数据结构。

## 一、基于比较排序
### (一)交换排序
#### 1. 冒泡排序 *
- 重点：循环不断交换，将最小/大交换至最左/右

#### 2. 快速排序 *
- 名词解释：
  - pivotIndex变量：切分左右分区(一半大一半小)的切点
    - 切点即为该元素位于有序数组中所在位置
  - partition方法：对数组进行左右分区，返回切点pivotIndex
  - quickSort方法：对数组进行递归，不断的递归分区
    - 范围是除了切点partition
  - 快排算法：不断按照切点pivot(可随机)进行分区，分区完成切点pivot即为正确位置(排序完成的位置)，之后分治对左右分区再分，直到小于2个元素，也说明确定了所有元素的pivot，即排序完成
- 重点：
  1. 递归的出口为：left<right
    - 即至少两个元素。才有必要进行分区和排序
- 优化：
  - pivot可以选择中间数，避免有序而导致O(n^2)
    - partition方法增加swap(nums, left, (left + right) >> 1);

### (二)插入排序
#### 1. 简单插入排序
#### 2. 希尔排序

### (三)选择排序
#### 1. 简单选择排序
- 重点：循环找到最大/小索引，再交换至最左/右

#### 2. 堆排序 *

### (四)归并排序
#### 1. 两路归并排序
- 名词解释：
  - sort方法：对所有元素的拆分分配内存空间，进行递归拆分(sort)合并(merge)
  - middle变量：归并的切点，从此将左右进行拆分
  - merge方法：将拆分好的两半数组进行归并(按顺序)
- 重点：
  1. 归并与拆分的所有数组段(即每一次操作)都是要重新申请内存空间
    - 这样归并的操作才会不影响原数组，进而正确的排序
- 思路1：通过下标进行归并排序
  - 传参：0,nums.length-1
  - 分：
    1. 递归不断按照对二分分区，取得分区的下标，即[left,mid,right]
    2. 当left>=right时，即拆分到位单个元素时，不再拆分
  - 并：
    1. 由最小单位的元素不断向上进行合并，自下向上的个数组此时必定相对有序
    2. 不断进行合并，将两个有序的数组合并为一个有序数组
  - System.arraycopy(原数组,原数组起点，目标数组，目标数组起点，复制长度)
- 思路2：通过复制Array比较两个数组比较合并新数组
- 比较：该思路2或许耗费更多的空间：
  - 思路1比较：通过原数组[下标]比较，最后放入新数组。一层需要1个数组
  - 思路2比较：传递两个数组，最后再放入新数组。一层需要3个数组
- 推荐：思路1>思路2

```
左分：[5, 2] [6, 4]
左并：[6, 5, 4, 2]

右分：[9, 1] [3]
右并：[9, 3, 1]

最终分：[6, 5, 4, 2] [9, 3, 1]
最终并：[9, 6, 5, 4, 3, 2, 1]
```


#### 2. 多路归并排序 *

## 二、非基于比较排序
#### 1. 桶排序
#### 2. 计数排序
#### 3. 基数排序

![image](http://note.youdao.com/yws/res/34148/4654C3B114D242A1890861DCAAA11728)

## 三、排序算法稳定性汇总
- 判断稳定性依据：排序过程中，相等元素的相对前后顺序有没有发生改变
  - 有改变：不稳定
  - 无改变：稳定
- 稳定性的好处：从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。这样，有可能减轻系统的开销。
  - 即前一排序操作过程中相等元素的相对位置不变，使得下一次排序操作也无需交换该相等元素位置，从而节省系统开销
- 稳定性的意义

```
1、如果只是简单的进行数字的排序，那么稳定性将毫无意义。
2、如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义（所谓的交换操作的开销已经算在算法的开销内了，如果嫌弃这种开销，不如换算法好了？）
3、如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。
4、除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。（当然，如果需求不需要保持初始的排序意义，那么使用稳定性算法依旧将毫无意义）。
```
- 判断算法：
  - 冒泡排序：稳定，冒泡过程中，相等元素不需要交换
  - 选择排序：不稳定，选择最小/最大元素的位置交换，可能会导致相等元素相对前后顺序发生改变
    - 如5,8,5,2,9，第一遍选择第1个5和2交换，会导致两个5的相对前后顺序发生改变
  - 插入排序：稳定，插入过程中，相等元素可以不需要改变相对前后顺序
  - 快速排序：不稳定，在中枢元素和a[j]交换时，会把前面元素的稳定性打乱
  - 归并排序：稳定，合并过程中不改变相等元素相对前后顺序发生改变
  - 堆排序：不稳定，插入元素过程中，会不断的上浮元素，上浮的过程中会改变相等元素前后相对顺序