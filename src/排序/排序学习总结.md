## 排序
将无序的数据进行排序，通常应用于数组数据结构。

## 一、基于比较排序
### (一)交换排序
#### 1. 冒泡排序 *
- 重点：循环不断交换，将最小/大交换至最左/右

#### 2. 快速排序 *
- 名词解释：
  - pivotIndex变量：切分左右分区(一半大一半小)的切点
    - 切点即为该元素位于有序数组中所在位置
  - partition方法：对数组进行左右分区，返回切点pivotIndex
  - quickSort方法：对数组进行递归，不断的递归分区
    - 范围是除了切点partition
  - 快排算法：不断按照切点pivot(可随机)进行分区，分区完成切点pivot即为正确位置(排序完成的位置)，之后分治对左右分区再分，直到小于2个元素，也说明确定了所有元素的pivot，即排序完成
- 重点：
  1. 递归的出口为：left<right
    - 即至少两个元素。才有必要进行分区和排序
- 优化：
  - pivot可以选择中间数，避免有序而导致O(n^2)
    - partition方法增加swap(nums, left, (left + right) >> 1);

### (二)插入排序
#### 1. 简单插入排序
#### 2. 希尔排序

### (三)选择排序
#### 1. 简单选择排序
- 重点：循环找到最大/小索引，再交换至最左/右

#### 2. 堆排序 *
- 名词解释：
  - sort方法：对所有元素的拆分分配内存空间，进行递归拆分(sort)合并(merge)
  - middle变量：归并的切点，从此将左右进行拆分
  - merge方法：将拆分好的两半数组进行归并(按顺序)
- 重点：
  1. 归并与拆分的所有数组段(即每一次操作)都是要重新申请内存空间
    - 这样归并的操作才会不影响原数组，进而正确的排序

### (四)归并排序
#### 1. 两路归并排序
- 思路：
  - 分：
    1. 递归不断按照对二分分区，取得分区的下标，即[left,mid,right]
    2. 当left>=right时，即拆分到位单个元素时，不再拆分
  - 并：
    1. 由最小单位的元素不断向上进行合并，自下向上的个数组此时必定相对有序
    2. 不断进行合并，将两个有序的数组合并为一个有序数组
- System.arraycopy(原数组,原数组起点，目标数组，目标数组起点，复制长度)

```
左分：[5, 2] [6, 4]
左并：[6, 5, 4, 2]

右分：[9, 1] [3]
右并：[9, 3, 1]

最终分：[6, 5, 4, 2] [9, 3, 1]
最终并：[9, 6, 5, 4, 3, 2, 1]
```


#### 2. 多路归并排序 *

## 二、非基于比较排序
#### 1. 桶排序
#### 2. 计数排序
#### 3. 基数排序

![image](http://note.youdao.com/yws/res/34148/4654C3B114D242A1890861DCAAA11728)