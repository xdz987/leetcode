## 一、概念补充
#### 1. 元组：一组复合值
- 例题q347
- 使用元组的方式，默认将元组第一个值当做键来比较。如果第一个相同，继续比较第二个。

##### 比如下面的 (4,5,6) 和 (4,2,8)，由于第一个值相同，因此继续比较后一个，又由于 5 比 2 大，因此 (4,2,8)先出堆。
```
h = [(1,2,3), (4,5,6), (2,1,3),(4,2,8)]
heapq.heappify(h) # 堆化（小顶堆）

heapq.heappop() # 弹出 (1,2,3)
heapq.heappop() # 弹出 (2,1,3)
heapq.heappop() # 弹出 (4,2,8)
heapq.heappop() # 弹出 (4,5,6)
```
![image](https://note.youdao.com/src/D58D1B401D91462A91CE259E09CA1DDB)

#### 元组应用
1. 携带一些额外的信息

```
比如我想求二维矩阵中第k小数，当然是以值作为键。但是处理过程又需要用到其行和列信息，那么使用元组就很合适，比如 (val, row, col)这样的形式。
```
2. 想根据两个键进行排序，一个主键一个副键。

```
2.1 一种是两个都是同样的顺序，比如都是顺序或者都是逆序。
2.2 另一种是两个不同顺序排序，即一个是逆序一个是顺序。
```

#### 2. 模拟大顶堆
- 即将原有的数全部取相反数，比如原数字是 5，就将 -5 入堆。经过这样的处理，小顶堆就可以当成大顶堆用了。

![image](http://note.youdao.com/yws/res/39665/53AEB84D0BD94B77A1CE9197966CEE32)

## 二、三个技巧
### 技巧一：固定堆
- 例题剑40、q215、q347

#### 应用：优化TopK问题：
- 原始：先将所有元素入大顶堆，最后出堆K-1个，之后堆顶即为第TopK
- 优化-固定堆：先将K个元素入小顶堆，之后入堆出堆同时进行，保持堆大小为k，所有元素入堆后堆顶即为TopK
- 优化前：O(NlogN)
- 优化后：O(NlogK)

#### 优化前后比较
```
例如：10个元素求第3Top

原始堆：入堆10次+出堆2次。同时堆的元素越多，入/出堆将花费更多操作。

优化-固定堆：入堆10次+出堆7次
优化点在于堆的数量始终为k-~k+1个元素，所有出/入堆花费更少操作数
```

![image](http://note.youdao.com/yws/res/39700/13540F7527B44956B908DACEFF68DCC1)

### 技巧二：双堆
#### 功能：动态获取中位数
- 前置：不等式的传递性
  - 当A<B时，判断C是否为最大则C比较B，判断C是否为最小则C比较A
    - 用于平衡性操作
- 思想：大顶堆存放【小元素】，小顶堆存放【大元素】，此时大顶堆的堆顶与小顶堆的堆顶刚好为中位数。
  1. 当元素为偶数数量时，两堆顶/2即为中间数
  2. 当元素为奇位数量时，选一个堆顶作为中间数存放（此题解选大顶堆）
- 重点：
  1. 性质：大顶堆的堆顶【小于等于】小顶堆的堆顶
  2. 平衡性：双栈元素数量之差最多为1