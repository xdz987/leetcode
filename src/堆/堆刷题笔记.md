## 一、固定堆
### 数组中的第k个最大元素 q215
#### 方法一：固定堆
- ==重点：求第k个最大元素则用小顶堆，求第k个最小元素则用大顶堆==
- ==题解：==
  1. ==初始化固定堆，堆大小为K+1==
    - 如果是堆的大小是1，那么pop后就是0，堆的大小是2，pop后就是1，无法比较大/小，出现断层
  2. ==所有元素push，push失败即堆满，则pop再push==
  3. ==如果堆元素数量为k+1个，则pop一个==
  4. ==返回堆顶元素即为TopK==

#### 方法二：随机快排
- 略

### 最小的k个数 剑40
#### 方法一：固定堆
- ==题解：【同q215】求最小的k个数则使用大顶堆，最后的堆中数字即为结果==

#### 方法二：随机快排-剪枝
- ==题解：==
  - ==快排-剪枝：快排在找到某分区位置后，判断该位置是否大于K==
    1. 是则对左区进行partition操作
    2. 否则对右区进行partition操作
  - ==目的：找到大于K的下标后，右边的元素均大于左边元素，且不属于k的范围，右边直接剪枝==
  - 题解：
    1. 随机快排-剪枝
    2. 返回copyOfRange(0,k)

### 前K个高频元素 q347
#### 方式一：手写固定堆+元组
- ==题解：==
  1. ==先计算元素频率，使用HashMap实现==
  2. ==将HashMap转换为int[2]即元组的形式==
  3. ==创建大顶堆，以元素频率作为交换依据==
- 方案：
  1. 先统计每个数字频率
  2. 在以元组[频率，数字]的方式构建固定小丁堆
  3. 其他步骤同【剑40】

#### 方式二：优先队列+元组
- ==题解：【同方式一】==

## 二、双堆
### 数据流中的中位数 剑41
#### 方法一：双堆
- ==思想：通过双堆将数据分为两半，大顶堆存放小的数据，小顶堆存放大的数据。==
  - ==偶数时，实现两个堆顶元素即为中位数==
  - ==奇数时，大顶堆的堆顶即为中位数==
- 题解：
  1. 初始化minHeap和maxHeap
  2. 当平衡时，使得maxHeap的元素数量多1个。
    - 实现：
    - 将元素放进minHeap取得大元素中的最小，再将此最小元素放入maxHeap
  3. 当不平衡时(maxHeap>minHeap)，使得minHeap数量+1
    - 实现：
    - 将元素放进maxHeap取得小元素中的最大，再讲次最大元素放入minHeap
  4. 当maxHeap数量>minHeap时，返回maxHeap.peek，否则返回两堆peek/2
- ==优化-捷径赋值：==
  - ==要往maxHeap添加元素num时，当num比minHeap的最小元素还小==：
    - ==是，直接添加进max队列==
    - 否，先进minHeap再poll回maxHeap
  - ==要往minHeap添加元素num，当num比maxHeap的最大元素还大：==
    - ==是，直接添加进min队列==
    - 否，先进maxHeap再poll回minHeap
- 方案：
  - push：
    1. 双栈元素数量不等，说明相差>1，调整平衡性。向smallHeap添加元素达到平衡
      1. 大堆顶>num，不符合性质，对调位置
      2. 否则直接push达到平衡性
    2. 双栈元素相等，完全平衡(平衡性为0)时
      1. 小顶堆>num
        1. 符合性质，直接push达到平衡性
        2. 不符合性质，对调位置
  - find：偶数数量两堆顶/2，奇数则大顶堆

## 三、带权最短路径

## 四、因子分解

## 五、堆排序
- 略