## 一、贪心算法基本思想
- 贪心：贪⼼的本质是选择每⼀阶段的局部最优，从⽽达到全局最优。
- 什么时候用贪心：手动模拟感受一下局部最优推出整体最优，举反例，想不到反例则可一试
   - 如一堆钞票拿10张，要求拿最大金额：每次都拿最大的一张钞票，十次之后即为最大金额
- 解题步骤：
   1. 将问题分解为若⼲个⼦问题
   2. 找出适合的贪⼼策略
   3. 求解每⼀个⼦问题的最优解
   4. 将局部最优解堆叠成全局最优解

### 贪心与DP的区别
#### 第一次理解
- 贪心：
   1. 做出的每步贪心决策都无法改变，且当前的局部最优解是由上一步的局部最优解推导出的，【上一步之前的最优解则不作保留】，【由此贪心得出的不一定是最优解】
   2. 如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可（通常这个“最优”都是基于当前情况下显而易见的“最优”）；这样的话，就不需要知道一个节点的所有子树情况，于是构不成一棵完整的树；
- DP：
   1. 做出的每步子问题最优解，而最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，【因此记录之前的所有最优解】
   2. 动态规划则自底向上，从叶子向根，构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值，得到答案
- 例子：1元3元4元找零钱最小张数
   - 贪心：4+1+1=6，3张
   - DP：3+3=6，2张
   - DP得出才是最优解
- 总结：
   1. 都是子问题最优性
   2. 贪心是DP的一个特例
   3. 贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。

## 二、应用
### (一)传递法
#### 分发糖果、最大子序和
#### 柠檬水找零
- 局部最优：遇到账单20，优先消耗美元10，完成本次找零
- 方案：遍历bills，使用int存储5元和10元，if else

### (二)取差值法
#### 摆动序列
#### 方法一：贪心 取差值法
- 局部最优：每次都为当前连续数字的最长子序列，即跳过非峰值数字
- 重点：
   1. 左侧持续相等的情况，则preDiff始终为0
   2. 右侧持续相等的情况，则直接跳过该数字
   3. 由于比较的是两个数字，所以res总数量初始值为1
- 方案：
   1. 从1开始遍历nums数组
   2. curDiff动态保存i与i-1的差值
   3. 当preDiff<=0&&curDiff>0时或者preDiff>=0&&curDiff<0时说明存在峰值
      1. res++
      2. 更新preDiff

#### 最大子序和 q53
#### 方法一：贪心 取差值+传递
- 最优局部："连续和"为负数时，重新定位起点
- 重点：
   1. 当为负数时，遇到任何正数都将拉低子序列最大值，设sum=0，重新计算
      - 而如果nums全为负数，res会保存最大的负数

#### 加油站 q134
#### 方法一：贪心 取差值法
- 局部最优：当前累加rest[j]的和curSum⼀旦⼩于0，起始位置⾄少要是j+1，因为从x~j开始⼀定不满足一圈
- 重点：
   1. surplus[i]=gas[i]-cost[i]<0作为起点必定到不了gas[i+1]
   2. 累加curSum+=surplus，当curSum不足以消费gas[i]-cost[i]时，前x~i必定不能作为起点
   3. gas的总和<cost的总和，必定达不到一圈
- 方案：
   1. 初始化起点start、curSum、totalSum
   2. 遍历gas/cost，curSum、totalSum累加gas[i]-cost[i]，当curSum<0，重置start=i+1，curSum=0
   3. 当totalSum<0，说明gas不足以扣除costreturn-1
   4. 否则返回start

### (三)枚举排除法
#### 分发饼干 q455
#### 方法一：贪心 枚举排除法
- 局部最优：最小尺寸饼干给最小胃口孩子，或反之
- 重点：先排序，然后大饼干满足大胃口，小饼干满足小胃口，无法满足胃口的饼干忽略

#### 买卖股票的最佳时机2 q122
#### 方法一：贪心 枚举排除法
- 最优局部：收集每天的正利润
- 重点：利润分解为每天为单位的维度，⽽不是从0天到第N天整体去考虑
- 方案：累加所有正利润

### (四)拆分法
#### k次取反后的最大值 q1005
#### 方法一：暴力
- 方案：while循环k次，每次选最小值取反

#### 方法二：贪心 拆分法
- 局部最优：
   1. 存在负数时，k次将绝对值最大的负数转为正数，如还存在k值，则继续2.
   2. 均为正数时，k%2为0则保持不变，k%2=1则将最小绝对值转为负数
- 方案：
   1. 将数据按绝对值从大到小排序
   2. 循环数据由绝大值大到小，将绝对值大的负数转换为正数
   3. 如k>0，则k%2是否为0，是则数据不变，否则最小绝对值取反
   4. 统计数据总和，返回

#### 分发糖果 q135
#### 方法一：贪心 拆分+传递
- 局部最优：
   1. 只要右边评分⽐左边⼤，右边的孩⼦就多⼀个糖果
   2. 只要左边评分⽐右边⼤，左边的孩⼦就多⼀个糖果
- 方案：
   1. 初始化candy数组。先填充为1。提前处理了评分相等、分数小的一方的的candy
   2. 第一次确定从左到右中，右边评分高的candy数量
      - r[i]>r[i-1]，则candy[i]=candy[i-1]+1;
   3. 第二次确定从右到左中，左边评分高的candy数量
      - r[i]>r[i+1]，则candy[i]=max(candy[i],candy[i+1]+1)
      - 取max是因为第一次从左到右存在已经递增保存了candy
   4. 统计candy数组，返回

### (五)范围覆盖法
#### 跳跃游戏 q55
#### 方法一：贪心 范围覆盖法
- 最优局部：每次取最⼤跳跃步数（取最⼤覆盖范围）
- 方案：
   1. 遍历[0~n-2]个步数，保存能够跳到的最远距离，即max(上一i+nums,i+num[i])
      - 不到最后一个步数是因为倒数第二个能跳到最后一格即可，最后一格是什么数字重要
   2. 如果能够跳到最远距离<=i，说明可能遇到0，跳不动了，直接return false
   3. 否则能够跳到最远距离是否>=n-1

#### 跳跃游戏2 q45
#### 方法一：贪心 范围覆盖法
- 最优局部：在能跳到的范围内选择最大步数的位置
- 重点：设定设定end作为当前步伐范围的终点，动态保存每个步伐能够达到的最远距离
- 方案：
   1. 初始化farthest、jumpCount、stepEnd(当前能够到达的最远距离)
   2. 遍历[0~n-2]个jump，动态保存当前jump能到的最远距离
   3. 判断i是否等于stepEnd，是则jumpCount++，更新stepEnd为当前i能到的最远距离

![image](http://note.youdao.com/yws/res/41260/5C9F79F6725540B9BC07AB5B5B4D4C5D)

### (六)元组/双维度
#### 根据身高重建队列 q406
- 局部最优：优先按身⾼⾼的people的k来插⼊。再按k值顺序插入
- 重点：
   1. 身高和k值得两个维度中，k值是根据身高这一维度按照队列得出的，所以身高应当作为主要考量
   2. 按照身高升序及k值降序后的队列即满足队列属性，最后再重新插入整理即可
- 方案：
   1. 排序，第一序是身高升序，第二序是k指降序
   2. 根据k值插入链表
   3. 将链表转为数组返回

