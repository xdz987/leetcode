 - 二叉树的路径划分
    1. 每个节点的前缀和
        - 即所有个叶节点中，处于左子节点的路径与处于右子节点的路径
            - 排列是从最左叶到最右叶，如为满二叉树，则是左右左右左右的形式
        - 在递归中，每轮递归都保存累计值
    2. 每个叶节点路径
        - 在递归中，判断root.left与root.right为空即为叶节点，则保存累加值
 - 单边子树比另一子树深度更大
    1. 当左右子树中，存在左(右)子树的深度比另一左(右)子树深时：
        1. 右子树的值保持不变，而左子树会一直往下递增
        2. 如左：5,6,7,8，而右:3,5,5,5。右子树到5时已经没有子节点
            - 此时比较左右，则是5>3,6>5,7>5,8>5

#### 1. 如何计算从根节点到每条叶节点的路径总和？
 - 左右子节点拥有相同的父节点.val，也同样是相同父节点及其祖先.val之和
 - 递归理解：当对于递归开始传入0时，即开始分裂：
    1. root传入给Left和Right累加器=0
    2. 假如Left=5,Right=9。
        1. 此时Left累加器的5，又复制分裂作为参数传入给Left.left与Left.right
        2. 此时Right累加器=9，又复制分裂作为参数传入给Right.left和Right.right
    3. 此时一开始的1个累加器，到了第三层时的节点时，已经复制分裂为4个累加器(不包含root及root.left/right的三个累加器)


```
//用于学习：计算每条路径之和
public boolean hasPathSum(TreeNode root, int targetSum) {
    boolean res = pathSum(root, 0, targetSum);
    System.out.println(pathSumList.toString());
    return res;
}

//每条路径之和容器
List<Integer> pathSumList = new ArrayList<>();

public boolean pathSum(TreeNode root, int currentSum, int targetSum) {
    if (root == null) {
        return false;
    }
    //到此说明为叶节点
    if (root.left == null && root.right == null) {
        int pathSum = currentSum+root.val;
        pathSumList.add(pathSum);
//            return pathSum == targetSum;
    }

    //累加每条路径的值，并进行作为形参赋值到Left和Right子树，进行分裂
    currentSum += root.val;
    return pathSum(root.left, currentSum, targetSum) || pathSum(root.right, currentSum, targetSum);
}
```

#### 2. 如何访问每颗子树？
 - 后序遍历

#### 3. 如何访问每个节点？
 - 前序遍历

#### 4. 如何累计树的深度？
 - 每递归左和右节点一次就算一层，即+1

```
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int left = maxDepth(root.left);
    int right = maxDepth(root.right);

    //每递归左和右节点一次就算一层，即+1
    int maxDepth = Math.max(left, right) + 1;
    return maxDepth;
}
```

#### 5. 如何序列化一颗树？
 - 即转换为字符串的形式

```
if (root == null) {
    return "#";
}

String left = serialize(root.left);
String right = serialize(root.right);
String subTree = left + "," + right + "," + root.val;

//保存每一颗序列化的子树(包括整树)
box.put(subTree);
```


#### 6. 如何序列化一颗树的所有子树？
 - 即转换为字符串的形式

```
if (root == null) {
    return "#";
}

String left = serialize(root.left);
String right = serialize(root.right);

//不断覆盖前一序列化的子树，直到最后整棵树
return left + "," + right + "," + root.val;
```

#### 7. 如何不序列化树而判断树是否相等？
 - 使用双层递归(暴力法)
 1. 第一层将所有(需要判断)的节点传入第二层递归
 2. 第二层递归对传入的节点进行条件判断

```
//双层递归
public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null || t == null) {
        return s == null && t == null;
    }
    //判断是否为同一结构的树
    if (isSameTree(s, t)) {
        return true;
    }

    //递归每颗子树(节点)，判断是否相等
    return isSubtree(s.left, t) || isSubtree(s.right, t);
}

private boolean isSameTree(TreeNode ss, TreeNode t) {
    if (ss == null || t == null) {
        return ss == null && t == null;
    }
    //判断节点的值是否相等
    if (ss.val != t.val) {
        return false;
    }

    //递归判断左右所有节点的val是否相等
    return isSameTree(ss.left, t.left) && isSameTree(ss.right, t.right);
}
```
