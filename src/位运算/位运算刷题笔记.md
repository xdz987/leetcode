### (一)综合统计
#### 只出现一次的数字2 q137
#### 方法一：遍历统计
- 重点：==累加所有数字对应比特位的数量，再%3得出的即为出现一次的数字，出现3次的数字刚好为3的整数直接抵消等于0==
- 方案：
  1. int的范围是32位，所以设立长度为32位的数组保存按位为1的累计数量
    - 需要注意的num & 1的方式第一比特位直接获取，所以总共只需要右移31次
  2. 最后每个位置%3，得出的二进制即为出现一次的数字
    - 注意必须跟放进数组的顺序反过来
    - 注意res从0开始，所以需要左移32次

#### 方法二：有限自动状态机
- 方法一的优化版
- 重点：==使用模3自动状态机的【状态转换公式】过滤出现3次的整数，留下的即为出现一次的整数==
- 具体看【有限自动状态机.md】

#### 数组中出现次数超过半的数 剑39q169
#### 方法一：摩尔【最佳】
- O(n) O(1)
- 略

#### 哈希表、排序取中
- 略

#### 方法二：位运算——统计
- 复杂度：O(n^2) O(1)
- ==【同q137的思路】，所有整数的第0~31位的1的数量，如>n/2则保存起来，最后结果即为众数==
- 重点：众数的任意二进制位为1的个数>n/2
- 方案：
  1. 遍历32个二进制位，mask初始化为1，每次循环左移一位
  2. 遍历nums数组，计数当前二进制mask位的所有num为1的数量
  3. 当二进制mask位的1数量>n/2时，说明是众数的二进制位，保存到res

#### 最大单词长度乘积 q318
#### 方法一：位运算——映射
- ==映射思想：==
  1. ==通过0-25二进制位映射a-z，使得word的转换为二进制位形式==
    - 使得1左移(0-25)实现
  2. ==使用int存储这一串二进制，即整数遍历或运算每个位，而最终用来比较重复，所以重复字符不影响最终比较==
  3. ==使用int[]存储每个单词对应的int，下标对应words[]数组==
- O(N^2) O(N)
- 重点：java整数为32位bit位，小写字母26个可以通过映射的方式放入到一个整数中
  - 但是保存某字符的频率，因为bit只有0和1
- 方案：
  1. 初始化int[]bitWords用于存放words的每个字符串word的映射
  2. 遍历每个word：将每个word对应的字符映射到bit上，如z为从右往左数第26位
    1. 初始化存放bit的32位整数容器bitWord
    2. 遍历每个字母，放入bitWord中
    3. 将bitWord放入bitWords数组中
  3. 暴力循环每个word
    1. 外层i从0开始，内存从j从i开始
    2. 不存在相同字母才进行计算，即当bitWords[i]【与】bitWords[j]==0。保存其长度乘积最大值
  4. 返回乘积最大值

#### 两整数之和 q371
- ==利用未运算模拟两数相加==
  - ==相加：a^b==
    - a^=b做保存结果的容器
  - ==进位：(a&b)<<1==
- 重点：a^b为a和b未考虑进位的两数之和，(a&b)<<1就是进位
- 方案：递归a=a^b，b=(a&b)<<1。当b==0时返回a

### (二)异或运算
#### 只出现一次的数字 q136
#### 方法一：异或运算
- ==异或：A^A=0,A^0=A==
- 方案：遍历所有数异或变量0，返回该变量即可

#### 数组中数字出现的次数 剑56_1
- 前置知识：
  1. A^A=0,A^0=A
  2. x&(-x)：保留最右二进制位为1的值，左边的1置0
  3. 异或自反性：即a^c=b<=>b^c=a
- 思想：
  1. ==异或所有的数，这样能找到两个单次出现的数异或值==
  2. ==为了将使用【q136】的操作，把数组分为两边再进行异或，而单次出现的数分布在两边。将【两单次出现的异或值】取得最右边的1设为flag，以该flag作为分割点。==
  3. ==再次遍历数组，当flag&num不为0的则属于【某个单次出现】的数字所属阵营，最后得出【某个单次出现的数字】==
  4. ==再利用异或的自反性之间取得【另一个单词出现的数字】==
- 方案：
  1. 向异或所有数字得到目标数字a ^ b的结果x
  2. 将目标数字x&(-x)，得到仅最右单个二进制位为1的数字flag
  3. 遍历所有数字，只对和flag与运算为不等于0的数字进行异或，得到结果a或b
    - 假如非出现一次的数字被排除，那么也是排除两次该数字，不影响结果
    - 必须是!=0，!=包含了多个情况，如1,2,4,8等。等于0甚至可能排除掉所有数字
      - [1,2,5,2]的x=flag=4，所有数字与运算4都不存在等于0的情况
  4. 利用异或的自反性，x异或a/b等到b/a，返回[a,b]

#### 消失的两个数字 面1719
#### 方法一：位运算——异或
- 注意：==为q136和剑56_1的拼接题==
- 方案：
  1. 初始化x=0，n=num.len
  2. 找到相同那两个数a,b的异或结果，即x异或1~n+2再异或nums数组
  3. 找到最右为1的二进制位，用于拆分数组，即flag = x & -x
  4. 根据x最右为1的二进制数，排除这个二进制位为0的i，这样能够排除掉a或b中的一个，即在i或num与运算flag不为0的前提下，res异或i~n+2再异或nums数组
  5. 返回[res，res^x]

#### 方法二：排序+双指针
- ==遍历1~n+2，当与nums数组对应元素不同时为消失的数字，或者都相同，消失的数为n+1或n+2==
- 重点：
  1. 初始化n、numI指向nums数组
  1. 先将nums降序排序
  2. 遍历1~n+2，不相等则添加到res且numI指针不动，否则numI++，numI等于n，则直接将后续i添加到res并continue

#### 汉明距离 q461
- O(K) O(1)，K为xy异或后1的数量
- ==思想：先取得x,y的异或结果。不断删除右边的'1'，累加删除次数即为汉明就距离==
- 方案：
  1. z=x^y取得异或结果
  2. while循环z不等于0，count累加循环次数，z=z&(z-1)删除最右的1
  3. 返回count

#### 丢失的数字 q268
- ==思想：异或[0,n]再异或nums数组即可找到丢失的数字==
- O(n) O(1)
- 方案：
  1. 初始化disappear的数字为n
  2. 遍历0~n，disappear异或i和nums[i]，重复数会被消除
  3. 返回disappear

#### 数字的补数 q476
- 思想：==先求得数字最高位二进制数的位数+1。补数即为数字^(数字最低到最高位全1再-1)==
  - 例：101，最高位为3
  - 则101^((1<<3+1)-1)
  - 即101^(1000-1)
  - 即101^111=010
- O(k) O(1)其中K为num最最左边1到最右边数量
- 方案：
  1. 计算num最低位到最高位1的距离+1
  2. 返回异或num和与之同样二进制位的全1，即num异或((1 << size) - 1)

### (三)与运算
#### 二进制中1的个数 剑15
#### 2的幂 q231
- ==思想：使用x&(x-1)消除右边的1，累加消除的次数==
- 前置：x&(x-1)，消除二进制下最后出现1的位置，其余保持不变
- 重点：x>0
- 方案：return x>0&&(x&(x-1))==0

#### 比特位计数 q338
#### 方法一：巧用x&(x-1)
- ==思想：每个数字计算x&(x-1)消除1的次数即可==
- 前置：x&(x-1)：消除二进制下最后出现1的位置，其余保持不变
- 重点：遍历i计数为1的比特位，通过x&(x-1)消除为1的比特位

### (四)位移
#### 二进制中1的个数 剑15
#### 方法一：无符号右移
- 复杂度：O(N) O(1)
- 方案：：
  1. while遍历n!=0
  2. res+=n&1最右的二进制数
  3. n>>>1无符号右移1位

#### 方法二：巧用x&(x-1)
- ==思想：计算x&(x-1)消除1的次数即可==
- 复杂度：O(M)/即O(1) O(1)
- 方案：
  1. while遍历n!=0
  2. res++
  3. n=n&(n-1)，消除最右边的1

#### 颠倒二进制位 q190
- ==思想：数字是2~32，所以只需遍历0-31，让最右边的二进制位左移31减i位，再将数字右移继续循环==
- 复杂度：O(logN) O(1)
- 方案：
  1. 遍历所有比特位
  2. n最右比特值左移31-i位
  3. n右移1位

#### 4的幂 q342
- ==思想：int整数型中4的幂只有16种情况，直接遍历0-15。设立tmp为1，每次tmp左位移2位，相等则为4的幂，大于n则一定不为4的幂。循环结束也不为4的幂==
- 复杂度：O(logN) O(1)
- 方案：
  - 当n==1直接true
  1. 遍历0~16，32位比特中，4的幂是16种情况
  2. tmp<<=2，判断n等于tmp与否即是否为4的幂
  3. 当tmp已经超过n了直接返回false

#### 交替位二进制数 q693
#### 方法一：位移
- ==思想：模拟交替位移。即取得最右边的二进制位取反，再遍历32个二进制位且n!=0，不断比较是否为交替==
- O(logN) O(1)
- 方案：
  1. 初始化flag等于最右bit取反
  2. 遍历32位，当n==0说明到最左边bit
    1. 每次取得最右bit
    2. flag==bit相等说明不交替
    3. 否则flag=bit，n>>>=1
  3. 循环结束说明为交替二进制

#### 方法二：与结合异或
- ==思想：先取得n中1的最高位到最低全为1。再+1取得100...的数字，再与运算n为0则说明为交==替
- O(1) O(1)
- 重点：交替二进制数n(异或)n右移一位，为全1
- 方案：
  1. 设m=n&(n>>>1)
  2. 当m&(m+1)为0说明为交替二进制

