### (一)综合统计
#### 只出现一次的数字2 q137
#### 方法一：遍历统计
- 重点：累加所有数字对应比特位的数量，再%3得出的即为出现一次的数字，出现3次的数字刚好为3的整数直接抵消等于0
- 方案：
  1. int的范围是32位，所以设立长度为32位的数组保存按位为1的累计数量
    - 需要注意的时num & 1的方式第一比特位直接获取，所以总共只需要右移31次
  2. 最后每个位置%3，得出的二进制即为出现一次的数字
    - 注意必须跟放进数组的顺序反过来
    - 注意res从0开始，所以需要左移32次

#### 方法二：有限自动状态机
- 方法一的优化版
- 重点：使用模3自动状态机的【状态转换公式】过滤出现3次的整数，留下的即为出现一次的整数
- 具体看【有限自动状态机.md】

#### 数组中出现次数超过半的数 剑39q169
#### 方法一：摩尔【最佳】
- O(n) O(1)

#### 哈希表、排序取中
- 略

#### 方法二：位运算——统计
- 仅做学习
- 重点：众数的任意二进制位为1的个数>n/2
- 方案：
  1. 遍历32个二进制位，mask初始化为1，每次循环左移一位
  2. 遍历nums数组，计数当前二进制mask位的所有num为1的数量
  3. 当二进制mask位的1数量>n/2时，说明是众数的二进制位，保存到res

#### 最大单词长度乘积
#### 方法一：位运算——映射
- O(N^2) O(N)
- 重点：java整数为32位bit位，小写字母26个可以通过映射的方式放入到一个整数中
  - 但是保存某字符的频率，因为bit只有0和1
- 方案：
  1. 初始化int[]bitWords用于存放words的每个字符串word的映射
  2. 遍历每个word：将每个word对应的字符映射到bit上，如z为从右往左数第26位
    1. 初始化存放bit的32位整数容器bitWord
    2. 遍历每个字母，放入bitWord中
    3. 将bitWord放入bitWords数组中
  3. 暴力循环每个word
    1. 外层i从0开始，内存从j从i开始
    2. 不存在相同字母才进行计算，即当bitWords[i]【与】bitWords[j]==0。保存其长度乘积最大值
  4. 返回乘积最大值

#### 两整数之和 q371
- 重点：a^b为a和b未考虑进位的两数之和，(a&b)<<1就是进位
- 方案：递归a=a^b，b=(a&b)<<1。当b==0时返回a

### (二)异或运算
#### 只出现一次的数字 q136
#### 方法一：异或运算
- 前置知识：任何数异或0等于自己，自己异或自己等于0
- 方案：遍历所有数异或变量0，返回该变量即可

#### 数组中数字出现的次数 剑56_1
- 前置知识：
  1. 任何数异或0等于自己，自己异或自己等于0
  2. x&(-x)：保留二进制下最后/右出现的1的位置，其余位置置0（即一个数中最大的2的n次幂的因数
  3. 异或自反性：即a^c=b<=>b^c=a
- 重点：a ^ b = c中c的二进制位1肯定是a的0/1和b的1/0异或CIA得到1
- 方案：
  1. 向异或所有数字得到目标数字a ^ b的结果x
  2. 将目标数字x&(-x)，得到仅最右单个二进制位为1的数字flag
  3. 遍历所有数字，只对和flag与运算为不等于0的数字进行异或，得到结果a或b
    - 假如非出现一次的数字被排除，那么也是排除两次该数字，不影响结果
    - 必须是!=0，!=包含了多个情况，如1,2,4,8等。等于0甚至可能排除掉所有数字
      - [1,2,5,2]的x=flag=4，所有数字与运算4都不存在等于0的情况
  4. 利用异或的自反性，x异或a/b等到b/a，返回[a,b]

#### 消失的两个数字 面1719
#### 方法一：位运算——异或
- 注意：为q136和剑56_1的拼接题
- 方案：
  1. 初始化x=0，n=num.len
  2. 找到相同那两个数a,b的异或结果，即x异或1~n+2再异或nums数组
  3. 找到最右为1的二进制位，用于拆分数组，即flag = x & -x
  4. 根据x最右为1的二进制数，排除这个二进制位为0的i，这样能够排除掉a或b中的一个，即在i或num与运算flag不为0的前提下，res异或i~n+2再异或nums数组
  5. 返回[res，res^x]

#### 方法二：排序+双指针
- 重点：
  1. 初始化n、numI指向nums数组
  1. 先将nums降序排序
  2. 遍历1~n+2，不相等则添加到res且numI指针不动，否则numI++，numI等于n，则直接将后续i添加到res并continue

#### 汉明距离 q461
- O(K) O(1)，K为xy异或后1的数量
- 方案：
  1. z=x^y取得异或结果
  2. while循环z不等于0，count累加循环次数，z=z&(z-1)删除最右的1
  3. 返回count

#### 丢失的数字 q269
- O(n) O(1)
- 方案：
  1. 初始化disappear的数字为n
  2. 遍历0~n，disappear异或i和nums[i]，重复数会被消除
  3. 返回disappear

#### 数字的补数 q476
- O(k) O(1)其中K为num最最左边1到最右边数量
- 方案：
  1. 循环计数num最左边的1到最右的数量
  2. 返回异或num和与之同样二进制位的全1，即num异或((1 << size) - 1)

### (三)与运算
#### 二进制中1的个数 剑15
#### 2的幂 q231
- 前置：x&(x-1)：消除二进制下最后出现1的位置，其余保持不变
- 重点：x>0
- 方案：return x>0&&(x&(x-1))==0

#### 比特位计数 q338
#### 方法一：巧用x&(x-1)
- 前置：x&(x-1)：消除二进制下最后出现1的位置，其余保持不变
- 重点：遍历i计数为1的比特位，通过x&(x-1)消除为1的比特位

### (四)位移
#### 二进制中1的个数 剑15
#### 方法一：无符号右移
- 复杂度：O(N) O(1)
- 方案：：
  1. while遍历n!=0
  2. res+=n&1最右的二进制数
  3. n>>>1无符号右移1位

#### 方法二：巧用x&(x-1)
- 复杂度：O(M)/即O(1) O(1)
- 方案：
  1. while遍历n!=0
  2. res++
  3. n=n&(n-1)，消除最右边的1

#### 颠倒二进制位 q190
- 复杂度：O(logN) O(1)
- 方案：
  1. 遍历所有比特位。PS：当n=0时没必要颠倒，直接break剪枝
  2. res保存：n最右比特值左移31-i位
  3. n右移1位

#### 4的幂 q342
- 复杂度：O(logN) O(1)
- 方案：
  - 当n==1直接true
  1. 遍历0~16，32位比特中，4的幂是16种情况
  2. tmp<<=2，判断n等于tmp与否即是否为4的幂
  3. 当tmp已经超过n了直接返回false

#### 交替位二进制数 q693
#### 方法一：位移
- O(logN) O(1)
- 方案：
  1. 初始化flag等于最右bit取反
  2. 遍历32位，当n==0说明到最左边bit
    1. 每次取得最右bit
    2. flag==bit相等说明不交替
    3. 否则flag=bit，n>>>=1
  3. 循环结束说明为交替二进制

#### 方法二：与结合异或
- O(1) O(1)
- 重点：交替二进制数n(异或)n右移一位，为全1
- 方案：
  1. 设m=n&(n>>>1)
  2. 当m&(m+1)为0说明为交替二进制

