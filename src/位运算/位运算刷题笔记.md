### (一)综合统计
#### 只出现一次的数字2 q137
#### 方法一：遍历统计
- 重点：累加所有数字对应比特位的数量，再%3得出的即为出现一次的数字，出现3次的数字刚好为3的整数直接抵消等于0
- 方案：
  1. int的范围是32位，所以设立长度为32位的数组保存按位为1的累计数量
    - 需要注意的时num & 1的方式第一比特位直接获取，所以总共只需要右移31次
  2. 最后每个位置%3，得出的二进制即为出现一次的数字
    - 注意必须跟放进数组的顺序反过来
    - 注意res从0开始，所以需要左移32次

#### 方法二：有限自动状态机
- 方法一的优化版
- 重点：使用模3自动状态机的【状态转换公式】过滤出现3次的整数，留下的即为出现一次的整数
- 具体看【有限自动状态机.md】

#### 数组中出现次数超过半的数 剑39q169
#### 方法一：摩尔【最佳】
- O(n) O(1)

#### 哈希表、排序取中
- 略

#### 方法二：位运算——统计
- 仅做学习
- 重点：众数的任意二进制位为1的个数>n/2
- 方案：
  1. 遍历32个二进制位，mask初始化为1，每次循环左移一位
  2. 遍历nums数组，计数当前二进制mask位的所有num为1的数量
  3. 当二进制mask位的1数量>n/2时，说明是众数的二进制位，保存到res

### (二)异或运算
#### 只出现一次的数字 q136
#### 方法一：异或运算
- 前置知识：任何数异或0等于自己，自己异或自己等于0
- 方案：遍历所有数异或变量0，返回该变量即可

#### 数组中数字出现的次数 剑56_1
- 前置知识：
  1. 任何数异或0等于自己，自己异或自己等于0
  2. x&(-x)：保留二进制下最后/右出现的1的位置，其余位置置0（即一个数中最大的2的n次幂的因数
  3. 异或自反性：即a^c=b<=>b^c=a
- 重点：a ^ b = c中c的二进制位1肯定是a的0/1和b的1/0异或CIA得到1
- 方案：
  1. 向异或所有数字得到目标数字a ^ b的结果x
  2. 将目标数字x&(-x)，得到仅最右单个二进制位为1的数字flag
  3. 遍历所有数字，只对和flag与运算为不等于0的数字进行异或，得到结果a或b
    - 假如非出现一次的数字被排除，那么也是排除两次该数字，不影响结果
    - 必须是!=0，!=包含了多个情况，如1,2,4,8等。等于0甚至可能排除掉所有数字
      - [1,2,5,2]的x=flag=4，所有数字与运算4都不存在等于0的情况
  4. 利用异或的自反性，x异或a/b等到b/a，返回[a,b]

#### 消失的两个数字 面1719
#### 方法一：位运算——异或
- 注意：为q136和剑56_1的拼接题
- 方案：
  1. 初始化x=0，n=num.len
  2. 找到相同那两个数a,b的异或结果，即x异或1~n+2再异或nums数组
  3. 找到最右为1的二进制位，用于拆分数组，即flag = x & -x
  4. 根据x最右为1的二进制数，排除这个二进制位为0的i，这样能够排除掉a或b中的一个，即在i或num与运算flag不为0的前提下，res异或i~n+2再异或nums数组
  5. 返回[res，res^x]

#### 方法二：排序+双指针
- 重点：
  1. 初始化n、numI指向nums数组
  1. 先将nums降序排序
  2. 遍历1~n+2，不相等则添加到res且numI指针不动，否则numI++，numI等于n，则直接将后续i添加到res并continue

### (三)与运算
#### 二进制中1的个数 剑15
#### 2的幂 q231
- 前置：x&(x-1)：消除二进制下最后出现1的位置，其余保持不变
- 重点：x>0
- 方案：return x>0&&(x&(x-1))==0

### (四)位移
#### 二进制中1的个数 剑15
#### 方法一：无符号右移
- 复杂度：O(N) O(1)
- 方案：：
  1. while遍历n!=0
  2. res+=n&1最右的二进制数
  3. n>>>1无符号右移1位

#### 方法二：巧用x&(x-1)
- 复杂度：O(M) O(1)
- 1. while遍历n!=0
- 2. res++
- 3. n=n&(n-1)，消除最右边的1

