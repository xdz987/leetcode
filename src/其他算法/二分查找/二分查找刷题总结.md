## 二分查找刷题总结
### (一)基本二分查找
#### X的平方根 q69
- ==思路，使用二分查找会出现的情况：==
   1. ==找到目标平方根，直接返回==
   2. ==平方根是存在小数，为目标值+1==
- ==题解：==
   - ==注意事项：mid*mid可能越界，序用long类型==
   1. ==平方根最大的情况是x/2，所以初始化right为x/2==
   2. 二分查找
      1. ==mid*mid为目标值直接返回==
      2. mid*mid>x，right=mid-1
      3. mid*mid<x，left=mid+1
   3. ==到此说明平方根存在小数，返回left-1即可==

#### 寻找峰值 q162
- ==思路：峰值意味着其左边必定递增右边必定递减。所以mid的必定处于以下两种情况：==
   - m==id处于递减，即n[mid]>n[mid+1]，令right = mid==
   - ==mid处于递增或相等，即n[mid]<=n[mid+1]，令left = mid-1==
- 题解：由思路可知
   1. 初始化左右指针[0,len-1]
   2. ==二分查找left<right==
      1. n[mid]>n[mid+1]时，则说明峰值在mid这边即左边，则right=mid
      2. 否则，则说明峰值在mid+1这边即右边，则left=mid+1
   3. 返回left

#### 搜索二维矩阵 q74
- ==前置：一维隐射二维==
   - x=index/行
   - y=index-(x*行)
- ==题解：一维二分查找，将下标隐射到二维==

#### 寻找重复数 q287
#### 方法一：二分查找+计数 28ms
- ==复杂度：O(NlogN) O(1)==
- ==抽屉思想：10个苹果放进9个抽屉，怎么放都至少有一个抽屉立马放至少2个苹果==
- ==思路：隐式的二分查找==
   - ==给定的数组只是用来查找小于x的数字的数量。==
   - ==实际的二分查找是从[1,n]的进行查找，判定是左右分区的依据则是根据小于等于x的数量来看==
      - ==小于x的数量>x，说明在左区间[1,x]，使得right=x==
      - ==小于x的数量<=x，说明在区间[x,n]，使得left=x+1==
- 题解：
   1. 二分查找
   2. 遍历数组，查找小于等于mid的数量为count
      1. count>x，说明在左区间，right=mid
      2. 否则，说明再右区间，left=mid+1

#### 方法二：标记法 2ms
- 复杂度：O(N) O(N)
- 题解：
   1. 初始化数组mark[n+1]
   2. 遍历nums数组
      1. ==如果mark[num]为1说明已经访问过，直接返回num==
      1. ==否则mark[num]访问过的设为1==

#### 方法三：原地交换排序法 7ms
- 复杂度：O(nlogn)/猜测 O(1)
- ==思路：利用nums元素处于[1,n]的特性，对nums进行交换排序==
- ==思路实现/题解：==
   - ==注意点：下标=位置-1==
   1. 遍历[1,n]
   2. ==当元素位置/元素下标+1与元素值不匹配时==
      1. ==判断元素值是否等于以元素值为下标的值相等，是则说明为重复元素，直接返回元素值==
      2. ==while交换：以元素值-1作为下标与当前元素位置进行交换，直到有序为止==

#### 方法四：快慢指针 5ms
- ==思想：与原地交换排序操作类似。存在相同的元素值，意味着以值为下标的进行串联最终会存在一个环。环的起点即为重复值==
- 题解：
   1. 设立起点fast=slow=nums[0]
   2. 快慢指针
      - slow=nums[slow]
      - fast=nums[nums[fast]
   3. ==当slow等于fast，说明到达环的相遇点==
   4. ==设slow为起点即nums[0]，快慢指针同时跑==
   5. ==当slow等于fast时，即为环的起点，即重复元素==

#### 性能：标记法>快慢指针>原地交换排序>计数+二分查找

#### 搜索旋转排序数组 q33
- ==思路：nums[0]为左段的最小值，nums[n-1]为右段的最大值。通过这两个值对数组进行分割比较，确定target位于那一段。==
- ==题解：==
   1. 当n[mid]=target，直接返回mid
   2. ==当n[mid]>=n[0]，说明mid位于左段。==
      1. ==判断target>=nums[0]且target<=nums[mid]，说明target也位于左段。则right=mid-1==
      2. ==否则位于右段，则left=mid+1==
   3. 当n[mid]<n[0]，说明mid位于右段。
      1. 判断target>nums[mid]且target<=nums[n-1]，说明位于右段，则left=mid+1
      2. 否则位于左段，right=mid-1

##### 每轮循环mid只会存在以下两种状态，要么位于高段要么位于低段
![image](http://note.youdao.com/yws/res/31720/D36369A5D9BF43F9A16E04BFA64A6440)

#### 搜索旋转数组2 q81
- ==思路：当左半部分的第前N个元素与右半部分的后N个元素重复时，无法判断边界。采用直接去重的方式==
- ==题解：==
   1. ==在【q33】基础上，循环判断mid属于哪个区间前，先判断nums[left]==nums[mid]，相等则left++==
      - 达到去重的效果

### (二)边界二分查找
#### 爱吃香蕉的珂珂 q875
- ==题解：二分查找为[1,maxPile]之间找到最小值==
   1. ==设定左右指针[1,maxPile]==
   2. ==当mid可以完成吃蕉时，在左分查找即right=mid==
   3. ==当mid不可以完成吃蕉时，再右分查找即left=mid+1==
   4. ==返回left即为最小的情况==

#### q1011 左侧边界二分查找
- 重点：边界，D最大为1，且船最低要载最大的货物，即边界max~total
- 方案：
   - 左侧边界二分查找：
      1. 对船的最低到最高运载能力进行二分查找
      2. 判定条件为在D日内以某承载量将所有货物运载完成
      3. 力求最低运载能力，所以是左侧边界二分查找

#### q34 左/右侧边界二分查找 (前后执行)
- 重点：是否存在target，才进行第二次二分查找
- 方案：
   - 左/右侧边界二分查找:
   1. 左侧边界二分查找到最左边重复值索引 边界[0,length]
   2. 判断left==length或num[left]!=target，说明没有查到target,则直接return [-1,-1]
   3. 右侧边界二分查找到最右边重复值索引 边界[最左侧重复值索引,length]

#### q153 旋转数组 左侧边界二分查找 两种边界(并行执行)
- 重点：
   1. 数组的第一位元素大于右边段的所有元素，位于左边段的元素可直接跳过，因为肯定不是min值
   2. 要查找的min值即处在旋转数组的中心点上，可在右段中判断mid是否小于mid-1，是则mid为最小值，而mid-1为最大值
- 方案：
   - 左侧边界二分查找 两种边界：
   1. 判断mid值是否小于第一个元素。
   2. 是则mid在右侧，判断mid是否小于mid-1，是则说明为旋转数组中心点，否则压缩右侧边界。
   2. 否则直接压缩左侧边界，即left=mid+1，因为是要找最小值

#### q154 旋转数组 左侧边界二分查找
- q153的延续，允许重复元素，影响：
   1. 第一个元素由**大于变成大于等于**右边段所有元素
   2. 旋转数组的中心点的性质，由mid**小于变成小于等于**mid-1则mid为最小值
- 重点：以nums[right]为基准，逐渐向旋转数组中心靠拢
- 方案：
   - 左侧边界二分查找：
   1. 以nums[right]元素为基准，大于该元素说明为左段直接左侧边界，小于则压缩右侧边界进行调整，等于则向左一个个调整

#### q378 矩阵左侧边界二分查找
- 重点：(1)有序矩阵可存在重复数(2)注意是位置值还是元素值
   - 注意是查第k位置的数字，而不是查数字k
- 方案：利用有序矩阵的性质：行列升序
   1. left为左上，right为右下，取mid
   2. 从左下到右上与中间数比较，调整横纵坐标，始终定位到mid位于列的位置，而该位置的上方则都是小mid数(累加数字作为确定k位置的依据)
   3. 累加数量小于k，说明在左上，反之在右下
   4. 最后left即为第k位置的数字

##### 如图，从左下到右上(行升序)，实际为查找mid位于列的位置(列升序)
![image](https://note.youdao.com/yws/res/30761/AC888FC0BB3340859EAB16C42FA1ECE4)

#### 剑53 左侧边界二分查找
- 方案
   1. 先使用左侧二分找到等于target的最左侧值下标
   2. 再从该下标向右遍历等于target的值，res++，直到不相等直接break

#### 剑53.2 二分查找
- 方案：
   1. nums[mid]==mid则表示不存在数在右边，left=mid+1
   2. 反之则right=mid-1;
