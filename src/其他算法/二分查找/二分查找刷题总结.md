## 二分查找刷题总结
### (一)基本二分查找
#### X的平方根 q69
- ==思路，使用二分查找会出现的情况：==
    1. ==找到目标平方根，直接返回==
    2. ==平方根是存在小数，为目标值+1==
- ==题解：==
    - ==注意事项：mid*mid可能越界，序用long类型==
    1. ==平方根最大的情况是x/2，所以初始化right为x/2==
    2. 二分查找
        1. ==mid*mid为目标值直接返回==
        2. mid*mid>x，right=mid-1
        3. mid*mid<x，left=mid+1
    3. ==到此说明平方根存在小数，返回left-1即可==

#### 寻找峰值 q162
- ==思路：峰值意味着其左边必定递增右边必定递减。所以mid的必定处于以下两种情况：==
    - m==id处于递减，即n[mid]>n[mid+1]，令right = mid==
    - ==mid处于递增或相等，即n[mid]<=n[mid+1]，令left = mid-1==
- 题解：由思路可知
    1. 初始化左右指针[0,len-1]
    2. ==二分查找left<right==
        1. n[mid]>n[mid+1]时，则说明峰值在mid这边即左边，则right=mid
        2. 否则，则说明峰值在mid+1这边即右边，则left=mid+1
    3. 返回left

#### 搜索二维矩阵 q74
- ==前置：一维隐射二维==
    - x=index/行
    - y=index-(x*行)
- ==题解：一维二分查找，将下标隐射到二维==

#### 寻找重复数 q287
#### 方法一：二分查找+计数 28ms
- ==复杂度：O(NlogN) O(1)==
- ==抽屉思想：10个苹果放进9个抽屉，怎么放都至少有一个抽屉立马放至少2个苹果==
- ==思路：隐式的二分查找==
    - ==给定的数组只是用来查找小于x的数字的数量。==
    - ==实际的二分查找是从[1,n]的进行查找，判定是左右分区的依据则是根据小于等于x的数量来看==
        - ==小于x的数量>x，说明在左区间[1,x]，使得right=x==
        - ==小于x的数量<=x，说明在区间[x,n]，使得left=x+1==
- 题解：
    1. 二分查找
    2. 遍历数组，查找小于等于mid的数量为count
        1. count>x，说明在左区间，right=mid
        2. 否则，说明再右区间，left=mid+1

#### 方法二：标记法 2ms
- 复杂度：O(N) O(N)
- 题解：
    1. 初始化数组mark[n+1]
    2. 遍历nums数组
        1. ==如果mark[num]为1说明已经访问过，直接返回num==
        1. ==否则mark[num]访问过的设为1==

#### 方法三：原地交换排序法 7ms
- 复杂度：O(nlogn)/猜测 O(1)
- ==思路：利用nums元素处于[1,n]的特性，对nums进行交换排序==
- ==思路实现/题解：==
    - ==注意点：下标=位置-1==
    1. 遍历[1,n]
    2. ==当元素位置/元素下标+1与元素值不匹配时==
        1. ==判断元素值是否等于以元素值为下标的值相等，是则说明为重复元素，直接返回元素值==
        2. ==while交换：以元素值-1作为下标与当前元素位置进行交换，直到有序为止==

#### 方法四：快慢指针 5ms
- ==思想：与原地交换排序操作类似。存在相同的元素值，意味着以值为下标的进行串联最终会存在一个环。环的起点即为重复值==
- 题解：
    1. 设立起点fast=slow=nums[0]
    2. 快慢指针
        - slow=nums[slow]
        - fast=nums[nums[fast]
    3. ==当slow等于fast，说明到达环的相遇点==
    4. ==设slow为起点即nums[0]，快慢指针同时跑==
    5. ==当slow等于fast时，即为环的起点，即重复元素==

#### 性能：标记法>快慢指针>原地交换排序>计数+二分查找

#### 搜索旋转排序数组 q33
- ==思路：nums[0]为左段的最小值，nums[n-1]为右段的最大值。通过这两个值对数组进行分割比较，确定target位于那一段。==
- ==题解：==
    1. 当n[mid]=target，直接返回mid
    2. ==当n[mid]>=n[0]，说明mid位于左段。==
        1. ==判断target>=nums[0]且target<=nums[mid]，说明target也位于左段。则right=mid-1==
        2. ==否则位于右段，则left=mid+1==
    3. 当n[mid]<n[0]，说明mid位于右段。
        1. 判断target>nums[mid]且target<=nums[n-1]，说明位于右段，则left=mid+1
        2. 否则位于左段，right=mid-1
    4. 都不存在，返回-1

##### 每轮循环mid只会存在以下两种状态，要么位于高段要么位于低段
![image](http://note.youdao.com/yws/res/31720/D36369A5D9BF43F9A16E04BFA64A6440)

#### 搜索旋转数组2 q81
- ==思路：当左半部分的第前N个元素与右半部分的后N个元素重复时，无法判断边界。采用直接去重的方式==
- ==题解：==
    1. ==在【q33】基础上，循环判断mid属于哪个区间前，先判断nums[left]==nums[mid]，相等则left++==
        - 达到去重的效果
    2. ==在【q33】的基础上，将nums[0]改为left，将nums[n-1]改为right==

### (二)边界二分查找
#### 爱吃香蕉的珂珂 q875
- ==题解：左侧二分查找为[1,maxPile]之间找到最小值==
    1. ==设定左右指针[1,maxPile]==
    2. ==当mid可以完成吃蕉时，在左分查找即right=mid==
    3. ==当mid不可以完成吃蕉时，再右分查找即left=mid+1==
    4. ==返回left即为最小的情况==

#### 在 D 天内送达包裹的能力 q1011
- ==题解：左侧二分查找最小值==
    - ==先确定船的最大运载重量（只要范围涵盖了最小送达重量即可）：==
        - 最小：1
        - ==最大：最大货物重量*（包裹数/限制天数 向上取整）==
    1. ==左侧边界二分查找==
    2. ==不断尝试mid是否能够canFinsh==
        - ==是，设right=mid（这样使得不断向左侧边界靠近）==
        - ==否，设left=mid+1==
        - ==这里可以剪枝，即mid必须大于等于最大包裹重量==
    3. 返回left
    - ==辅助函数canFinsh：判断当前重量是否满足D天内送达==

#### 在排序数组中查找元素的第一个和最后一个位置 q34 【边界二分查找经典题】
- ==左/右侧边界二分查找(前后执行)==
- 题解：
    - ==边界二分查找辅助函数==
        - n[mid]>target，则选左分区，即令left=mid+1;
        - ==n[mid]<target，则选右分区，即令right=mid（这里mid不减-1，是避免右侧边界二分查找到达边界后值的判定）==
        - n[mid]==target，
            - 当d为true为左侧边界二分查找，设right=mid
            - 当d为false为右侧边界二分查找，设left=mid+1;
        - 返回值：
            - ==d为true即左边界：==
                1. ==当left=len，说明到达边界后+1才会等于len，直接返回-1==
                2. ==否则判定n[left]=target与否，等于返回left，否则-1。因为可能是因为left<right不满足循环直接此逻辑判定代码==
            - ==d为false：同左侧边界，不过判断的是0==
                1. ==left=0直接返回-1，因为只有left始终+1，所以left至少为1==
                2. ==或者没有进入left<right循环，所以还要判断是否等于target==
    - 题解：
        1. 左侧边界二分查找，如结果为-1直接返回[-1,-1]
        2. ==右侧边界二分查找，以左侧查找的值作为左边界==

#### 寻找旋转排序数组中的最小值 q153
- ==左侧边界二分查找==
- 重点：
    1. 数组的第一位元素大于右边段的所有元素，位于左边段的元素可直接跳过，因为肯定不是min值
    2. 要查找的min值即处在旋转数组的中心点上，可在右段中判断mid是否小于mid-1，是则mid为最小值，而mid-1为最大值
- ==题解：==
    - ==左侧边界二分查找：==
        1. ==nums[mid]<nums[0]，则最小值位于左分区==
            1. ==如nums[mid]<nums[mid-1]，则说明nums[mid]就是旋转中心即最小值==
            2. ==否则不是旋转中心，即right = mid==
        2. ==nums[mid]>=nums[0]，则最小值位于右分区，即left=mid+1==

#### q154 旋转数组 左侧边界二分查找
- q153的延续，允许重复元素，影响：
    1. 第一个元素由**大于变成大于等于**右分段所有元素
    2. ==旋转数组的中心点的性质，由nums[mid]**小于变成小于等于**mid-1则mid为最小值。采用right--跳过该数字的方式去除重复==
- ==题解：如进行了旋转，那么最小值始终是相对位于右边，考虑到重复的数，所以以nums[right]为基准==
    - ==由于以right为基准，所以二分查找范围为[0,n-1]==
    1. ==当nums[mid]>nums[right]，说明最小值位于右分区，令left=mid+1==
    2. ==当nums[mid]<nums[right]，说明最小值位于左分区，令right=mid==
    3. ==当nums[mid]=nums[right]，跳过重复数，即right--==

#### q378 矩阵左侧边界二分查找【特殊题：根据值二分查找】
#### 方法一：二分查找
- ==思路：根据元素值来划分分区即范围为[matrix[0][0],matrix[n-1][n-1]]，根据矩阵的值的比较计算推导出第K小位于哪边分区：==
    - 辅助函数：获取升序矩阵中小于mid元素的数量，从第一行最右开始比较，不断向左压缩，直到小于mid，累加count。在指向第二行，如此重复。
    1. ==计算小于mid的元素个数count。已知行与列都按升序排序：==
        - ==从最后一行进行计算（最后一行为每列的最大数），从最后一行第一列出发第一列进行比较==
            - ==当matrix[x][y]>mid，则向上移动，即y--==
            - ==当matrix[x][y]<=mid，由于列升序，所以[0,x]都<=mid，计数累加count+=x+1（下标所以补1）==
    2. ==当count>=k，说明mid大了，选择左分区，即right=mid==
        - 因为此时的mid不一定是矩阵中的元素，所以还需进行调整。设定right=mid后，不断的缩小right范围，直到mid不满足条件时left+1，此时left即为第k小元素。
    3. ==当count<k，说明mid小了，选择右分区，即left=mid+1==
    4. ==最后left即为第k小==
- 题解：
    1. 根据元素值来二分查找，初始化mid值为(matrix[0][0]+matrix[n-1][n-1])/2
    2. 从最左下角出发向右遍历，查找元素值<=mid的个数count
    3. 左侧边界二分查找
        1. 当count>=k，说明位于左分区，right=mid
        2. 当count<k，说明位于右分区，left=mid+1
    4. left即为第k小

##### 如图，查找第8小，从左下到右上(行升序)，实际为查找mid位于列的位置(列升序)
![image](https://note.youdao.com/yws/res/30761/AC888FC0BB3340859EAB16C42FA1ECE4)

#### 方法二：归并排序
- 重点：无需拆分，直接进行合并排序

#### 性能：二分查找>归并排序

#### 在排序数组中查找数字1 剑53
- ==题解：==
    1. ==左侧边界二分查找，找目标值的最左边值==
    2. ==从left往右计算等于target的数量==
        - 不相等自然数量为0，无需额外逻辑判断

#### 剑53.2 二分查找
- ==抽屉原理：一定存一个抽屉是空的==
- ==思路：当元素值等于下标时，说明不存在的数位于右分区，否则位于左分区==
- ==题解：==
    1. ==左侧边界二分查找==
        1. ==当nums[mid]=mid时，位于右分区，即left=mid+1==
        2. ==否则，位于左分区，right=mid==
    2. ==返回left==
