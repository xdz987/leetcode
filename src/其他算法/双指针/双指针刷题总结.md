## 双指针刷题总结
### (一)快慢指针
#### q141 快慢指针 链表
- 重点：设定fast的速度是slow的两倍，那么如果存在环时fast和slow始终会相遇
- 方案：
  - 快慢指针
  1. 设定fast=slow=head
  2. fast=fast.next.next，而slow=slow.next即速度为slow两倍
  3. 当fast==slow即存在环

#### q142 快慢指针 链表
- 提示：是q141的延伸
- 重点：当fast和slow相遇时，head->起点->相遇点的距离 = 起点->相遇点->起点的距离
- 方案：
  - 快慢指针：
  1. 找到环后fast=slow
  2. 设slow=head，然后slow和fast同时向前走
  3. 当fast=slow时，则说明为环的起点

#### q19 快慢指针 链表
- 重点：fast先走n步，再fast和slow同时走，到链表终点时slow即为倒数第n结点
- 方案
  - 快慢指针：
  1. fast指针先走n步
  2. 如果fast为null，则说明到了head，直接返回head.next，即删除了head结点
  3. 再fast和slow同时走到终点，删除slow=slow.next即删除slow结点

### (二)左右指针
#### q344 左右指针
- 重点：左右指针元素交换，向中靠拢
- 方案：
  - 左右指针：
  1. 边界为[0,length-1],交换left和right元素
  2. left++,right--

#### q645 左右指针
- 提示：q344的基础增加个元音字母判断
- 重点：增加判断元素是否为元音字母a,e,i,o,u及大写
- 方案：
  - 左右指针：
  1. 边界为left,right为[0,length-1]
  2. 当left为元音字母时，再判断right是否为元音字母，只有都为元音字母才进行交换
  3. 否则left不是则left++，right不是则right--

#### q167 左右指针
- 重点：左右指针对应的值相加比较target以调整left和right
- 方案：
  - 左右指针：
  1. 设边界为left,right[0,length-1]
  2. sum等于left和right的值
  3. 比较sum与target的大小，sum大则right--，小则left--，最后找到匹配target的下标

#### q680 左右指针
- 重点：双重左右指针，第一层判断left,right是否相等，第二层判断是否为回文字符串
- 方案：
  - 左右指针：
  1. 边界为left,right[0,length-1]，判定left值是否等于right值
  2. 不等则去除左边或去除右边字符，判断是否为回文字符串
  3. 辅助函数判断是否为回文字符串则是，左右指针left==right与否，相等则left++right--，否则不是回文字符串

#### q633 左右指针
- 重点：可将b的范围缩小到√c内，否则可能存在越界问题，即b*b可能超过int的范围
- 方案：
  - 左右指针
  1. 设边界为[0,√c]
  2. 变量sum=a方+b方，当sum<c时，a++;当sum>c时b--;

#### q11 左右指针
- 重点：左右谁先移动指针的条件谁的值小则移动
- 方案：
  - 暴力法(超时)
    - 略
  - 左右指针：
  1. 边界left,right为[0,length-1]
  2. area=(right-left)*Math.min(height[left],height[right])
  3. 比较height[left]<height[right]
    - true，left++
    - false，right--

#### q9 左右指针
- 重点：将数字转换为charArray，左右指针判断left==right直到中间

#### 移除元素 q27
- O(n) O(1)
- 重点：相等则将元素交换到最右边

#### 三数之和 q15
#### 方法一：排序+双指针
- O(N^2) O(N)
- 重点：
  1. 计算i+left+right是否为0，而left从i+1递增，right从n-1递减
  2. 去除重复情况
    1. 当nums[i]==nums[i-1]时跳过当次循环
    2. 当nums[left]==nums[left+1]时left不断++
    3. 当nums[right]==nums[right-1]时right不断--
- 方案：
  1. 降序排序
  2. 遍历所有元素
    1. 剪枝：nums[i]大于0时+右边两个元素必定>0
    2. 去重：当n[i]==n[i-1]时，说明i-1已经计算过，跳过i
    3. left=i+1,right=n-1，left<right循环查找累加等于0的三个数
      1. 当n[i]+n[left]+n[right]==0时，
        1. 添加进res
        2. 去重nums[left]==nums[left+1]时left++
        3. 去重nums[right]=nums[right+1]时right--
      2. 总和<0时，left++增大范围
      3. 总和>0时，right--缩小范围
  3. 返回res

#### 四数相加 q18
#### 方法一：排序+双指针
- 复杂度：O(n^3) O(1)
- 重点：
  - 去重：
    - 相邻相同的元素去除，需要处理四次，对应四数中的每个
  - 剪枝：
    1. 当左边的四个元素即最小之和都大于target，直接break跳出循环
    2. 当左边的元素与最右元素之和都小于target，说明以左边元素为起点的遍历不可能找到target，直接continue进入下一个起点
- 方案：
  1. 先对数组进行降序排序
  2. 遍历[0~n-3)个元素，即【四个元素中左第一个元素】
  3. 遍历[i~n-2)个元素，即【四个元素中左第二个元素】
  4. 双指针，查找等于target的值，思想同题目【三数之和】

### (三)同向条件双指针
- 指针根据一定条件才可行走

#### q283 同向条件双指针
- 重点：实际0元素可以不移动留到最后填充
- 方案：双指针。指针1为循环判断数组元素是否为0元素，指针2将非0元素向左覆盖，最后填充数组右边为0
- 移动≠“移动操作”

#### q88 同向条件双指针
- 重点：m,n为非0元素数量，从后往前判断nums1与nums2最大值得比较，并填充至nums1的最右侧
- 方案：
  - 同向条件双指针
  1. p1指向m-1,p2指向n-1,p3指向n+m-1
  2. 从n+m-1即最后一个位置进行填充
  3. 循环比较，比较nums1[p1]与nums2[p2]的大小，大的填充进入nums1[p3]，当p1或p2小于0也退出循环
  4. 补充填充p1或p2中较小元素(无需比较)

#### q392 同向条件双指针 贪心匹配
- 重点：贪心匹配 子序列
- 方案：
  - 同向条件双指针
  1. 双指针的边界为[0,s.length]和[0,t.length]
  2. 遍历t的字符，同时设立指针sp指向s的起始字符，当s的字符相等则指向下一位字符
  3. 最后sp=s.length则匹配所有字符，s即为子序列

#### q524 同向条件双指针 贪心匹配
- 提示：q392的延续
  1. 题目描述稍有问题，是从字典中找到字符串s的子序列，且为所有元素中最长的&字典顺序最小
  2. 即对子序列，并判断字符串是否最长，如同为最长再判断谁的字典顺序最小
- 重点：贪心匹配 子序列
- 方案：
  -同向条件双指针
  1. 判断元素是否为子序列，保存result
  2. 判断当前子序列长度是否大于result或者相等时字典顺序是否小于result，满足则保存result

