## 双指针刷题总结
### (一)快慢指针
- 略。看链表刷题笔记

### (二)左右指针
#### 反转字符串 q344
- ==题解：左右指针元素交换，向中靠拢==
  1. 边界为[0,length-1],交换left和right元素
  2. left++,right--

#### 错误的集合 q345
- ==题解：在【q344】基础，增加判断元素是否为元音字母a,e,i,o,u及大写,是在进行判断==

#### 两数之和2 q167
- ==题解：采用左右指针的方式。数组拥有升序的性质，为了保持细粒度，应 采用值大了缩小左边的指针，反之缩小右边指针==
  1. 当sum<target时，left++
  2. 当sum>target时，right--

#### 验证回文字符串2 q680
- ==题解：左右指针判段是否为回文串==
  1. ==是回文，返回true==
  2. ==当左右字符不相等时，返回回文判定[left+1,right]与[left,right-1]，即跳过不相等的字符判断是否为回文==
- 步骤：
  - 辅助函数：(s,left,right)判断是否为回文
  - 主函数：判断(s)是否为回文，不是则返回调用辅助函数[left+1,right]或运算[left,right-1]

#### 平方数之和 q633
- ==【同q167两数之和】，范围是[0,√c]==

#### 盛最多水的容器 q11
- ==题解：左右指针不断向中间靠拢，并动态保存最大容纳水量==
  - 保存最大容量即(距离)*min(h[left],h[right])

#### 回文数 q9
- ==题解：将整数转换为字符串再转换为charArray。再左右指针判定是否为回文子串==

#### 移除元素 q27
- ==题解：当出现重复元素时与右指针交换值==
  - ==左指针：待检查的元素==
  - ==右指针：被删除的位置==

#### 三数之和 q15
#### 方法一：排序+双指针
- 复杂度：O(N^2) O(1)
- ==思路：==
  - ==注意：由于元素需要去重，所以必须进行排序==
  - ==固定左边元素，将右边的元素中进行二分查找，查找两个元素值+左边元素后等于0==
    - ==剪枝：由于升序又从左往右遍历，所以当n[left]>0时直接break==
    - ==去重：n[left]=n[left-1]跳过==
    - 等于0，添加进res==
      - ==去重：n[mid]=n[mid+1]则跳过，n[right]=n[right-1]则跳过==
    - 大于0，缩小右指针
    - 小于0，缩小左指针
- 方案：
  1. 降序排序
  2. 遍历所有元素
    1. 剪枝：nums[i]大于0时+右边两个元素必定>0
    2. 去重：当n[i]==n[i-1]时，说明i-1已经计算过，跳过i
    3. left=i+1,right=n-1，left<right循环查找累加等于0的三个数
      1. 当n[i]+n[left]+n[right]==0时，
        1. 添加进res
        2. 去重nums[left]==nums[left+1]时left++
        3. 去重nums[right]=nums[right+1]时right--
      2. 总和<0时，left++增大范围
      3. 总和>0时，right--缩小范围
  3. 返回res

#### 四数相加 q18
- 复杂度：O(n^3) O(1)
- ==类似【三数之和】思路，不过可以进一步剪枝==
- ==思路：==
  - ==去重：==
    - ==相邻相同的元素去除，需要处理四次，对应四数中的每个数==
  - 取【三数之和】区别：
    - 【四数之和】左边元素之和>target不能剪枝，因为target可能是一个负数
      - 如-11，此时-4,-5,-6。那么-5+(-6)即为答案，但是被跳过
  - ==剪枝：==
    1. ==当左边的四个元素即最小之和都大于target，说明右边以第一个元素开始，右边任意元素组合都大于target，直接break跳出循环==
    2. ==当左边的元素与最右元素之和都小于target，说明以左边元素为起点的遍历不可能找到target，直接continue进入下一个起点==
- 题解：
  1. 先对数组进行降序排序
  2. 遍历[0~n-3)个元素为i，即【四个元素中左第一个元素】
  3. 遍历[i~n-2)个元素为，即【四个元素中左第二个元素】
  4. 双指针，查找等于target的值，思想同题目【三数之和】

### (三)同向条件双指针
- 指针根据一定条件才可行走

#### 移动零 q283
- ==思路：不需要移动0。将非0元素往左靠拢，最后右边填充为0即可。==
- ==题解：==
  1. ==指针1指向非0元数量索引，遍历元素==
    - ==当元素为0，跳过==
    - ==当元素不为0，左靠拢==
  2. ==使用指针1将右边元素填充为0==

#### 合并两个有序数组 q88
- ==题解：==
  - ==指针1指向nums1有效元素最后位==
  - ==指针2指向nums2有效元素最后位==
  - ==指针3指向nums1即结果存放容器最后位==
  1. ==指针1与指针2的值大小，将大的值放入指针3指向的位置，调整指针==
  2. ==最后如果nums2有效位还有元素，则继续放入指针3位置做补充==
- 方案：
  1. p1指向m-1,p2指向n-1,p3指向n+m-1
  2. 从n+m-1即最后一个位置进行填充
  3. 循环比较，比较nums1[p1]与nums2[p2]的大小，大的填充进入nums1[p3]，当p1或p2小于0也退出循环
  4. 补充填充p1或p2中较小元素(无需比较)

#### 判断子序列 q392
- ==题解：==
  - ==指针1指向s==
  - ==指针2指向t==
  1. ==比较指针1与指针2==
    - 相等双指针同时向前
    - 不相等指针2向前
  2. ==当指针1等于s.len时返回true==
  3. ==否则返回false==
- 方案：
  - 同向条件双指针
  1. 双指针的边界为[0,s.length]和[0,t.length]
  2. 遍历t的字符，同时设立指针sp指向s的起始字符，当s的字符相等则指向下一位字符
  3. 最后sp=s.length则匹配所有字符，s即为子序列

#### 通过删除字母匹配到字典里最长单词 q524
- 【q392的延续】

#### 方法一：动态保存+遍历子序列
- ==方案：动态保存最长且最小字典顺序子序列==
  1. ==判断元素是否为子序列，保存result==
  2. ==判断当前子序列长度是否大于result或者相等时字典顺序是否小于result，满足则保存result==

#### 方法二：排序+遍历子序列
- ==同方法一，不过先按长度降序再按字典升序==
  - 所有一旦找到符合条件立马返回

#### 最大连续1的个数 q485
- ==重点：动态更新变量：临时最大值+计数器==