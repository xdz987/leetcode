## 滑动窗口刷题总结
### (一)固定窗口
#### 字符串的排序 q567
#### 方法一：固定窗口+哈希表
- ==重点：==
  1. ==缩小窗口的条件是right-left超过固定窗口大小(s1.length)==
  2. ==返回true的条件是窗口内元素为s1的任意序列(valid=need.size)==
- ==题解：==
  1. 初始化窗口指针、使用哈希表need记录目标s1各字符出现的频率、初始化窗口哈希表window、窗口字符符合条件计数值valid
  2. ==滑动窗口规则：先判定窗口是否满足条件，再判定是否要缩小窗口==
    1. ==扩展窗口right++，当频率相等时，valid++==
    2. ==判定valid是否等于need.size()，是说明该窗口即满足条件，返回true==
    3. ==判断窗口大小是否大于s1.length()。是则缩小窗口left++，当缩小前频率相等时，valid--再缩小==
  3. 到此说明不满足返回false

#### 串联所有单词的子串 q30
- ==失败尝试==：不能再滑动窗口内动态的截取单词，会出现==单词与单词直接公用了字符的情况，出现耦合==
  - 如aba或abaa，["ab","ba"]。
    - 动态截取如[a[b]a]，中间的b被使用了两次
- 失败教训：限定了单词之间分离的情况，那么需将单词作为整体

#### 方法一：固定窗口+哈希表
- ==【同q567】，但以单词为最小单位==
- ==题解：==
  1. ==初始化窗口总长度winSize为words数组总厂*单个word长度、按频率哈希表need、窗口字符符合条件计数值valid==
  2. ==遍历words数组，记录频率于need哈希表==
  3. ==遍历s，以每个字符作为窗口起点，匹配[i,winSize]单词频率是否等于need单词频率==
    - 【此步骤同q567】

#### 找到字符串中所有字母异位词 q438
- ==【同q567】，但需要将结果保存到List==

### (二)满足条件最小窗口
#### 最小覆盖子串 q76
- ==注意点：==
  - ==包装类作为一个对象需使用equal比较相等而不能用"=="==
- ==题解：==
  1. ==初始化最小窗口resL/resR、初始化intMap容器window和need、初始化窗口指针、满足窗口字符符合条件计数值valid和target==
  2. ==滑动窗口，使得窗口内存在满足条件，但不一定是最小窗口==
  3. ==循环判断窗口是否满足最小覆盖子串==
    1. ==保存满足条件窗口的左右指针==
    2. ==不断缩小窗口，直到不满足最小覆盖子串==
  4. 返回最小窗口
- 方案：
  - 可变窗口：
  1. 初始化：窗口指针、窗口容器、窗口字符符合条件计数值、满足条件的对照容器、满足条件的子串的始终位置
  2. 填充满足条件的对照容器Map need
  3. 滑动窗口，当满足条件时，即valid==need.size，保存子串的start和end位置

#### 长度最小的子数组 q209
- ==重点：缩小窗口的条件为窗口内元素之和大于target==
- ==题解：==
  1. ==初始化左右指针、sum为0、保存结果长度res为MAX_VALUE==
  2. ==滑动窗口==
    1. ==sum累加元素值==
    2. ==遍历当sum>=target，保存最小长度，缩小窗口==
  3. ==返回最小长度==
- 方案：
  - 滑动窗口
  1. 初始化窗口指针、当前窗口元素之和、当前最小连续子数组长度res
  2. 滑动窗口
  3. 当当前窗口元素之和大于等于target
    1. 实时保存最小len至res
    2. 缩小窗口
  4. 滑动窗口结束，返回res

### (三)、满足条件最大窗口
#### 无重复字符吃的最长子串 q3
- ==重点：缩小窗口的条件为存在重复字符==
- ==题解：==
  1. ==初始化窗口指针、初始化Set作窗口容器window、最长子串res=0==
  2. 滑动窗口
    1. ==字符不存在于window，保存最长子串长度，并添加进window==
    2. ==字符存在于窗口，不断缩小窗口，直到left等于重复字符的右边为止==
  3. 返回res
- 方案：
  - 可变窗口：
  1. 初始化窗口指针、窗口容器window、长度记录
  2. 滑动窗口
  3. 当window[字符]>1时(存在重复)缩小窗口
  4. 保存当前最长子串长度Math.max(res,right-left)

#### 最大连续1的个数3 q1004
- ==题解：==
  1. ==初始化窗口指针、结果res、窗口的'0'累加zeroSum==
  2. ==滑动窗口==
    1. ==当元素为1时，保存最大连续1个个数==
    2. ==当元素为0时，判断zeroSum是否大于k==
      1. ==不大于k，保存最大连续1个数，zeroSum累加，right++右扩指针==
      2. ==大于等于k，找到当前窗口最左边的0，将left设为该0的右边，zeroSum减一==
  3. 返回res

#### 最长湍流子数组 q978
- 提示：湍流子数组即驼峰或山谷：

![image](http://note.youdao.com/yws/res/32749/4572CE99AA8F4CD691A5302EFD5B2023)
- 重点：
  1. ==当A元素超过3个时，如中间的数为驼峰或谷底时，则湍流子子数组为3==
  2. ==当A元素小于3个时，也算湍流子：==
    - A.length=1==>1
    - A.length=2==>相等则1，不相等则2
- 题解：
  1. ==初始化res，当元素数量>=2时，判定前两个元素不相等则res初始化为2，否则初始化为1==
  2. 初始化窗口指针
  3. 滑动窗口
    1. ==套用题目公式，是则保存最长湍流子数组长度，即max(res,right-left+2)==
    2. ==否则重设起点left=right==
- 方案：
  - 滑动窗口
  1. 初始化窗口指针、满足条件窗口长度res
  2. 先处理前两个元素
    - A.length=1，则res=1
    - A.length>=2，且A[0]=A[1]则res=1，反之res=2
  3. 滑动窗口right<A.length-2
  4. right++
  5. 判断right-1,right,right+1是否符合驼峰或谷底
    1. 符合则保存最长至res=right-left+2(+2是第一个驼峰或谷底由3个元素组成)
    2. 不符合则重新计算湍流子left=right
       6.滑动窗口结束，返回res

#### 水果成篮 q904
- ==注意：必须使用【哈希表】记录水果型号出现的次数，而不能使用Set。==
  - 因为存在[1,0,1,4,1,4]这种情况，相互穿插
- ==重点：缩小窗口条件为水果型号超过2种==
- ==题解：==
  1. 初始化窗口指针、哈希表valid、res
  2. ==valid.size() > 2则缩小窗口==
  3. ==保存水果总数res=Max(res,right-left)==
  4. 返回res

### (四)普通可变窗口
#### q1248 可变窗口 数学 前缀和
- 重点：优美子数组左右偶数数量影响组合次数
- 方案：
  - 滑动窗口：
  1. 初始化窗口边界、窗口状态计数器valid、结果res
  2. 滑动窗口
  3. 直到valid奇数的数量等于k，则累加计算包含k个奇数与左右偶数的优美子数组(左边偶数作为起点，右边偶数作为终点)：
    1. 左边起点，则是从窗口的第一个奇数到窗口外前一个奇数的之间偶数数量+1(可一个偶数不取所以+1)
    2. 右边终点，则是从窗口的最后一个奇数到窗口外后一个奇数之间偶数数量+1(可以一个偶数不取所有+1)
  4. res+=(左边起点)*(右边偶数)
    - 因为一个起点对应N个终点，所以是起点*终点
  5. 缩小窗口left++，valid--(因为3.1后left指针已指向窗口的第一个奇数)
    - 3.2后right指向窗口外右边的第一个奇数或者结尾元素
  6. 返回res
  - 前缀和：
  1. 初始化前缀和容器数组preSum、结果res、奇数总数sum
  2. preSum[0]=1，第一个优美子数组+1
  3. 循环每个原数组元素
    - 当元素为奇数，则sum++
    - 记录每个奇数的前缀和，即preSum[sum]++
    - 当sum>=k，即满足条件，则res+=preSum[sum-k]
      - 即res加优美子数组的每个起点总数*1(终点)

### q992 滑动窗口 思路转换
- 重点：恰好(等于)K = 最多K - 最多K-1

```
 由于题目要求的是，某个子数组中不同的整数个数恰好(等于)为K，直接使用滑动窗口比较难求(如例1)。
 * 可运用技巧的是：恰好(等于)K可转换为最多为K，即：
 (1)例如K=2。  最多为2则是：可以是1个整数或2个整数； 恰好为2：只能是2个整数
 (2)即最多2 = 恰好为2 + 恰好为1/最多为1
 (3)即恰好K = 最多K - 最多K-1
 而转换为最多为K后，则滑动窗口的计算变得很紧密。本来恰好为K需要跳过K-1...的情况，滑动窗口变得麻烦如(K=2,跳过1)；而最多为K则可以计算所有的可能，无需考虑K-1及往前的计算(如例2)。
```

- 方案：
  - 滑动窗口：A的某个子数组中不同整数的个数最多为K

```
 当窗口指针left或right固定(即在收缩或者拓展窗口处)时：res+=right-left(如right指向窗口最后一个元素，则+1)
 如left固定而向右拓展窗口：[1,2,1,2,3],k=2。 left=0固定时，直到K>2之前为 [1][1,2][1,2,1][1,2,1,2] 再收缩则[2][2,1][2,1,2] ... 直到[2][2,3] ==> 即4+3+2+1+2=12
```

#### q424 滑动窗口
- 重点：
  1. 使用maxCharCount比较而保存最大频率字符
  2. 缩小窗口条件：窗口内元素<maxCharCount+k
  3. 缩小窗口为单次收缩即使用if而不是while
    - 因为题目K次是替换任意字符
- 方案：
  - 滑动窗口：
  1. 初始化窗口指针、当前最大频率字符数量maxCharCount、统计窗口内字符频率freq
  2. 滑动窗口
  3. 每轮循环保存最大频率字符数量
  4. 需要替换的字符大于K则缩小窗口(单次)
  5. 保存替换后的最长重复字符res=max(res,right-left)

#### q395 滑动窗口 枚举 字符种类
- 重点：拓展与缩小窗口以字符的种类进行判定
- 方案：
  - 分治-递归
    - 略，见分治刷题总结
  - 滑动窗口 枚举

```
/**
 * 滑动窗口 枚举
 * 提示：先读代码再读这，帮助理解
 *
 * 一、枚举理解
 * 问1：为什么t需要从1~26都执行一遍？可否一些情况(s字符种类<26种字符)时t不执行到26(优化)？
 * 结论：t的值决定了符合K的连续的字符所包含的字符种类的最大长度。
 * (1)每种t(1~26)对应着a~z(26个)的26种最长的排列组合，t=满足条件最长子串种的字符种类数，才能使得less为0，从而恰当的获得最大值
 * (2)t大了，则会包含不符合k的字符，res=0
 * (3)t小了，则没有涵盖所有符合条件的字符，即使less=0，但res无法取得最大值
 * 过程：
 * - 例子1
 * kababccdddef k=2。最长子串为ababccddd，即res=9，窗口内字符种类为4
 * (1)K=2时，t=1。当执行到cc和ddd时，less=0，res=3(错)。符合结论(3)
 * (2)K=2时，t=3。当执行到ababcc，less=0，res=6(错)。符合结论(3)
 * (3)K=2时，t=5。当执行到kababccddd，less=1(包含了k而没有缩小窗口)，res=0。符合结论(2)
 * (4)k=2时，t=4。当执行到kababcc，less=1继续拓展窗口，kababccd，种类5>t4缩小窗口，ababccddd，less=0，res=9。符合结论(1)
 *
 * - 例子2
 * abcdefg...xyzxyz...gfedcba k=2，最长子串即s.length，res=52，窗口内字符种类为26
 * 此时，k=3则res=0，t=1~26都不影响结果
 * 而当，k=2时，必须是t=26，才能使得最长子串时能够涵盖a~z，使得res=52
 *
 * - 例子3
 * aaaaeebbbbbcccccdef，k=5 最长子串bbbbbccccc，res=6，串口内字符种类为2
 * 此时只有t=2才能使得res=6，因为最长子串的字符种类为2
 *
 * 二、滑动窗口
 * 重点：
 * 以下只是一种查找窗口内字符种类满足t与否 以及 字符是否满足k与否的 高效方法（这么做是为了性能，也可遍历count，但性能就低了)
 * 1. 窗口滑动的拓展与收缩
 * 1)在拓展窗口时，在拓展的第right个字符为第1次出现(数量为1)和等于k时进行记录 less total
 * 2)在缩小窗口时，在收缩的第left个字符为数量为1和小于k时进行记录 less total
 * 2. 子串最大值的查找
 * 1)由上面的结论中可发行，当t小于窗口种类total时，0<res<子串最大值(正确值)，所以需不断的取max
 *
 * 三、枚举优化
 * 优化1：k=1时直接返回s.length
 *
 * 优化2：减少t的循环次数，即当找到最长子串后直接break
 * 1)由部分一中的结论可知res随着t的增长而变化：
 * 当t<窗口内元素时，0<res<最长子串长度(错误)，且res的值与t成正比
 * 当t=窗口内元素时，res=最长子串长度(正确)
 * 当t>窗口内元素时，res=0
 * 2)方案：
 * 滑动窗口前保存res的值为lastRes，滑动窗口后查看res==lastRes
 * 情况一：存在最长子串
 * 不相等，则说明当前t<滑动窗口内元素，res递增中
 * 相等，则说明当前及往后所有t>滑动窗口内元素，即res=max(res,0)，才会导致res==lastRes
 *
 * 情况二：不存在最长子串
 * res始终为0，当t=1时循环就结束
 */
```

#### q395 滑动窗口
- 重点：将原本就满意的客户与可能不满意的客户数据分离
- 方案：
  - 固定窗口
  1. 先计算原本就满意的客户
  2. 再滑动固定x长度的窗口，找到窗口元素和最大的值
  3. 返回原本满意+窗口最大值

#### q1658前缀和 滑动窗口 总数
- 重点：
  - 前缀和：total-(sum[i]-sum[j])=x
  1. 元素>=1。即表示sum_j>0，则left存在操作，j+1(j为索引从0开始算需+1)；如sum_j=0则表示左边没有操作数j
  2. 左操作数区间和+有操作数区间和=x，即sum[j]+[total-(sum[i]-sum[j])-sum[j]]=x ，即sum[j]=sum[i]-total+x
  3. 作数数量：左=j+1或j，右=length-(i+1)。操作数量=左+右，注：当sum[j]=0则不存在操作数
  - 滑动窗口
  1. total-窗口内元素之和=x
  2. 操作数之和：left+(length-(right+1))
- 方案：
  - 前缀和：total-窗口内元素之和=x
  1. 初始化前缀和容器preSum、总数、结果
    - preSum[0,0]
    - 存在不减左边元素操作，即sum[i]需要sum[j]为0的情况
  2. 前缀和查找满足条件最小操作数
  3. 当sum[i]==x则所有减去所右元素才满足条件，res=nums.length
  - 滑动窗口
  1. 初始化结果res、窗口指针、总数和、窗口内元素和、目标窗口内元素和(换算得来)calTarget
  2. 如total<x则直接返回-1
  3. 滑动窗口
  4. 当前窗口内元素超过目标calTarget时，缩小窗口
  5. 窗口内元素满足条件，保存最小操作数结果
  6. 返回res

#### q1234 滑动窗口
- 重点：
  1. 关注多余平均数的字符
    - 如Q:1 W:4 E:3 R:4 length/4=3，关注W和R，满足条件最小替换即"WR"替换成"QQ"，长度为2。又或者WQR，长度为3
  2. 'A-Z'的字符可存储至数组，如'B'-'A'=1
- 方案：
  - 滑动窗口HashMap：性能低
  - 滑动窗口intMap：性能佳
  1. 初始化窗口指针、结果res、s各个字符数量容器count[]
  2. 统计字符数量count[]
  3. 滑动窗口，**以减的形式**
    - 即滑动窗口right++时，是减少count中right位置字符的数量
  4. 当'Q','W','E','R'都<length/4时，且left<length时，说明满足条件
    - 保存最小值
    - 缩小窗口
  5. 返回结果res
