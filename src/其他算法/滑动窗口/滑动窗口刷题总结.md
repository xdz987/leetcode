## 滑动窗口刷题总结
### (一)、固定窗口
#### q567 固定窗口
 - 重点：
    1. 缩小窗口的条件是right-left超过固定窗口大小(s1.length)
    2. 返回true的条件是窗口内元素为s1的任意序列(valid=need.size)
 - 方案：
    - 滑动窗口
    1. 初始化窗口指针、窗口容器、窗口字符符合条件计数值、满足条件的对照容器need
    2. 填充满足条件的对照容器need
    3. 滑动窗口
    4. valid==need则返回true
    5. right-left大于固定窗口s1.length长度则缩小窗口
    6. 滑动窗口结束，没有符合返回false

#### q438
 - 提示：基本和q567一样，区别：
    1. 找到满足条件的子串放入list

### (二)、满足条件最小窗口
#### q76 满足条件最小窗口
 - 注意点：
    1. String作为一个对象需使用equal比较相等而不能用"=="
 - 重点：
    1. 基于滑动窗口框架
    2. 满足题目子串要求与缩小窗口的条件为，valid等于need.size，
        - 即含有指定字符与数量
 - 方案：
    - 可变窗口：
    1. 初始化：窗口指针、窗口容器、窗口字符符合条件计数值、满足条件的对照容器、满足条件的子串的始终位置
    2. 填充满足条件的对照容器Map need
    3. 滑动窗口，当满足条件时，即valid==need.size，保存子串的start和end位置

#### q209 满足条件最小窗口
 - 重点：缩小窗口的条件为窗口内元素之和大于target
 - 方案：
    - 滑动窗口
    1. 初始化窗口指针、当前窗口元素之和、当前最小连续子数组长度res
    2. 滑动窗口
    3. 当当前窗口元素之和大于等于target
        1. 实时保存最小len至res
        2. 缩小窗口
    4. 滑动窗口结束，返回res

### (三)、满足条件最大窗口
#### q3 满足条件最大窗口
 - 重点：缩小窗口的条件为存在重复字符
 - 方案：
    - 可变窗口：
    1. 初始化窗口指针、窗口容器window、长度记录
    2. 滑动窗口
    3. 当window[字符]>1时(存在重复)缩小窗口
    4. 保存当前最长子串长度Math.max(res,right-left)

#### q209 满足条件最大窗口
 - 重点：
    1. 计算窗口内0的数量
    2. 缩小窗口条件为：
        1. (独立)"零计数器">K
        2. (独立)“零计数器”=K并且下一个窗口为0
 - 方案：
    - 滑动窗口
    1. 初始化窗口指针、窗口内元素为0的累加器、当前最大连续1的长度
    2. 滑动窗口
    3. 如拓展的元素为0则累加器+1
    4. 如累加器>K，缩小窗口，判断缩小窗口left元素而更新累加器
    5. 保存最长长度res
    6. 如累加器=K并且right下一个元素为0，判断缩小窗口left元素而更新累加器
    7. 滑动窗口结束，返回res

#### q978 满足条件最大窗口
 - 提示：湍流子数组即驼峰或山谷：

![image](http://note.youdao.com/yws/res/32749/4572CE99AA8F4CD691A5302EFD5B2023)
 - 重点：
    1. 当A元素超过3个时，如中间的数为驼峰或谷底时，则湍流子子数组为3
    2. 当A元素小于3个时，也算湍流子：
        - A.length=1==>1
        - A.length=2==>相等则1，不相等则2
 - 方案：
    - 滑动窗口
    1. 初始化窗口指针、满足条件窗口长度res
    2. 先处理前两个元素
        - A.length=1，则res=1
        - A.length>=2，且A[0]=A[1]则res=1，反之res=2
    3. 滑动窗口right<A.length-2
    4. right++
    5. 判断right-1,right,right+1是否符合驼峰或谷底
        1. 符合则保存最长至res=right-left+2(+2是第一个驼峰或谷底由3个元素组成)
        2. 不符合则重新计算湍流子left=right
    6.滑动窗口结束，返回res

#### q904 满足条件最大窗口
 - 重点：缩小窗口条件为水果型号超过2种
 - 方案：
    - 滑动窗口
    1. 初始化窗口指针Map、res
    2. valid.size() > 2则缩小窗口
    3. 保存水果总数res=Max(res,right-left)
    4. 返回res

### (四)普通可变窗口
#### q1248 可变窗口 数学 前缀和
 - 重点：优美子数组左右偶数数量影响组合次数
 - 方案：
    - 滑动窗口：
    1. 初始化窗口边界、窗口状态计数器valid、结果res
    2. 滑动窗口
    3. 直到valid奇数的数量等于k，则累加计算包含k个奇数与左右偶数的优美子数组(左边偶数作为起点，右边偶数作为终点)：
        1. 左边起点，则是从窗口的第一个奇数到窗口外前一个奇数的之间偶数数量+1(可一个偶数不取所以+1)
        2. 右边终点，则是从窗口的最后一个奇数到窗口外后一个奇数之间偶数数量+1(可以一个偶数不取所有+1)
    4. res+=(左边起点)*(右边偶数)
        - 因为一个起点对应N个终点，所以是起点*终点
    5. 缩小窗口left++，valid--(因为3.1后left指针已指向窗口的第一个奇数)
        - 3.2后right指向窗口外右边的第一个奇数或者结尾元素
    6. 返回res
    - 前缀和：
    1. 初始化前缀和容器数组preSum、结果res、奇数总数sum
    2. preSum[0]=1，第一个优美子数组+1
    3. 循环每个原数组元素
        - 当元素为奇数，则sum++
        - 记录每个奇数的前缀和，即preSum[sum]++
        - 当sum>=k，即满足条件，则res+=preSum[sum-k]
            - 即res加优美子数组的每个起点总数*1(终点)

### q992 滑动窗口 思路转换
 - 重点：恰好(等于)K = 最多K - 最多K-1

```
 由于题目要求的是，某个子数组中不同的整数个数恰好(等于)为K，直接使用滑动窗口比较难求(如例1)。
 * 可运用技巧的是：恰好(等于)K可转换为最多为K，即：
 (1)例如K=2。  最多为2则是：可以是1个整数或2个整数； 恰好为2：只能是2个整数
 (2)即最多2 = 恰好为2 + 恰好为1/最多为1
 (3)即恰好K = 最多K - 最多K-1
 而转换为最多为K后，则滑动窗口的计算变得很紧密。本来恰好为K需要跳过K-1...的情况，滑动窗口变得麻烦如(K=2,跳过1)；而最多为K则可以计算所有的可能，无需考虑K-1及往前的计算(如例2)。
```

 - 方案：
    - 滑动窗口：A的某个子数组中不同整数的个数最多为K

```
 当窗口指针left或right固定(即在收缩或者拓展窗口处)时：res+=right-left(如right指向窗口最后一个元素，则+1)
 如left固定而向右拓展窗口：[1,2,1,2,3],k=2。 left=0固定时，直到K>2之前为 [1][1,2][1,2,1][1,2,1,2] 再收缩则[2][2,1][2,1,2] ... 直到[2][2,3] ==> 即4+3+2+1+2=12
```

#### q424 滑动窗口
 - 重点：
    1. 使用maxCharCount比较而保存最大频率字符
    2. 缩小窗口条件：窗口内元素<maxCharCount+k
    3. 缩小窗口为单次收缩即使用if而不是while
        - 因为题目K次是替换任意字符
 - 方案：
    - 滑动窗口：
    1. 初始化窗口指针、当前最大频率字符数量maxCharCount、统计窗口内字符频率freq
    2. 滑动窗口
    3. 每轮循环保存最大频率字符数量
    4. 需要替换的字符大于K则缩小窗口(单次)
    5. 保存替换后的最长重复字符res=max(res,right-left)

#### q395 滑动窗口 枚举 字符种类
 - 重点：拓展与缩小窗口以字符的种类进行判定
 - 方案：
    - 分治-递归
        - 略，见分治刷题总结
    - 滑动窗口 枚举

```
/**
 * 滑动窗口 枚举
 * 提示：先读代码再读这，帮助理解
 *
 * 一、枚举理解
 * 问1：为什么t需要从1~26都执行一遍？可否一些情况(s字符种类<26种字符)时t不执行到26(优化)？
 * 结论：t的值决定了符合K的连续的字符所包含的字符种类的最大长度。
 * (1)每种t(1~26)对应着a~z(26个)的26种最长的排列组合，t=满足条件最长子串种的字符种类数，才能使得less为0，从而恰当的获得最大值
 * (2)t大了，则会包含不符合k的字符，res=0
 * (3)t小了，则没有涵盖所有符合条件的字符，即使less=0，但res无法取得最大值
 * 过程：
 * - 例子1
 * kababccdddef k=2。最长子串为ababccddd，即res=9，窗口内字符种类为4
 * (1)K=2时，t=1。当执行到cc和ddd时，less=0，res=3(错)。符合结论(3)
 * (2)K=2时，t=3。当执行到ababcc，less=0，res=6(错)。符合结论(3)
 * (3)K=2时，t=5。当执行到kababccddd，less=1(包含了k而没有缩小窗口)，res=0。符合结论(2)
 * (4)k=2时，t=4。当执行到kababcc，less=1继续拓展窗口，kababccd，种类5>t4缩小窗口，ababccddd，less=0，res=9。符合结论(1)
 *
 * - 例子2
 * abcdefg...xyzxyz...gfedcba k=2，最长子串即s.length，res=52，窗口内字符种类为26
 * 此时，k=3则res=0，t=1~26都不影响结果
 * 而当，k=2时，必须是t=26，才能使得最长子串时能够涵盖a~z，使得res=52
 *
 * - 例子3
 * aaaaeebbbbbcccccdef，k=5 最长子串bbbbbccccc，res=6，串口内字符种类为2
 * 此时只有t=2才能使得res=6，因为最长子串的字符种类为2
 *
 * 二、滑动窗口
 * 重点：
 * 以下只是一种查找窗口内字符种类满足t与否 以及 字符是否满足k与否的 高效方法（这么做是为了性能，也可遍历count，但性能就低了)
 * 1. 窗口滑动的拓展与收缩
 * 1)在拓展窗口时，在拓展的第right个字符为第1次出现(数量为1)和等于k时进行记录 less total
 * 2)在缩小窗口时，在收缩的第left个字符为数量为1和小于k时进行记录 less total
 * 2. 子串最大值的查找
 * 1)由上面的结论中可发行，当t小于窗口种类total时，0<res<子串最大值(正确值)，所以需不断的取max
 *
 * 三、枚举优化
 * 优化1：k=1时直接返回s.length
 *
 * 优化2：减少t的循环次数，即当找到最长子串后直接break
 * 1)由部分一中的结论可知res随着t的增长而变化：
 * 当t<窗口内元素时，0<res<最长子串长度(错误)，且res的值与t成正比
 * 当t=窗口内元素时，res=最长子串长度(正确)
 * 当t>窗口内元素时，res=0
 * 2)方案：
 * 滑动窗口前保存res的值为lastRes，滑动窗口后查看res==lastRes
 * 情况一：存在最长子串
 * 不相等，则说明当前t<滑动窗口内元素，res递增中
 * 相等，则说明当前及往后所有t>滑动窗口内元素，即res=max(res,0)，才会导致res==lastRes
 *
 * 情况二：不存在最长子串
 * res始终为0，当t=1时循环就结束
 */
```

#### q395 滑动窗口
 - 重点：将原本就满意的客户与可能不满意的客户数据分离
 - 方案：
    - 固定窗口
    1. 先计算原本就满意的客户
    2. 再滑动固定x长度的窗口，找到窗口元素和最大的值
    3. 返回原本满意+窗口最大值
