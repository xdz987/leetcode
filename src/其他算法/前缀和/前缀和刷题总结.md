## 前缀和刷题总结
#### q1 前缀和
 - 重点：空间换时间，保存查询过的值，判断需要的值是否再保存中
 - 方案：
    - 前缀和:
    1. 初始化容器Map保存已经查询过的值
    2. 查询target-num[i]是否存在于保存的值中
        - 存在，返回[map.get(target-num[i])，i]
    3. 将num[i]保存至map

#### q560 前缀和
 - 变数：
    1. 额外字典sum，sum.put(0,1)
    2. res，保存结果
 - 执行：
    - 将计算前缀和的过程结合进题目要求
    - 原为sum[i]-sum[j]=移项为sum[j]=sum[i]-k
        1. 设i>j的
        2. 例5-2=3，即sum[i]-k=sum[j]，sum[j]的值一定比sum[i的值小]，即sum[j]已经跃过了(不一定存在此前缀和)
    1. 循环原数组
    2. sumi+=num[i]，即前缀和
    3. sumj=sumi-k，sumj为符合条件的前缀和
        - 满足条件需要两个前缀和的值，sumi是一定存在的，则只需要判断sumj是否存在
    4. 判断sumj是否存在于字典sum，存在则res+=字典value
    5. 将sumi保存进前缀和
    6. 返回结果

#### q1248 可变窗口 数学 前缀和
 - 重点：优美子数组左右偶数数量影响组合次数
 - 方案：
    - 滑动窗口：
    1. 初始化窗口边界、窗口状态计数器valid、结果res
    2. 滑动窗口
    3. 直到valid奇数的数量等于k，则累加计算包含k个奇数与左右偶数的优美子数组(左边偶数作为起点，右边偶数作为终点)：
        1. 左边起点，则是从窗口的第一个奇数到窗口外前一个奇数的之间偶数数量+1(可一个偶数不取所以+1)
        2. 右边终点，则是从窗口的最后一个奇数到窗口外后一个奇数之间偶数数量+1(可以一个偶数不取所有+1)
    4. res+=(左边起点)*(右边偶数)
        - 因为一个起点对应N个终点，所以是起点*终点
    5. 缩小窗口left++，valid--(因为3.1后left指针已指向窗口的第一个奇数)
        - 3.2后right指向窗口外右边的第一个奇数或者结尾元素
    6. 返回res
    - 前缀和：
    1. 初始化前缀和容器数组preSum、结果res、奇数总数sum
    2. preSum[0]=1，第一个优美子数组+1
    3. 循环每个原数组元素
        - 当元素为奇数，则sum++
        - 记录每个奇数的前缀和，即preSum[sum]++
        - 当sum>=k，即满足条件，则res+=preSum[sum-k]
            - 即res加优美子数组的每个起点总数*1(终点)

#### q724 前缀和 总数
 - 提示：左右指针较难AC，因为元素存在负数，不好判断哪边的指针走
 - 重点：左边元素之和sum=所有元素之和total-左边元素之和-中心元素nums[i]
 - 方案：
    - 前缀和：
    1. 初始化所有元素之和、前缀和sum
    2. 遍历数组元素，判断nums[i]=total-sum*2

#### q974 前缀和 数学
 - 重点：
    1. 0必定可被K整除
    2. 负数取模为负数(和语言有关)
 - 方案：
    - 暴力前缀和
    1. 初始化前缀和容器、满足条件子数组数量、累计运算sum
    2. 填充前缀和容器
    3. 双层循环：区间之和%K等0则res++
        - (sums[i] - sums[j]) % K == 0
    - 优化前缀和 hashMap
    1. 初始化前缀和容器[sum%k,数量]、结果res
    2. 循环所有元素
        1. 累加sum
        2. 计算preSum容器是否存在(sum%k)的数
            - 即是否存在sum[i]%k等于sum[j]%k，需要注意的是需取绝对值
                - 如2-7=-5,-5%5=0
                - 而2%5=2，-7%5=-2,2≠-2
        3. preSum添加当前i的sum%k的绝对值
    4. 返回res
    - 优化前缀和 int[]
    1. map换int[K.length]
        1. int[0]=1
        2. res+=preSum[(sum%k+k)%k]
            - res初始化时未赋值的元素为0
        3. preSum[(sum%k+k)%k]++

#### q523 前缀和 数学
 - 提示：类似于q974
 - 重点：
    1. 不同于q974,0不是K的倍数
    2. k可以为负数和0
 - 方案：
    - 前缀和：两条线
    - 同q974，
    1. 初始化前缀容器HashMap[sum,i] preSum
    2. 当k=0时，sum[i]==sum[j]
        - i-preSum.get(sum[j])>1，即使符合n*k元素数量至少2个
    3. 当k≠0时，sum[i]%k==sum[j]%k
        - i-preSum.get(sum[j])>1，即使符合n*k元素数量至少2个

#### q930 前缀和
 - 重点：0<=元素<=1，所以前缀和<=S
    - 则可用int[]存储优化后的前缀和
 - 方案：
    - 暴力前缀和：
        - sum[i]-sum[j]==S
        - 略
    - 优化前缀和 HashMap：
        1. 如preSum.containsKey(sum-S)为true，则res+=preSum.get(sum-S)
        2. preSum.put(sum...)
    - 优化前缀和 int[]：
        1. 如sum-S>=0，则res+=preSum[sum-S]
        2. preSum[sum]++

