## 前缀和刷题总结
#### 和为k的子数组 q560
#### 方法一：前缀和+哈希表
- ==题解：==
    1. ==使用哈希表存储前缀和==
        - 由于题目不要求元素数量，即==单个整数也可，所以map.put(0,1)==
    2. ==遍历数组，计算前缀和preSum==
        - 前缀和：curSum-preSum=k
        - 即：==curSum-k=preSum==
    3. ==查找哈希表是否存在curSum-k，存在则累加res次数==
    4. ==更新哈希表，即map.put(preSum,map.get(preSum))==
        - 因为存在负数的情况，可能有数个子数组前缀和相等

#### 统计优美子数组 q1248
#### 方法一：前缀和+哈希表/intMap
- ==【同q560】，前缀和是奇数的个数==
- ==原理：当奇数的个数达到K个之后，往后每遍历一个非奇数都res都加子数组的数量，奇数则增加数量的因子。==
    - 其中map对应着<奇数个数，该奇数个数的出现次数>
- ==题解：==
    1. 遍历数组
        1. ==如果元素为奇数，则preSum++==
        2. 否则前缀和不变
    2. ==查找哈希表是否存在preSum-k，存在则累加res次数==
    3. ==更新哈希表map.put(preSum,map.get(preSum))==

#### 方法二：滑动窗口
- 重点：优美子数组左右偶数数量影响组合次数
- 方案：
    - 滑动窗口：
    1. 初始化窗口边界、窗口状态计数器valid、结果res
    2. 滑动窗口
    3. 直到valid奇数的数量等于k，则累加计算包含k个奇数与左右偶数的优美子数组(左边偶数作为起点，右边偶数作为终点)：
        1. 左边起点，则是从窗口的第一个奇数到窗口外前一个奇数的之间偶数数量+1(可一个偶数不取所以+1)
        2. 右边终点，则是从窗口的最后一个奇数到窗口外后一个奇数之间偶数数量+1(可以一个偶数不取所有+1)
    4. res+=(左边起点)*(右边偶数)
        - 因为一个起点对应N个终点，所以是起点*终点
    5. 缩小窗口left++，valid--(因为3.1后left指针已指向窗口的第一个奇数)
        - 3.2后right指向窗口外右边的第一个奇数或者结尾元素
    6. 返回res

#### 寻找数组的中心下标 q724
- 注意：==左右指针较难AC==，因为元素存在负数，不好判断哪边的指针走

#### 方法一：前缀和
- ==题解：==
    1. ==计算所有元素之和sum==
    2. ==遍历元素，当num=sum-2*preSum时，说明num即为中心点==
        - sum=left+num+right，其中left与right会一组元素和/前缀和

#### 和可被k整除的子数组 q974
#### 方法一：前缀和+哈希表
- 前置：
    1. ==0必定可被K整除==
    2. ==负数取模为负数(和语言有关)==
- ==题解：==
    1. ==初始化哈希表int[k]，put(0,1)==
    2. ==遍历数组，累加前缀和==
    3. ==由于题目要求的是被k整除，k的倍数都为前缀查找的目标，累加前缀和res==
        - ==k的倍数：(preSum%k+k)%k，取得正负数的绝对值==
        - 如查找4，那么4、-4、8、-8、40都可看做同个数

#### 连续的子数组和 q523
- 注意：
    1. 不同于q974,0不是K的倍数
    2. k可以为负数和0
- ==重点：对前缀和进行取模后再保存到map中，即sum=sum%k==
- ==题解：==
    - ==前缀和哈希表<前缀和，元素下标>==
    1. ==初始化哈希表，由于子数组大小至少为2，哈希表的value为元素下标，则初始化put(0,-1)==
    2. 遍历数组，累加前缀和
    3. ==当k!=0时，preSum取得取模于k后的值==
        - 当k=0时，map[i]=map[j]。此时说明存在前一个前缀和A和后一个前缀和B之间差为k的倍数
            - 如k=6，而23和29之差为6，此时23%6=5，29%6=5。所以map[i]=map[j]即满足标记
        - 当k≠0时，map[i]%k==map[j]%k
    4. ==当map存在preSum，且子数组大小至少为2，则返回true==
        - i-map.get(preSum)>2
    5. ==map不存在于preSum，则放入map==

#### 和相同的二元子数组 q930
- 【同q1248统计优美子数组】

## 差分
- 类似于前缀和，区别在于
    - 前缀和：只有一条前缀和，但不断累加递增
    - 差分：存在多条起点，累加的是多条路径的值
        - 起点：实现的方式即在起点处赋值X
        - 终点：在终点处减去该值X
        - 例子：
            1. 赋值。起点赋+终点赋-，结果10,0,0,0,-10
            2. 累加。后一元素等于前一元素，结果：10,10,10,10,10
- 优点：不管有多少条路径，复杂度最多为O(N+M)
    - 如采用暴力法则是O(N*M)

#### 航班预计统计 q1109
#### 方法一：差分
- 方案：
    1. 初始化res[]
    2. 遍历bookings，差分赋值
    3. 累加res[i+1]+=res[i]