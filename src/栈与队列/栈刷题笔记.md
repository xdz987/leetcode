## 一、单调栈
### 下一个更大的数 q496
#### 方法一：哈希表+单调栈
- ==哈希表的作用：从【结果集】找到题目想要的【一些结果】，即nums1数组元素==
- ==思想：查找nums2每个元素的下一个更大元素，此过程nums1无参与。==
- ==题解：递减栈==
    1. ==从后往前遍历nums2数组，元素设num==
    2. ==当栈不为空时，栈顶元素如小于num，即不符合递减栈，遍历出栈直到符合>num==
    3. ==将num元素放入队列，如栈为空值为-1，否则为栈顶元素==
        - -1说明不存在更大的数字
- 方案：
    - 补充：题目为两个数组，使用Map存储元素与下一个元素的位置，最后再还原nums1的位置
    1. 初始化一个栈做排除<=当前元素的元素
    2. 倒叙遍历所有元素
        1. 栈不为空，并且栈中的元素<=当前元素
            - 弹出
        2. 保存“下一个更大的数”，如果栈为空则说明不存在更大的数即-1，否则保存当前栈顶元素
        3. 将当前元素压栈
    4. 返回结果数组

#### 方法二：暴力法+哈希表
- ==哈希表的作用：找到目标元素的下标索引，才能找到右边元素==
- ==思想：==
    - ==使用哈希表记录[nums2元素值，nums2元素值对应位置==
    - ==当遍历nums1元素时，通过哈希表查找到是否存在于nums2数组中。==
        1. ==不存在于nums2则为-1==
        2. ==存在则从其右边查找下一个更大元素立即break此层循环==
- 题解：
    1. 将nums2以[值,索引]方式建立哈希表
    2. 初始res数组，遍历nums1元素
        1. 初始res[i]为-1
        2. 当nums1元素存在于哈希表则查找下个更大元素，找打立即break
    3. 返回res

### 每日温度 q739
#### 方法一：单调栈
- ==题解：递减栈，不过栈保存的是下标，通过下标计算等待天数==

### 下一个更大的数2 q503
#### 方法一：单调栈+循环数组
- ==题解：递减栈，不过数组可循环==
    - ==循环数组实现：遍历的元素为length*2，通过取模即i%n获取元素和赋值==

## 二、多栈
### 最小栈 q155
#### 方法一：双栈
- ==思想：==
    - ==使用A栈，普通栈即入栈不做处理==
    - ==使用B栈，每次入栈都保存自栈底向上与新添加元素的最小值==
- 题解：
    1. 初始化AB栈
        - B栈为最小栈，先入栈一个Integer.MAX_VALUE，可省略是否为空的判断
    - 入栈：
        1. A栈正常入栈
        2. B栈保存min(栈顶元素,val)
    - 出栈、peek()、minValue：直接操作

### 有效的括号 q20
#### 方法一：栈
- ==思想：有效的括号是，当遇到右括号时，栈顶必须是匹配的左括号，否则是无效的括号==
- ==题解：==
    1. ==如是左括号则入栈==
    2. ==如是右括号则判断栈顶是否为匹配的左括号==
        1. 匹配，continue继续匹配
        2. 不匹配，返回false

### 删除相邻重复项 q1047
- ==同【q20有效括号】，不过最后返回的是栈剩余元素==
    - 需要注意的是，栈是先入后出，但结果需要保存先对顺序

#### 方法一：辅助栈
- ==题解：使用双端队列，入队口作为栈，出队口重新组合res字符串==

#### 方法二：StringBuilder充当栈
- ==优势：可剩去最后重新组装成字符串的步骤==
- ==题解：StringBuilder的Len-1作为栈顶，结果直接返回sb.toString()==

### 逆波兰表达式 q150
#### 方法一：栈
- ==题解：==
    1. ==当遇到运算符"+-/*"时，对栈顶两个元素进行运算，并压栈==
    2. ==由于堆是逆序，所以是第二个出栈+-*/第一个出栈元素==

