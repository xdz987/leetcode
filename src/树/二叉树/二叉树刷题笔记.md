 - 遍历基本框架

```
/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历g
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```
## 一、递归理解-修改二叉树为例
 - 把题目要求细化(每个节点需要做什么)，然后交给递归(前/中/后序)，**不需要跳进递归里的细节**，理解递归的函数/定义即可。

#### 形式区别
 - 前序：自顶向下。水平操作，需求是对每个**节点**进行操作
    - 最里面的递归为叶节点
    - 应用：每个节点链接、修改、查找等
 - 后序：自下向顶。垂直操作，需求是对每颗**子树**进行操作
    - 最里面的递归为root节点
    - 应用：重复子树、树的深度、链接左右子树等

### (一)将某节点下的左右子树拉成单链表
 - 抽象：left/right两条右斜树单链表
 - 业务：在两条单链表**头结点**位置进行**垂直连接**

 - 应用1：后序，需对两条单链表头尾相连 q114

```
void flatten(TreeNode root) {
    // base case
    if (root == null) return;

    //递归拉成单链表，指向该子树(left/right)头节点
    flatten(root.left);
    flatten(root.right);
    
    //左子树单链表
    TreeNode left = root.left;
    //右子树单链表
    TreeNode right = root.right;
    
    //修改root的节点，将left单链表链接到root.right
    root.left = null;
    root.right = left;
    
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
}
```
![image](http://note.youdao.com/yws/res/34277/2EEDC66E5AD84A2DAB513729E6A8B7C3)

 - 应用2：前序，需对两条单链表每个节点交换位置 q226

```
TreeNode invertTree(TreeNode root) {
    // base case
    if (root == null) {
        return null;
    }

    /**** 前序遍历位置 ****/
    // root 节点需要交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 让左右子节点继续翻转它们的子节点
    invertTree(root.left);
    invertTree(root.right);

    return root;
}
```
![image](http://note.youdao.com/yws/res/34364/BF51E189DCF54F3CB8BA2134BD006F22)
### (二)将两个节点下的左右子树拉成单链表
 - 抽象：node1和node2的left/right右斜树四条单链表
 - 业务：对四条单链表的**每个**节点进行**水平连接**
 - 应用1：前序，需要对四条链表每个节点进行横向链接 q116

```
void connectTwoNode(Node node1, Node node2) {
    if (node1 == null || node2 == null) {
        return;
    }
    /**** 前序遍历位置 ****/
    // 将传入的两个节点连接
    node1.next = node2;

    // 连接相同父节点的两个子节点
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // 连接跨越父节点的两个子节点
    connectTwoNode(node1.right, node2.left);
}
```

![image](http://note.youdao.com/yws/res/34325/C7A4455175FC4C74B211DAA38386E373)

## 二、递归构建二叉树
#### 构造最大二叉树 q654
 - 提示：类似快排
 - 重点：前序构建
 - 方案：
    1. 递归base case，low>right
    2. 找到数组最大数，创建作为root节点
    3. 递归left和right，不断定位left中的最大值和right中的最大值
        - 范围与快排一样left为(0,maxIndex-1)，right(maxIndex+1,right)
    4. 返回root节点

#### 从前中序序列遍历构建二叉树 q105
 - 理念：从"前序列"可知parent节点，从"中序列"可知左右子树的范围
    - "前序列"左子树始终是第一个序列(但无法知道右边界)，但右子树则需要从"中序列"中推算出(无法知道左边界)
 - 重点：同上的q654，变动：
    1. root节点由max改为前序序列的第一个节点
    2. 需要同时维护前序与中序的范围
 - 方案：前序构建
    1. 递归base case，preLeft>preRight
    2. preorder[preLeft]作为root节点
    3. 找到root节点位于inorder中的位置inIndex，以确定范围
    4. 递归left和right，范围：
        - left，preorder[preLeft+1,preLeft+(inIndex-inLeft)]，inorder[inLeft,index-1]
        - right，preorder[preLeft+(inIndex-inLeft)+1,preRight]，inorder[index+1,inRight]
    5. 返回root节点

#### 合并二叉树 q617
 - 方案：前序构建
    1. 如root1或root2一方节点为空，直接返回该节点(拆出来)作为新树节点
    2. 否则创建新节点作为新树节点
    3. 递归root的left与right子树

#### 从中后序序列遍历构建二叉树 q106
 - 提示：同q105，只是root节点为postorder的最后一元素
 - 方案：前序构建
    1. 递归left和right，post范围：
        - left，postorder[post,left,postLeft+(inIndex-inLeftSize)-1]
        - right，postorder[post,postLeft+(Index-inLeftSize),postRight-1]

#### 序列化二叉树 剑37
 - 重点：使用队列层序遍历，然后转换为字符串格式。需要注意的最底层叶节点的null不影响反序列化，所以不需要处理。反序列化类似操作
 - 方案：
    - 序列化：使用队列进行层序遍历，将节点转换为字符串
    - 反序列化：同序列化，只是反过来

## 三、递归搜索二叉树
#### 寻找重复的子树 q652
 - 重点：后序
    1. 将子树序列化进行保存
        - 序列化：转换为字符串的形式，节点值转为字符串，null则为'#'
    2. 使用后缀遍历，自底向上，保存每颗子树至HashMap
 - 方案：
    - 后缀法
    1. 初始化记录子树的容器HashMap<子树序列号，重复数> memo，结果List<TreeNode> res
        - 设为全局变量，因为要存于递归函数之外
    2. 序列化当前子树，查找是否存在重复，存在则加到res
    3. 将当前子树序列化添加到容器

![image](http://note.youdao.com/yws/res/34610/9B175E7CF09A40F5B1CB7E2237AB8F3A)

#### 二叉树寻找最近公共祖先 q236
 - 方案：后序
    1. 如果left和right同时为null。则不存在
    2. 如果left或right任一为null，而另一不为null。则说明来自同一子树，以高的为父节点
    3. 如果left或right均不为null，则说明来自同一子树。则以高的值的父节点为最近祖先

#### 二叉树的最大深度 q104
 - 方案：后序
    1. 比较每个节点的深度，取最大深度

#### 二叉树的最小深度 q111
 - 提示：同q104
 - 重点：后序
    1. 为叶节点或单边节点则提前返回
    2. 每个节点的深度中取最小

#### 对称二叉树 q101
 - 方案：前序遍历
    1. 判断左子树.val是否等于右子树.val
    2. 判断左子树与右子树的子节点是否对称

#### 路径总和 q112
 - 重点：使用给定的sum值，不断递归减去当前节点，当为叶节点时，判断是否等于sum 
 - 方案：前序
    1. 判断是否为叶节点，是则判断叶节点的值是否等于sum
    2. 左递归传入sum-当前节点.val || 右递归传入sum-当前节点.val

#### 平衡二叉树 q110
 - 重点：比较左右深度是否大于1，当任一子树到达叶节点，而另一子树非叶继续递归时，前者的深度值保持不变，而后者则继续加大，最终超过1
 - 方案：后序
    1. 判断left-right的绝对值是否>1，是则false
    2. 返回当前最大深度Math.max(left, right) + 1

#### 二叉树的直径 q653
 - 重点：题意是求最大深度与第二大深度之和
 - 方案：后序
    1. 定义一个全局变量，动态保存两深度之和中的最大的那个
    2. 返回左右子树中最大的深度Math.max(left, right) + 1

#### 左叶子之和 q404
 - 方案：前序
    1. 设定一个全局变量用于累加左叶子节点
    2. 判断如为左叶子节点则进行累加
        1. root.left&&root.right均为null
        2. 左叶子节点则在递归调用时代入参数，如cal(root.left, true)

#### 另一树的子树 q572
 - 方案：
    - 序列化
    1. 序列化目标子树
    2. 递归序列化原子树，进行比较
    - 双层递归(暴力)
    1. 第一层递归，将所有节点放入第二次递归进行判断
    2. 第二次递归，将传入的节点进行比对
        1. 比对A树节点与B树节点的值是否相等或均为null，则符合true
        2. 或者A或B一方节点为null则不符合false

#### 树的子结构 剑26
 - 提示：类似q572，双层递归，但子树与子结构不同：
    1. 子树包含下面叶节点；子结构可以不包含叶节点
    2. 空树是任一树的子树；空树不是任意一个树的子结构

#### 二叉树中第二小的节点 q671
 - 题意：树为特殊的树，即可存在重复的节点值，子节点数只能为2或0
 - 方案：后序
    1. 只有左右字节点相等才需要递归，则进行剪枝
    2. 当左右子节点相等，而进行递归时：
        1. 所有节点相等，则当所有递归到达叶节点，返回-1
        2. 一边子树的所有节点相等或为叶节点，则直接返回另一节点
            1. 另一节点叶为-1，即等同于(1)
            2. 另一节点不为-1，则说明为倒数第二小子节点
        3. 两边子树都存在大于根节点的值，取最小值即为倒数第二小子节点。同时由于进行了剪枝，所以不会往下递归

#### 匹配某段路径总和 q437
 - 重点：前缀和+前序+后序
    - 前缀和：用于保存路径之和
    - 前序：用于累计前缀和，并匹配目标
    - 后序：更新前缀和容器，防止前一子树影响后一子树

#### 最大同值路径 q687
 - 重点：后序
 - 方案：
    1. 后序遍历
    2. 保存的是left与right子树的最长同值路径
    3. 进行条件判断，判断当前节点是否满足条件，并保存值
    4. 动态保存当前树的最大同值路径
    5. 递归返回，返回当前子树的最大同值的一边，从而继续向上节点链接

##### 如图，红圈的节点为了继续向上链接，需要舍弃一边(1的那边)，才能向上连成直径
![image](http://note.youdao.com/yws/res/35906/202006074FF543C992F1B81DCECBC547)

####

## 四、层序遍历二叉树
#### 从上至下打印二叉树1与2 剑32
 - 重点：使用queue实现
 - 方案：
    1. 初始化队列queue，结果res
    2. 先放入root节点至队列queue
    3. while循环queue不为空
        - . for循环，i=queue.size()，i>0，i--
            1. 出队节点node，将node数据存入临时容器level
            2. 将node的left与right入队
        5. 将level存入res
    4. 返回res

#### 从上至下打印二叉树3 剑32
 - 重点：在1的基础上把保存节点数的List变LintedList双端队列。通过res.size判断奇偶层

#### 二叉树中和为某一值得路径 面34
 - 重点：target递减，最后为target为零且为叶节点，则条件满足
 - 方案：前序+回溯
    1. path使用linkedList，这样可以指定删除最后一个元素
    2. 保存path的时候需要深拷贝

#### 完全二叉树的节点数量 q222
 - 重点：判断(子)树是否为满二叉树，满二叉树可直接套公式计算节点数量
 - 方案：
    - 增加满二叉逻辑代码
    1. 计算root左右节点的高
        1. 如相等则直接套用公式
        2. 否则按普通二叉树累加