## 一、字典树(前缀树/Trie)
 - 字典树是一种数据结构
 - 核心思想是用空间换时间，利用字符串的公共前缀来降低查询的时间开销。

![image](http://note.youdao.com/yws/res/37523/683FCB8500A949F7839F16DC71A6FAF2)
![image](http://note.youdao.com/yws/res/37544/205DF13166574601A9244AE9F772BFCF)

### 应用
 1. 输入自动补全
 2. 拼写检查
 3. IP 路由 (最长前缀匹配)
 4. T9 (九宫格) 打字预测
 5. 单词游戏

### 核心API
 - insert(word)：插入一个单词
 - search(word)：查找一个单词是否存在
 - startWith(word)：查找是否存在以word为前缀的单词
 - delete：操作比较麻烦，一般Trie建立起来后不会有删除操作

### 节点存储结构
 - preCount：以当前节点作为前缀的串数量
 - count：以当前节点作为结尾的串数量
 - children[]：存放下一个字符节点的children数组

```
private class TrieNode {
    //以该节点作为结尾的单词/串的个数
    int count;
    //以该节点作为前缀的单词/串的个数
    int preCount;
    TrieNode[] children;
    TrieNode() {
        children = new TrieNode[26];
        count = 0;
        preCount = 0;
    }
}
```

### 插入
 - 插入每个字符：如不存在该字符的节点则插入，存在则不变，指针指向该字符的节点

```
//插入单词API void
public void insert(String word) {
    TrieNode node = root;
    //循环插入单词/串的每个字符
    for (int i = 0; i < word.length(); i++) {
        //如不存再word[i]字符，则插入。指针node指向word[i]字符的节点
        if (node.children[word.charAt(i) - 'a'] == null)
            node.children[word.charAt(i) - 'a'] = new TrieNode();
        node = node.children[word.charAt(i) - 'a'];
        //以该字符为前缀的单词/串+1
        node.preCount++;
    }
    //以该字符为结尾的单词/串+1
    node.count++;
}
```

### 查询
 - 查询单词的每个字符，最后一个字符count>0说明单词存在，返回true
```
//搜索单词API boolean
public boolean search(String word) {
    TrieNode node = root;
    //循环查找单词的每个字符，node作为游标
    for (int i = 0; i < word.length(); i++) {
        if (node.children[word.charAt(i) - 'a'] == null)
            return false;
        node = node.children[word.charAt(i) - 'a'];
    }
    return node.count > 0;
}
```
### 查询某前缀的单词
 - 查询前缀的每个字符，最后一个字符preCount>0说明前缀存在，返回true
 - 不同于查询单词，此查询只要求存在前缀即可(而不是作为单词尾字符)

```
//查找是否存在以prefix为前缀的单词 boolean
public boolean startsWith(String prefix) {
    TrieNode node = root;
    //循环查找单词的每个字符，node作为游标
    for (int i = 0; i < prefix.length(); i++) {
        if (node.children[prefix.charAt(i) - 'a'] == null)
            return false;
        node = node.children[prefix.charAt(i) - 'a'];
    }
    return node.preCount > 0;
}
```

### 完整版
```
public class Trie {
    //根节点
    TrieNode root;

    //初始化根节点
    public Trie() {
        root = new TrieNode();
    }

    //插入单词API void
    public void insert(String word) {
        TrieNode node = root;
        //循环插入单词/串的每个字符
        for (int i = 0; i < word.length(); i++) {
            //如不存再word[i]字符，则插入。指针node指向word[i]字符的节点
            if (node.children[word.charAt(i) - 'a'] == null)
                node.children[word.charAt(i) - 'a'] = new TrieNode();
            node = node.children[word.charAt(i) - 'a'];
            //以该字符为前缀的单词/串+1
            node.preCount++;
        }
        //以该字符为结尾的单词/串+1
        node.count++;
    }

    //搜索单词API boolean
    public boolean search(String word) {
        TrieNode node = root;
        //循环查找单词的每个字符，node作为游标
        for (int i = 0; i < word.length(); i++) {
            if (node.children[word.charAt(i) - 'a'] == null)
                return false;
            node = node.children[word.charAt(i) - 'a'];
        }
        return node.count > 0;
    }

    //查找是否存在以prefix为前缀的单词 boolean
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        //循环查找单词的每个字符，node作为游标
        for (int i = 0; i < prefix.length(); i++) {
            if (node.children[prefix.charAt(i) - 'a'] == null)
                return false;
            node = node.children[prefix.charAt(i) - 'a'];
        }
        return node.preCount > 0;
    }

    private class TrieNode {
        //以该节点作为结尾的单词/串的个数
        int count;
        //以该节点作为前缀的单词/串的个数
        int preCount;
        //存在子节点的数组
        TrieNode[] children;
        TrieNode() {
            //26个字母
            children = new TrieNode[26];
            count = 0;
            preCount = 0;
        }
    }
}
```

## 二、拓展——中文前缀树
 - 将children换成Map<Character, TrieNode>
    - 对应<字符，子节点地址>

```
public class Trie2 {
    //根节点
    TrieNode root;

    //初始化根节点
    public Trie2() {
        root = new TrieNode();
    }

    //插入单词API void
    public void insert(String word) {
        TrieNode node = root;
        //循环插入单词/串的每个字符
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (!node.children.containsKey(c)) {
                TrieNode cNode = new TrieNode();
                node.children.put(c, cNode);
            }
            node = node.children.get(c);
            //以该字符为前缀的单词/串+1
            node.preCount++;
        }
        //以该字符为结尾的单词/串+1
        node.count++;
    }

    //搜索单词API boolean
    public boolean search(String word) {
        TrieNode node = root;
        //循环查找单词的每个字符，node作为游标
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (!node.children.containsKey(c))
                return false;
            node = node.children.get(c);
        }
        return node.count > 0;
    }

    //查找是否存在以prefix为前缀的单词 boolean
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        //循环查找单词的每个字符，node作为游标
        for (int i = 0; i < prefix.length(); i++) {
            char c = prefix.charAt(i);
            if (!node.children.containsKey(c))
                return false;
            node = node.children.get(c);
        }
        return node.preCount > 0;
    }

    private class TrieNode {
        //以该节点作为结尾的单词/串的个数
        int count;
        //以该节点作为前缀的单词/串的个数
        int preCount;
        //存在子节点的数组
        Map<Character, TrieNode> children;

        TrieNode() {
            children = new HashMap<>();
            count = 0;
            preCount = 0;
        }
    }
}
```
