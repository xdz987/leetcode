## 一、排列、组合、子集相关问题
### (一)排列
#### 全排列 q46
- 方案：
    1. 初始化used布尔数组，下标与nums对应，初始化存储排列的List即track
    2. 结束条件为，决策树深度等于nums深度
        - 即track.len==nums.len
    3. 遍历每个元素
        1. 当该层元素未使用则进行选择
        2. 选择该元素，即track添加改元素，used为true
        3. 回溯
        4. 取消选择该元素，即track末尾删除该元素，used改为false
    4. 返回结果

#### 全排列2 q47
- 重点：
    1. 决策树同层相同的元素则进行剪枝
    2. 为了判断同层相邻元素是否相等，==需先排序==
- 方案：
    - 判断是否为决策树同层：==used[i-1]即上一元素为false==
        - 为true说明是上下层
    - 判断两元素是否相等nums[i]==nums[i-1]

#### 排列序列/第N个排列序列 q60
- 重点：
    1. 排列数量对应叶子节点数量
    2. 第level层的叶节点数量等于(level-1)!
    3. 如果第k位的k从1开始，那么阶乘数组的应当从1开始，同时[0]位置序补1

#### 方法一：回溯-递归版
- 方案：
    1. 初始化化阶乘数组factorials、used数组
    2. 回溯，携带决策树的层数参数，从0开始
        1. basecase res==n则return
        2. 初始化当前层分治的叶节点branchLeafNodeCount的数量为factorials[n-1-level]
        3. 已经使用过的数字continue
        4. branchLeafNodeCount<k，说明在下一层，k-=branchLeafNodeCount然后continue
        5. 否则res.append(i)，used为true
        6. 进入回溯递归level+1
        7. 到此说明出发了basecase直接返回res

#### 方法二：回溯-迭代版
- 方案
    1. 初始化阶乘数组、used数组、结果res
    2. 外层循环：遍历决策树每一层，i为由n-1到0
        - 当前层的叶节点数等于阶乘数组[i]
    3. 内存循环：遍历每个元素
        1. 判断当前元素是否使用过
        2. 判断当前分治叶子节点数量是否>k
            1. 是则说明在下一个分治，k-=当前分治叶子节点数量
            2. 否则追加到res，used为true，break跳到下一层
    4. 返回结果res
- 重点：
    1. ==确定1~n有多少个叶节点，即阶乘==
    2. ==根据决策树每层的阶乘值，找到k位于的子树，即遍历k-=count==

##### 重点代码
```
//获取该层最后的阶乘，即叶节点数
int branchLeafNodeCount = factorials[i];
//查找属于哪颗子树，通过递减k实现
if (branchLeafNodeCount < k) {
    k -= branchLeafNodeCount;
    continue;
}
```
#### 方法三：模拟链表
- 方案：
    1. 初始化阶乘数组、1~n数组nums、结果res
    2. k作为下标需-1
    3. 模拟遍历决策树的每一层，n-1~0
        1. 计算得出k位于index位置的分支为k/factorials[i](即当前层各分治的叶节点数)
        2. res添加对应元素，并从nums数组总删除
        3. k-=index*factorials[i]进入下一层

#### 复原ip地址 q93 【特殊题】
- 与其他排列题不同点：每一层的决策会因为上一层的决策而不同
    1. 如2152，可分割为215.2、21.52、2.152，而每个作为节点都将影响其子节点的可选决策
    2. 每个子节点作为决策存在着限制
        1. 如为0则不能以0开头。只能是0.0.0.0，不能是255.025
        2. 节点不能大于255
- 重点：以前一层不同的终点作为后一层的起点
- 方案：
    - 辅助函数：判断截取的字符串len>1不能以以0开头，转换为数字必须在0~255的范围
    1. s的长度不再4~12则直接返回
    2. 回溯，传递分割的次数和新决策层的起点
        1. basecase判断起点是等于len。是则判断分割的次数是否0即分割完成，是则添加该ip地址。返回
        2. 遍历i为起点start到start+3
            1. i>=len说明到了结尾直接break
            2. 剪枝：剩下的字符凑不够剩下的个分段或者剩下的字符凑满分段（最多为3个字符如255）还有剩余。则continue
            3. 尝试分割，start到i进辅助函数判断是否合法，是则subString放进track，回溯，splitTime-1，start为i+1
    3. 返回res

#### 字符串的排列 剑38【相对特殊题】
- 重点：
    1. ==传递start确定避免元素重复使用==
    2. ==使用HashSet避免重复排列==
    3. ==使用交换字符完成字符串的排列==
- 方案：
    1. 传递start作为回溯循环起点，初始化start=0
    2. 回溯
        1. 当start+1等于s.len添加进res
        2. 设定HashSet存储字符，实现去除重复字符
        3. 遍历[start,n]，当存在字符于set直接continue，否则添加进set，回溯
            - 回溯采用交换i与start实现排列
    3. 返回res

### (二)组合
#### 组合 q77
- 重点：回溯，剪枝为子节点小于父节点
    - ==传递start为i+1==
        - 由于i作为元素值添加进track，所以i从1开始
- 方案：循环从i从start开始，start为1~n，start通过回溯函数传递(i+1)

#### 组合总和 q39
- 重点：回溯，剪枝
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
    - 剪枝2：子节点<=父节点
        - ==传递i作为start==
- 方案：设定初始target于函数参数进行target-candidates[i]运算
    1. 先对candidates进行排序
    2. target==0，添加进res
    3. 循环中target-candidates[i]<0直接break

#### 组合总和2 q40
- 重点：回溯
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
        - target-nums[i]<0，直接break
    - 剪枝2：==子节点下标<父节点下标【实现元素唯一】==
        - start为i+1
    - 剪枝3：==同层相同元素剪枝【实现组合唯一】==
        - 通过判断i>start与否判断是否同层。因为为上下层则i==start
        - i>start同时nums[i]==nums[i-1]

#### 组合总和3 q216
- 重点：
    1. ==传递i+1作为下一层的start，这样能省略已使用的元素==
    2. 当track==k的时候，判断sum是否等于n再加入res

#### 重新安排行程 q332
#### 方案一：回溯
- 重点：
    1. 先对tickets进行按字典顺序小的在前排序
    2. 遍历tickets，找到"JFK"后进行回溯，回溯中ticket终点作为下一次递归的起点

#### 方案二：Hierholzer
- 重点：使用map存储tickets，终点采用优先队列存储(按字典顺序小的优先)
- 方案：
    1. 将机票以map的形式存储
    2. dfs传递"JFK"为起点的机票，联通所有机票
        1. ==循环查找map中的以传递的参数作为起点队列，且队列数量>0。是则dfs该机票终点==
            - ==存在ticket终点没有起点ticket，所以需要先判断key是否存在==
            - ==循环是为了遍历每种可能，有的虽然字典顺序小但不一定能够串遍所有ticket==
        2. 直到不符合条件跳出while，res.add(传进来的参数)
    3. 反转res，return

### (三)子集
#### 子集 q78
#### 方法一：回溯
- 重点：先对nums进行排序
    - 剪枝：子节点<父节点
        - ==传递i+1作为start==

#### 方法二：位运算
- 重点：n个元素的集合的子集刚好对应二进制位0~2^n的位置
    - 因为子集的数量刚好等于2^n(包含空集)
- 方案：
    1. 遍历每个子集，即0~2^n(左闭右开)
        1. 取每个子集与元素位置对应二进制进行与运算，如=3，即001,010,100
        2. 如子集与元素位置对应二进制与运算>0说明为当前子集的元素，放进tmp
        3. 将tmp放进res
    3. 返回res

##### 示意图
![回溯.jpeg](http://note.youdao.com/yws/res/40346/WEBRESOURCEe4c592245057fa413b15e81d2f4764e9)
![位运算.jpeg](http://note.youdao.com/yws/res/40351/WEBRESOURCEecae6f0603e2b7d67702517a1efafb32)

#### 子集2 q90
#### 方法一：回溯
- 重点：相邻元素可剪枝，因为已经运算过了
    - 剪枝1：==元素唯一性，即子节点位置<父节点位置==
    - 剪枝2：==同层元素相同剪枝，即当相邻元素相等并且i不等start则剪枝。i等于start说明为父子节点==
        - ==需对nums先排序==

#### 方法二：位运算
- 重点：同q78，增加剪枝，相邻元素相等并且1的前面为0则跳过【待学位运算再理解】

![image](http://note.youdao.com/yws/res/40394/C6BC0F83E12B438C86F489747B906785)

## 二、Flood Fill
### (一)DFS
#### 图形渲染 q733
- 【二维矩阵方向查找】
- 重点：==DFS给定坐标的四个方向，不越界或者为oldColor改为newColor并继续DFS==
    - 注意：先判断oldColor等于newColor与否，是直接返回

### (二)回溯
#### 单词搜索 q79
- 【二维矩阵方向回溯】
- 重点：遍历方向，符合继续走，不符合回溯，满足一个即到达一次页节点直接退出回溯返回true
- 方案：
    1. 遍历二维数组查找word[0]即查找起点，找到起点后回溯，携带next=0
    2. 回溯
        1. 查找的字符不等于目标字符返回false
        2. ==next=len-1说明找到，直接返回true==
        3. 开始查找
            1. 查找的字符设为已使用
            2. 遍历四个方向，先判断是否该方向是否越界再遍历方向，为true说明找到了return true跳出回溯
            3. 到此说明走不同，该层字符设为未使用，返回false

## 三、字符串中的回溯问题
### (一)元组全排列
#### 电话号码中的字母组合 q17
- 【元组全排列】
- 方案：
    1. 初始化键盘
    2. 回溯
        1. 达到排列长度放进res
        2. 决策树遍历，以每个'按键数字'对应的字母作为【选择列表】
        3. ==多叉树遍历，传递digitIndex+1指向下一个'按键数字'==

### (二)指定字符子集
#### 字母大小写全排列 q784
- 方案：
    1. 添加空集
    2. 回溯
        1. 遍历决策树每层，即遍历每个字符
        2. 如果字符是字母，则转换该字符大小写并添加进res
        3. ==回溯，传递i+1作为start修改回去==
    3. 返回res

##### 大小写转换
```
sArr[i]^=32;
sArr[i]^=32;
```

### (三)其他
#### 括号生成 q22【特殊题】
- 重点：括号的规律
    1. 起点必须是左括号
    2. ==剩余左括号数量<=剩余右括号数量，否则括号不符合规律==
- 方案：
    1. 回溯，传递n作为左括号与右括号的数量
        - 也可传递0然后正数也可，只需要能够计数左右括号数量是否为n
        1. 剩余左括号数量>剩余右括号数量，不符合括号规律return
        2. 判断left剩余是否>0，是则track追加'('，回溯
        3. 判断right剩余是否>0，是则track追加')'，回溯
    2. 返回res

#### 分割回文串 q131
#### 方法一：回溯
- 重点：如"aab",则决策树第一层为"","a","aa","aab"，终点为叶节点等于s.length
- 方案：
    - 辅助函数：判断字符串的某范围是否是回文子串(闭区间)
    1. 回溯，传递0作为遍历起点
        1. 当start==n时添加进res并return
        2. 以start作为i，i~n，判断start~i是否为回文子串，不是则continue
        3. 是则添加该子串进res
        4. 递归传递i+1作为start
        5. 回溯
    2. return res
- ==截取字符数组的方式是起点+字符数：String(char[],startIndex,charCount);==

## 四、游戏问题
### (一)二维矩阵
#### N皇后 q51
- 【二维矩阵遍历回溯】
- 方案：
    - N皇后辅助函数：传进来的位置中列、左上方、右上方是否存在'Q'，是false，否则ture
    1. 初始化棋盘char[][]chessboard全部填'.'
    2. ==回溯，以当前row作为回溯的层级/路径==
        1. 当row等于n时，将当前棋盘添加进res
        2. 遍历每列即每个棋位
            1. 判断该棋位是否合法，即辅助函数
            2. 将该棋子改为'Q'
            3. 回溯
            4. 将该棋子改为'.'

#### 解数独 q37
- 【二维矩阵遍历回溯】
- 重点：==到了决策树的叶节点就直接返回==，毕竟数独答案只有一种解
- 方案：
    - 辅助函数：在[row][col]插入num是否合法。行或列不存在此数字，所在小矩阵也不存在此数字，则返回true
        - ==访问九宫格任意三宫格方法为(row或col/3)*3，作为起点，终点+3即可访问任意三宫格==
    - 回溯：
    1. 遍历决策树每条【路径】
    2. 遍历决策树【选择列表】
        1. 如果为空白则充数字，则尝试1~9进行填充，满足条件则回溯
            1. ==调用辅助函数判断填充合法，则回溯==
            2. 回溯结果为true，该路径是合法的，无需填充回'.'，否则填充回'.'
        2. 9个数字都尝遍都没有回溯结果为true的直接返回false，尝试另一【路径】

