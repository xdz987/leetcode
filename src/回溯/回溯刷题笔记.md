## 一、排列、组合、子集相关问题
### (一)排列
#### 全排列 q46
- 方案：
    1. 初始化used布尔数组，下标与nums对应，初始化存储排列的List即track
    2. 结束条件为，决策树深度等于nums深度
        - 即track.len==nums.len
    3. 遍历每个元素
        1. 当该层元素未使用则进行选择
        2. 选择该元素，即track添加改元素，used为true
        3. 回溯
        4. 取消选择该元素，即track末尾删除该元素，used改为false
    4. 返回结果

#### 全排列2 q47
- 重点：
    1. 决策树同层相同的元素则进行剪枝
    2. 为了判断同层相邻元素是否相等，需先排序
- 方案：
    - 判断是否为决策树同层：used[i-1]即上一元素为false
        - 为true说明是上下层
    - 判断两元素是否相等nums[i]==nums[i-1]

#### 排列序列 q60
- 重点：
    1. 排列数量对应叶子节点数量
    2. 第level层的叶节点数量等于(level-1)!
    3. 如果第k位的k从1开始，那么阶乘数组的应当从1开始，同时[0]位置序补1

#### 方法一：回溯-递归版
- 方案：
    1. 初始化化阶乘数组factorials、used数组
    2. 回溯，携带决策树的层数参数，从0开始
        1. basecase res==n则return
        2. 初始化当前层分治的叶节点branchLeafNodeCount的数量为factorials[n-1-level]
        3. 已经使用过的数字continue
        4. branchLeafNodeCount<k，说明在下一层，k-=branchLeafNodeCount然后continue
        5. 否则res.append(i)，used为true
        6. 进入回溯递归level+1
        7. 到此说明出发了basecase直接返回res

#### 方法二：回溯-迭代版
- 方案
    1. 初始化阶乘数组、used数组、结果res
    2. 外层循环：遍历决策树每一层，i为由n-1到0
        - 当前层的叶节点数等于阶乘数组[i]
    3. 内存循环：遍历每个元素
        1. 判断当前元素是否使用过
        2. 判断当前分治叶子节点数量是否>k
            1. 是则说明在下一个分治，k-=当前分治叶子节点数量
            2. 否则追加到res，used为true，break跳到下一层
    4. 返回结果res

#### 方法三：模拟链表
- 方案：
    1. 初始化阶乘数组、1~n数组nums、结果res
    2. k作为下标需-1
    3. 模拟遍历决策树的每一层，n-1~0
        1. 计算得出k位于index位置的分支为k/factorials[i](即当前层各分治的叶节点数)
        2. res添加对应元素，并从nums数组总删除
        3. k-=index*factorials[i]进入下一层

### (二)组合
#### 组合 q77
- 重点：回溯，剪枝为子节点小于父节点
    - start为i+1
- 方案：循环从i从start开始，start为1~n，start通过回溯函数传递(i+1)

#### 组合总和 q39
- 重点：回溯，剪枝
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
    - 剪枝2：子节点<=父节点
        - 传递i作为start
- 方案：设定初始target于函数参数进行target-candidates[i]运算
    1. target==0，添加进res
    2. 循环中target-candidates[i]<0直接break

#### 组合总和2 q40
- 重点：回溯
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
        - target-nums[i]<0，直接break
    - 剪枝2：子节点下标<父节点下标
        - start为i+1
    - 剪枝3：同层相同元素剪枝
        - 通过判断i>start与否判断是否同层。因为为上下层则i==start
        - i>start同时nums[i]==nums[i-1]

### (三)子集
#### 子集 q78
#### 方法一：回溯
- 重点：先对nums进行排序
    - 剪枝：子节点<父节点
        - 传递i+1作为start

#### 方法二：位运算
- 重点：n个元素的集合的子集刚好对应二进制位0~2^n的位置
    - 因为子集的数量刚好等于2^n(包含空集)
- 方案：
    1. 遍历每个子集，即0~2^n(左闭右开)
        1. 取每个子集与元素位置对应二进制进行与运算，如=3，即001,010,100
        2. 如子集与元素位置对应二进制与运算>0说明为当前子集的元素，放进tmp
        3. 将tmp放进res
    3. 返回res

##### 示意图
![回溯.jpeg](http://note.youdao.com/yws/res/40346/WEBRESOURCEe4c592245057fa413b15e81d2f4764e9)
![位运算.jpeg](http://note.youdao.com/yws/res/40351/WEBRESOURCEecae6f0603e2b7d67702517a1efafb32)

#### 子集2 q90
#### 方法一：回溯
- 重点：相邻元素可剪枝，因为已经运算过了
    - 剪枝1：子节点位置<父节点位置
    - 剪枝2：当相邻元素相等并且i不等start则剪枝。i等于start说明为父子节点
        - 需对nums先排序

#### 方法二：位运算
- 重点：同q78，增加剪枝，相邻元素相等并且1的前面为0则跳过【待学位运算再理解】

![image](http://note.youdao.com/yws/res/40394/C6BC0F83E12B438C86F489747B906785)

## 二、Flood Fill

## 三、字符串中的回溯问题

## 四、游戏问题