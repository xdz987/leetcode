## 一、排列、组合、子集相关问题
### (一)排列
#### 全排列 q46
- 方案：
    1. 初始化used布尔数组，下标与nums对应，初始化存储排列的List即track
    2. 结束条件为，决策树深度等于nums深度
        - 即track.len==nums.len
    3. 遍历每个元素
        1. 当该层元素未使用则进行选择
        2. 选择该元素，即track添加改元素，used为true
        3. 回溯
        4. 取消选择该元素，即track末尾删除该元素，used改为false
    4. 返回结果

#### 全排列2 q47
- 重点：
    1. 决策树同层相同的元素则进行剪枝
    2. 为了判断同层相邻元素是否相等，需先排序
- 方案：
    - 判断是否为决策树同层：used[i-1]即上一元素为false
        - 为true说明是上下层
    - 判断两元素是否相等nums[i]==nums[i-1]

#### 排列序列 q60
- 重点：
    1. 排列数量对应叶子节点数量
    2. 第level层的叶节点数量等于(level-1)!
    3. 如果第k位的k从1开始，那么阶乘数组的应当从1开始，同时[0]位置序补1

#### 方法一：回溯-递归版
- 方案：
    1. 初始化化阶乘数组factorials、used数组
    2. 回溯，携带决策树的层数参数，从0开始
        1. basecase res==n则return
        2. 初始化当前层分治的叶节点branchLeafNodeCount的数量为factorials[n-1-level]
        3. 已经使用过的数字continue
        4. branchLeafNodeCount<k，说明在下一层，k-=branchLeafNodeCount然后continue
        5. 否则res.append(i)，used为true
        6. 进入回溯递归level+1
        7. 到此说明出发了basecase直接返回res

#### 方法二：回溯-迭代版
- 方案
    1. 初始化阶乘数组、used数组、结果res
    2. 外层循环：遍历决策树每一层，i为由n-1到0
        - 当前层的叶节点数等于阶乘数组[i]
    3. 内存循环：遍历每个元素
        1. 判断当前元素是否使用过
        2. 判断当前分治叶子节点数量是否>k
            1. 是则说明在下一个分治，k-=当前分治叶子节点数量
            2. 否则追加到res，used为true，break跳到下一层
    4. 返回结果res

#### 方法三：模拟链表
- 方案：
    1. 初始化阶乘数组、1~n数组nums、结果res
    2. k作为下标需-1
    3. 模拟遍历决策树的每一层，n-1~0
        1. 计算得出k位于index位置的分支为k/factorials[i](即当前层各分治的叶节点数)
        2. res添加对应元素，并从nums数组总删除
        3. k-=index*factorials[i]进入下一层

#### 复原ip地址 q93 【特殊题】
- 与其他排列题不同点：每一层的决策会因为上一层的决策而不同
    1. 如2152，可分割为215.2、21.52、2.152，而每个作为节点都将影响其子节点的可选决策
    2. 每个子节点作为决策存在着限制
        1. 如为0则不能以0开头。只能是0.0.0.0，不能是255.025
        2. 节点不能大于255
- 重点：以前一层不同的终点作为后一层的起点
- 方案：
    - 辅助函数：判断截取的字符串len>1不能以以0开头，转换为数字必须在0~255的范围
    1. s的长度不再4~12则直接返回
    2. 回溯，传递分割的次数和新决策层的起点
        1. basecase判断起点是等于len。是则判断分割的次数是否0即分割完成，是则添加该ip地址。返回
        2. 遍历i为起点start到start+3
            1. i>=len说明到了结尾直接break
            2. 剪枝：剩下的字符凑不够剩下的个分段或者剩下的字符凑满分段（最多为3个字符如255）还有剩余。则continue
            3. 尝试分割，start到i进辅助函数判断是否合法，是则subString放进track，回溯，splitTime-1，start为i+1
    3. 返回res

### (二)组合
#### 组合 q77
- 重点：回溯，剪枝为子节点小于父节点
    - start为i+1
- 方案：循环从i从start开始，start为1~n，start通过回溯函数传递(i+1)

#### 组合总和 q39
- 重点：回溯，剪枝
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
    - 剪枝2：子节点<=父节点
        - 传递i作为start
- 方案：设定初始target于函数参数进行target-candidates[i]运算
    1. target==0，添加进res
    2. 循环中target-candidates[i]<0直接break

#### 组合总和2 q40
- 重点：回溯
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
        - target-nums[i]<0，直接break
    - 剪枝2：子节点下标<父节点下标
        - start为i+1
    - 剪枝3：同层相同元素剪枝
        - 通过判断i>start与否判断是否同层。因为为上下层则i==start
        - i>start同时nums[i]==nums[i-1]

### (三)子集
#### 子集 q78
#### 方法一：回溯
- 重点：先对nums进行排序
    - 剪枝：子节点<父节点
        - 传递i+1作为start

#### 方法二：位运算
- 重点：n个元素的集合的子集刚好对应二进制位0~2^n的位置
    - 因为子集的数量刚好等于2^n(包含空集)
- 方案：
    1. 遍历每个子集，即0~2^n(左闭右开)
        1. 取每个子集与元素位置对应二进制进行与运算，如=3，即001,010,100
        2. 如子集与元素位置对应二进制与运算>0说明为当前子集的元素，放进tmp
        3. 将tmp放进res
    3. 返回res

##### 示意图
![回溯.jpeg](http://note.youdao.com/yws/res/40346/WEBRESOURCEe4c592245057fa413b15e81d2f4764e9)
![位运算.jpeg](http://note.youdao.com/yws/res/40351/WEBRESOURCEecae6f0603e2b7d67702517a1efafb32)

#### 子集2 q90
#### 方法一：回溯
- 重点：相邻元素可剪枝，因为已经运算过了
    - 剪枝1：子节点位置<父节点位置
    - 剪枝2：当相邻元素相等并且i不等start则剪枝。i等于start说明为父子节点
        - 需对nums先排序

#### 方法二：位运算
- 重点：同q78，增加剪枝，相邻元素相等并且1的前面为0则跳过【待学位运算再理解】

![image](http://note.youdao.com/yws/res/40394/C6BC0F83E12B438C86F489747B906785)

## 二、Flood Fill
#### 图形渲染 q733
- 重点：DFS给定坐标的四个方向，不越界或者为oldColor改为newColor并继续DFS
    - 注意：先判断oldColor等于newColor与否，是直接返回


## 三、字符串中的回溯问题

## 四、游戏问题
### (一)二维矩阵
#### N皇后 q51
- 方案：
    - N皇后辅助函数：传进来的位置中列、左上方、右上方是否存在'Q'，是false，否则ture
    1. 初始化棋盘char[][]chessboard全部填'.'
    2. 回溯，以当前row作为回溯的层级/路径
        1. 当row等于n时，将当前棋盘添加进res
        2. 遍历每列即每个棋位
            1. 判断该棋位是否合法，即辅助函数
            2. 将该棋子改为'Q'
            3. 回溯
            4. 将该棋子改为'.'

#### 解数独 q37
- 重点：到了决策树的叶节点就直接返回，毕竟数独答案只有一种解
- 方案：
    - 辅助函数：在[row][col]插入num是否合法。行或列不存在此数字，所在小矩阵也不存在此数字，则返回true
        - 访问九宫格任意三宫格方法为(row或col/3)*3，作为起点，终点+3即可访问任意三宫格
    - 回溯：
    1. 遍历决策树每条【路径】
    2. 遍历决策树【选择列表】
        1. 如果为空白则充数字，则尝试1~9进行填充，满足条件则回溯
            1. 调用辅助函数判断填充合法，则回溯
            2. 回溯结果为true，该路径是合法的，无需填充回'.'，否则填充回'.'
        2. 9个数字都尝遍都没有回溯结果为true的直接返回false，尝试另一【路径】

