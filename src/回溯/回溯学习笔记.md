## 回溯
### (一)什么是回溯
- 解决一个回溯问题，实际上就是一个决策树的遍历过程。是一种走不通就回头的算法，本质是穷举所有可能，然后尽可能进行剪枝。
- 回溯算法就是纯暴力穷举，复杂度一般都很高

#### 名词解释
- 路径：已经做出的选择
- 选择列表：也就是当前可以做的选择
    - 通常回溯的元素是多个，所以采用一个for循环遍历所有元素，其本质与二维图形遍历四个方向是相同的。只是遍历四个方向是固定的，所以不需要for循环
- 结束条件：到达决策树底层，无法再做选择的条件
    - 决策树：【多叉树】，每个节点上其实都在做决策
    - 决策树的叶子节点即为目标

### (二)做题步骤
1. 先画树形图
    - 画图能帮助我们想清楚递归结构，想清楚如何剪枝
2. 分治是如何产生的/决策树是怎么工作的
3. 题目的解在哪里
    - 叶子节点？
    - 非叶子节点？
    - 根节点到叶子节点？
4. 哪些搜索会产生不需要的解的？
    - 产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝
5. 剪枝的条件是什么，代码怎么写？

### (三)回溯思想
#### 回溯算法框架
```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

#### 多叉树遍历框架
```
void traverse(TreeNode root) {
    for (TreeNode child : root.childern)
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
}
```
![image](http://note.youdao.com/yws/res/40026/DDFB1AF16F9B46E99F59FF91EE4603E4)
![image](http://note.youdao.com/yws/res/40029/DA2E6095EB58493EBF14227DB96ADF41)

### 回溯与DFS的区别：
#### 第一次理解
- 回溯：强调回退操作对于搜索的合理性。
- DFS：强调一种遍历的思想

#### 第二次理解：回溯就是DFS的优化版，DFS
- 回溯的关键步骤或者说特点，就是设定一个track集合跟踪路径，当走不通或者走到叶节点的时候，触发basecase返回，然后track删除该层的节点值还原track，继续走其他路径
- DFS可以通过回溯进行修改，就是每一层都深拷贝一个修改后的track作为参数继续深入，这样触发basecase后不需要删除该层节点直接结束即可。
- **结论**
    1. 【DFS比回溯更具适用性】。但是每层的深拷贝相比耗费时间与空间，特别是二维数组或者对象数组，在这种情况下，需要循环数组的每个对象一个个深拷贝传递给下一层节点。
        - 当传递的参数需要在原数据上修改时、遍历的是二叉树、链表时
    2. 【回溯比DFS具有更高性能】。只需要管理一个track，触发basecase等返回只需要删除该层节点元素即可，时间与空间上更高效。
        - 这点尤其随着数据量的提高越明显
    3. 当回溯与DFS没有任何剪枝，每个节点都需要进行保存，那么回溯与DFS性能是差不多的，因为深拷贝的次数相同。但大部分是回溯多次剪枝后的深拷贝数量比DFS要少的多，DFS在达到basecase或剪枝前必定深拷贝

##### 证明【回溯比DFS具有更高性能】例题：N皇后
- DFS
    - 深拷贝整个二维数组向下传递

![image](http://note.youdao.com/yws/res/40917/117127D770FB42E89B017C5FA549D115)
![image](http://note.youdao.com/yws/res/40915/3D0602693DF04C9CA032BB6BEBDB1803)

- 回溯
    - 修改二维数组中的一个点，达到目标时深拷贝结果

![image](https://note.youdao.com/src/6E99459C69DB4BE2AA66346730FCAD73)
![image](https://note.youdao.com/src/C61428898A5C488C9A83EABDBB714915)

#### 回溯与DP的区别：
- 相同点：
1. 求解一个问题分为很多步骤（阶段）
2. 每一个步骤（阶段）可以有多种选择
- 不同点
1. DP只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求
2. 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。
3. DP要求可以访问到当前之前的所有最优解结果，进而推出当前的最优结果。但回溯要么设定一个全局变量进行控制，但大部分情况下只能访问当前层和前后层的节点。

## 一、排列、组合、子集相关问题
### (一)基本思想
#### 排列：每个元素只能使用一次，排列所有可能
- 判断是否使用过，所以用used数组
1. 元素不重复
    - 排列种类为n!
2. 元素重复，先对数组进行排序，通过判断相邻节点是否相等得出

#### 组合：使用列表里的元素进行组合，达到某个target（比如相加为某数值）
- 不用used数组，传递start(即i+1)，因为重复使用，所以同左节点会涵盖右节点的操作
    - 形成类似321,21,1的形式
1. 元素可重复使用
2. 元素不可重复使用

#### 子集：使用列表的元素进行组合，组合的元素之间无序，即123与321与213为同一子集
- 同组合，传递i+1
    - 因为子集就是321,21,21
- 由于是子集，所以从根节点到每层的路径都要记录
    - 方法是添加节点到track的时候就添加路径到res
1. 元素不重复
    - 子集的数量刚好等于2^n(包含空集)
        - 刚好与二进制位对应，所以也可以使用位运算得出所有子集

![回溯.jpeg](http://note.youdao.com/yws/res/40346/WEBRESOURCEe4c592245057fa413b15e81d2f4764e9)
![位运算.jpeg](https://note.youdao.com/src/WEBRESOURCEecae6f0603e2b7d67702517a1efafb32)
2. 元素重复

#### 例q46：全排列
- 其中[2]就是「路径」，记录你已经做过的选择
- [1,3] 就是「选择列表」，表示你当前可以做出的选择
- 「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候

![image](http://note.youdao.com/yws/res/40015/9915D68D9B934A8BA1BEB6E5A539DFDC)
![image](https://note.youdao.com/src/D9326C4D8E6E42D3AA8799B3218EE012)

### (二)剪枝实现
#### 1. 排列
1. 同层相同元素剪枝 q47
    - 【元素可重复】
    - 判断相等，再通过used数组判断是否同层
2. 多剪枝：只回溯一条目标排列 q60
    - 【元素不可重复】
    1. 塑造阶乘数组，表示决策树的各层分支的叶子节点数（叶子节点数对应全排列的数量即n!）
    2. 通过k与当前层分支叶子节点数比较，k<leafNodeCount说明就是该分治，否则k-=child，进行下一个分治的判断，找到后添加改元素进入决策树下一层
3. 特殊题：满足题目要求合法性并剪枝
    - 特殊性：
    1. 【元素无所谓重复性】
    2. 合法性：len>1不为0且范围在0~255
    3. 父节点的终点作为子节点的起点：如1152为1.152/11.52/115.2
    4. basecase终点由start决定，即start=len即遍历所有字符才return，而添加进res的条件也是必须splitTime分割完
    - 剪枝：
    1. 当前分剩的字符大于待分割次数*3(最多为255即3个字符)
        - 如字符数剩2个，还需分3个分段，肯定不够
    2. 剩下的字符凑不够剩下的个分段
        - 如字符数剩7个，还需分2个分段，多了一个字符

#### 2. 组合
1. 剪枝子节点位置<父节点位置 q77
    - 【元素不可重复使用】
    - 传递i+1作为start
2. 多剪枝 q39
    - 【元素可重复使用】
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
    - 剪枝2：子节点<=父节点
        - 传递i作为start
3. 多剪枝 q40
    - 【元素不可重复使用】
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
    - 剪枝2：子节点下标<父节点下标
    - 剪枝3：同层相同元素剪枝
        - 可以不需要used，通过判断i>start与否判断是否同层。因为上下层的化i==start

#### 3. 子集
1. 剪枝子节点位置<父节点位置 q78
    - 【元素不重复】
    - 传递i+1作为start
2. 多剪枝 q90
    - 【元素可重复】
    - 剪枝1：子节点位置<父节点位置
    - 剪枝2：当相邻元素相等并且i不等start则剪枝。i等于start说明为父子节点
        - 需对nums先排序

## 二、Flood Fill
- 泛洪填充
    - 例如点一下打开一大片没有雷的区域

### (一)DFS
- 【二维矩阵方向查找】
- 思想：【根节点】是满足条件字符，然后以该字符四个方向作为【选择列表】，对进行选择的每个字符进行操作(如填充为其他字符)
    - 当然方向不能越界、还需满足条件
    - 也可类比【子集】，只是不需要记录路径
- 例：岛屿数量、图形渲染

### (二)回溯
- 【二维矩阵方向回溯】
- 思想：与【一维元素集合】型回溯不同点：
    1. 【根节点】是满足条件字符，然后以该字符四个方向作为【选择列表】，找到最后一个字符即为【叶节点】
        - 当然方向不能越界、还需满足条件、未使用过
    2. 当方向的字符不满足条件，需要回溯设字符为未访问
        - 可采用特殊字符填充，如保存字符tmp，然后设为'.'，恢复赋值为tmp
- 例：单词搜索

## 三、字符串中的回溯问题
- 特点：使用StringBuilder作为List使用

### (一)元组全排列
- 【元组全排列】
- 思想：同【一维元素集合】全排列相同，只是由一个字符换成一组字符(即元组)为单位。
    - 回溯中传递指针，指向下一个元组，而不需要used数组
- 例：九字键盘的组合

### (二)指定字符子集
- 【指定字符子集】
- 思想：同【子集】相同，只是子集存在着需要无视的特殊字符
    - 与子集思路完全相同，只是在回溯过程中直接跳过特殊字符。同时不需要track跟踪路径，直接将原字符数组拷贝一份放入res即可
- 例：字母大小写全排列

## 四、游戏问题
### (一)二维矩阵
#### 棋盘落子——N皇后
- 【二维矩阵遍历回溯】
- 思想：以每行作为决策树的【路径】，每列作为【选择列表】，【结束条件】为走到棋盘底部即row==n
- 回溯中【是否选择该路径】即N皇后的下棋规则

#### 解数独
- 【二维矩阵遍历回溯】
- 思想：
    1. 数独只有一个解，所以到达一次叶节点即返回。
    2. 遍历决策树的所有路径所有选择列表，但为空白并合法的填充数字后进行回溯，如果回溯结果为true，则无需填充为'.'了

