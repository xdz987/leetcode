## 回溯
### (一)什么是回溯
- 解决一个回溯问题，实际上就是一个决策树的遍历过程。是一种走不通就回头的算法，本质是穷举所有可能，然后尽可能进行剪枝。
1. 路径：已经做出的选择
2. 选择列表：也就是当前可以做的选择
3. 结束条件：到达决策树底层，无法再做选择的条件
    - 决策树：【多叉树】，每个节点上其实都在做决策
- 回溯算法就是纯暴力穷举，复杂度一般都很高

### (二)做题步骤
1. 先画树形图
    - 画图能帮助我们想清楚递归结构，想清楚如何剪枝
2. 分治是如何产生的/决策树是怎么工作的
3. 题目的解在哪里
    - 叶子节点？
    - 非叶子节点？
    - 根节点到叶子节点？
4. 哪些搜索会产生不需要的解的？
    - 产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝
5. 剪枝的条件是什么，代码怎么写？

### (三)回溯思想
#### 回溯算法框架
```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

#### 多叉树遍历框架
```
void traverse(TreeNode root) {
    for (TreeNode child : root.childern)
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
}
```
![image](http://note.youdao.com/yws/res/40026/DDFB1AF16F9B46E99F59FF91EE4603E4)
![image](http://note.youdao.com/yws/res/40029/DA2E6095EB58493EBF14227DB96ADF41)

#### 回溯与DFS的区别：
- 回溯：强调回退操作对于搜索的合理性。
- DFS：强调一种遍历的思想

#### 回溯与DP的区别：
- 相同点：
1. 求解一个问题分为很多步骤（阶段）
2. 每一个步骤（阶段）可以有多种选择
- 不同点
1. DP只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求，最优解对应的具体解是什么并不要求
2. 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。

## 一、排列、组合、子集相关问题
### (一)基本思想
#### 排列：每个元素只能使用一次，排列所有可能
- 判断是否使用过，所以用used数组
1. 元素不重复
    - 排列种类为n!
2. 元素重复，先对数组进行排序，通过判断相邻节点是否相等得出

#### 组合：使用列表里的元素进行组合，达到某个target（比如相加为某数值）
- 不用used数组，传递start(即i+1)，因为重复使用，所以同左节点会涵盖右节点的操作
    - 形成类似321,21,1的形式
1. 元素可重复使用
2. 元素不可重复使用

#### 子集：使用列表的元素进行组合，组合的元素之间无序，即123与321与213为同一子集
- 同组合，传递start
    - 因为子集就是321,21,21
- 由于是子集，所以从根节点到每层的路径都要记录
    - 方法是添加节点到track的时候就添加路径到res
1. 元素不重复
    - 子集的数量刚好等于2^n(包含空集)
        - 刚好与二进制位对应，所以也可以使用位运算得出所有子集

![回溯.jpeg](http://note.youdao.com/yws/res/40346/WEBRESOURCEe4c592245057fa413b15e81d2f4764e9)
![位运算.jpeg](https://note.youdao.com/src/WEBRESOURCEecae6f0603e2b7d67702517a1efafb32)
2. 元素重复

#### 例q46：全排列
- 其中[2]就是「路径」，记录你已经做过的选择
- [1,3] 就是「选择列表」，表示你当前可以做出的选择
- 「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候

![image](http://note.youdao.com/yws/res/40015/9915D68D9B934A8BA1BEB6E5A539DFDC)
![image](https://note.youdao.com/src/D9326C4D8E6E42D3AA8799B3218EE012)

### (二)剪枝实现
#### 1. 排列
1. 同层相同元素剪枝 q47
    - 【元素可重复】
    - 判断相等，再通过used数组判断是否同层
2. 多剪枝：只回溯一条目标排列 q60
    - 【元素不可重复】
    1. 塑造阶乘数组，表示决策树的各层分支的叶子节点数（叶子节点数对应全排列的数量即n!）
    2. 通过k与当前层分支叶子节点数比较，k<leafNodeCount说明就是该分治，否则k-=child，进行下一个分治的判断，找到后添加改元素进入决策树下一层
3. 特殊题：满足题目要求合法性并剪枝
    - 特殊性：
    1. 【元素无所谓重复性】
    2. 合法性：len>1不为0且范围在0~255
    3. 父节点的终点作为子节点的起点：如1152为1.152/11.52/115.2
    4. basecase终点由start决定，即start=len即遍历所有字符才return，而添加进res的条件也是必须splitTime分割完
    - 剪枝：
    1. 当前分剩的字符大于待分割次数*3(最多为255即3个字符)
        - 如字符数剩2个，还需分3个分段，肯定不够
    2. 剩下的字符凑不够剩下的个分段
        - 如字符数剩7个，还需分2个分段，多了一个字符

#### 2. 组合
1. 剪枝子节点位置<父节点位置 q77
    - 【元素不可重复使用】
    - 传递i+1作为start
2. 多剪枝 q39
    - 【元素可重复使用】
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
    - 剪枝2：子节点<=父节点
        - 传递i作为start
3. 多剪枝 q40
    - 【元素不可重复使用】
    - 剪枝1：同层节点当前元素已经不满足target，那么右边元素直接跳过
    - 剪枝2：子节点下标<父节点下标
    - 剪枝3：同层相同元素剪枝
        - 可以不需要used，通过判断i>start与否判断是否同层。因为上下层的化i==start

#### 3. 子集
1. 剪枝子节点位置<父节点位置 q78
    - 【元素不重复】
    - 传递i+1作为start
2. 多剪枝 q90
    - 【元素可重复】
    - 剪枝1：子节点位置<父节点位置
    - 剪枝2：当相邻元素相等并且i不等start则剪枝。i等于start说明为父子节点
        - 需对nums先排序

## 二、Flood Fill
- 泛洪填充
    - 例如点一下打开一大片没有雷的区域
- 思想：就是DFS，该类型的题也可以使用并查集
    - 经典题的DFS写法在学并查集的时候顺便也写了，这里不都赘述

## 三、字符串中的回溯问题

## 四、游戏问题
### (一)二维矩阵
#### 棋盘落子——N皇后
- 【二维矩阵查找类】
- 思想：以每行作为决策树的【路径】，每列作为【选择列表】，【结束条件】为走到棋盘底部即row==n
- 回溯中【是否选择该路径】即N皇后的下棋规则

#### 解熟读
- 【二维矩阵查找类】
- 思想：
    1. 数独只有一个解，所以到达一次叶节点即返回。
    2. 遍历决策树的所有路径所有选择列表，但为空白并合法的填充数字后进行回溯，如果回溯结果为true，则无需填充为'.'了

