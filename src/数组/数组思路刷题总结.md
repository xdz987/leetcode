## 数组思路刷题总结
#### 区域与检索 q303 设计
- ==重点：要求一次实例化 多次调用==
- 题解：
    1. ==全局保存前缀和==
    2. 当left为0时，直接返回pre[right]
    3. 否则取pre[right]-pre[left-1]

#### 托普利茨矩阵 q766 找规律
#### 方法一：线性遍历比较
- ==题解：遍历比较[i][j]与[i+1][j+1]，不相等直接返回false==

#### 方法二：以行遍历比较
- ==重点：每条对角线相等=>行或列均成相等规则==
- ==题解：上下行比较==

##### 如图，此类矩阵存在以下性质
![image](https://note.youdao.com/yws/res/30409/E0857B829B57418090547DFDC6DDDF36)

#### 重塑矩阵 q566 数学
#### 方法一：计算下标
- ==重点：将不同长宽的矩阵进行重新赋值==
- ==方案：判断长x宽是否相等==
    - ==第x个 / 新宽 ==>行坐标==
    - ==第x个 % 新宽 ==>纵坐标==

#### 方法二：判断下标
- ==题解：==
    - 当长*宽不相等时，直接返回 原矩阵
    1. 初始化cI、rI对应新矩阵存储下标
    2. ==当cI==c时，cI设为0，rI指向下一行==

#### 数组的度 q697
#### 方法一：哈希表
- ==题解：使用哈希表记录元素出现的次数、第一次出现位置、最后一次出现位置==
    1. ==遍历元素，更新哈希表，保存最大出现次数==
    2. ==遍历哈希表，当出现次数为最大时，保存min(res，元素最后一次出现位置-第一次出现位置)==

#### 错误的集合 q645
#### 方法一：标记法
- O(N) O(N)
- ==题解：==
    1. ==标元素是否访问过，是则说明该元素重复。设元素为已访问==
    2. ==遍历标记数组，找到未标记过的下标，即为消失的数字==

#### q667 找规律 构建法
- 重点：数组相邻差值
- 方案：前面元素直接构建符合k个相邻不同差值的数，后面元素直接填充
    1. [|a1-a2|,|a2-a3|,...]，可发现1~n个数中，最多可得相邻不同差值数量为n-1个
    2. 填充规则为，由于为绝对值，k个值由大至小为**k~1**
        - [1,k,2,k-1,3,k-4,...,k/2,k/2-1]
        - 即k/2个升序放奇数位置 与 k/2个降序放偶数位
        - **注意数组下标从0开始**
    3. 填充第k+1位置往后所有数，值为k+1+1开始到n，PS：原先|1-(k+1)|才能到k的最大值

##### 规律如下
```
当n = 50， k = 20时：
[1,21,2,20,3,19,4,18,5,17,6,16,7,15,8,14,9,13,10,12,11,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
当n = 50，k = 17时：
[1,18,2,17,3,16,4,15,5,14,6,13,7,12,8,11,9,10,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
```

#### q565 数组嵌套 标记法
- 重点：构成嵌套环的每个元素的路径是相同的，而最长路径也相同
- 方案：
    - 暴力法
        1. 循环每个元素，以每个元素为起点进行深入嵌套并计数
        2. 当循环到元素值等于起点元素则终止
        3. 保存计数最大的值
    - 标记法1：优化暴力法，**增加标记数组**
        - 在步骤2中增加visited数组，已访问的设为true
    - 标记法2：优化暴力法，**已访标记于原数组**
        - 在步骤2中设定已访问的元素位为一个标记值(Integer.MAX_VALUE)

### q769 找规律 数组分割
- 重点：第i个元素等于前i个元素最大值，则说明到此的元素可分割
    - 排序只能发生在切完的块内，同时块的位置无法改变
- 方案：
    1. 设定一个变量不断的保存到i为止的最大值
    2. 循环判断i是否等于该最大值，等于则说明到此为可分割，累计

### q240 升序矩阵 减而治之
- 重点：升序矩阵
- 方案：
    - 暴力法：遍历矩阵
    - 二分法：每行或列都采用二分查找，或同时采用
    - 减而治之：
        1. 从左下或右上出发，逐渐查找目标值
            - 只能左下或右上，因为此角往反方向遍历时，行或列的递增或递减为相反，这样才可以减少遍历

- 比较：
    1. 区别于q378，q378的矩阵二分查找是通过 累计小于mid的数量与第k小及位置进行比较，从而得出第k小位于哪一边，最后的查找结果是该位置的值是多少
    2. 而q240，则是根据值来查找是否存在于矩阵

### 数组中的重复数字 剑03
#### 方法一：Set
- 略

#### 方法二：交换法
- 重点：根据题意数组的值不大于下标值
- 方案：
    1. 遍历所有元素
    2. while当前值是否与下标相等，不相等则
        1. 判断下标的值是否等于以该值为下标的值，相等则说明是重复值。nums[i]==nums[nums[i]]
        2. 否则进行交换：
            - 如[2]=6,[6]=8，变成[2]=8,[6]=6

### 顺时针打印矩阵 剑29
#### 方法一：边界法
- 重点：设定上下左右四个边界，控制元素的遍历以顺时针的方式遍历
- 方案：
    1. 初始化
        - 设定left,top为0，right,bottom为length-1，
        - 初始化一位数组下标计数器
    2. 判断是否到边界的方法是
        1. 左到右：left<=right,++
        - 判断上到下边界：++top>bottom则break;
        2. 上到下：top<=bottom,i++
        - 判断右到左边界：--right<left则break;
        3. 右到左，right>=left,i---
        - 判断下到上边界：--bottom<top则break;
        4. 下到上，bottom>=top,i--
        - 判断左到右边界：++left>right则break;
    3. 返回结果

### 第一个只出现一次的字符
#### 方法一：intMap
- 方案：第一次遍历s使用intMap统计字符频率，第二遍历s找到第一个频率为1的字符即可

