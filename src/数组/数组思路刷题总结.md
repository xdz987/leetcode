## 数组思路刷题总结
#### 区域与检索 q303 设计
- ==重点：要求一次实例化 多次调用==
- 题解：
    1. ==全局保存前缀和==
    2. 当left为0时，直接返回pre[right]
    3. 否则取pre[right]-pre[left-1]

#### 托普利茨矩阵 q766 找规律
#### 方法一：线性遍历比较
- ==题解：遍历比较[i][j]与[i+1][j+1]，不相等直接返回false==

#### 方法二：以行遍历比较
- ==重点：每条对角线相等=>行或列均成相等规则==
- ==题解：上下行比较==

##### 如图，此类矩阵存在以下性质
![image](https://note.youdao.com/yws/res/30409/E0857B829B57418090547DFDC6DDDF36)

#### 重塑矩阵 q566 数学
#### 方法一：计算下标
- ==重点：将不同长宽的矩阵进行重新赋值==
- ==方案：判断长x宽是否相等==
    - ==第x个 / 新宽 ==>行坐标==
    - ==第x个 % 新宽 ==>纵坐标==

#### 方法二：判断下标
- ==题解：==
    - 当长*宽不相等时，直接返回 原矩阵
    1. 初始化cI、rI对应新矩阵存储下标
    2. ==当cI==c时，cI设为0，rI指向下一行==

#### 数组的度 q697
#### 方法一：哈希表
- ==题解：使用哈希表记录元素出现的次数、第一次出现位置、最后一次出现位置==
    1. ==遍历元素，更新哈希表，保存最大出现次数==
    2. ==遍历哈希表，当出现次数为最大时，保存min(res，元素最后一次出现位置-第一次出现位置)==

#### 错误的集合 q645
#### 方法一：标记法
- O(N) O(N)
- ==题解：==
    1. ==标元素是否访问过，是则说明该元素重复。设元素为已访问==
    2. ==遍历标记数组，找到未标记过的下标，即为消失的数字==

#### 优美的排序2 q667 找规律 构建法
- ==题解：前k元素构建为两个相方向的等差数列，后面元素直接填充==
    - ==找规律：两个相反方向的等差数列，可组成1-n不同整数。==
        - ==实现k以内的两个交叉的等差数列，一个递增一个递减。直到K后直接填充==
        - ==如k=5,n=10。16253478910==
- 方案：
    1. [|a1-a2|,|a2-a3|,...]，可发现1~n个数中，最多可得相邻不同差值数量为n-1个
    2. 填充规则为，由于为绝对值，k个值由大至小为**k~1**
        - [1,k,2,k-1,3,k-4,...,k/2,k/2-1]
        - 即k/2个升序放奇数位置 与 k/2个降序放偶数位
        - **注意数组下标从0开始**
    3. 填充第k+1位置往后所有数，值为k+1+1开始到n，PS：原先|1-(k+1)|才能到k的最大值

##### 规律如下
```
奇数：1~k/2
偶数：k/2~1

当n = 50， k = 20时：
[1,21,2,20,3,19,4,18,5,17,6,16,7,15,8,14,9,13,10,12,11,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
当n = 50，k = 17时：
[1,18,2,17,3,16,4,15,5,14,6,13,7,12,8,11,9,10,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
```

#### 数组嵌套 q565
#### 方法一：快慢指针+剪枝
- ==思路：以每个元素为起点，通过快慢指针查找到环，并记录环的长度，保存最大值。==
- ==剪枝：==
    1. ==当环的长度>n/2时，必定为最长的环长度。==
    2. ==已经访问过的元素，不需要重新设为起点再访问环，因为一个环内的任意起点结果相同。使用标记数组实现。==
- 题解：
    - ==辅助函数：快慢指针，找到以i为起点的环的长度，访问过的元素设为true==
    1. 初始化visited数组
    2. 遍历数组，当未访问过，以元素下标查找环
    3. ==查找到环的长度>n/2时，break==

### 最多能完成排序的块 q769 找规律
- ==思路：==
    - ==规律：如max=max(x~i)，那么分割点即为i=max时，这样才符合【当前块的最大值】小于【下一块的最大值】，符合排序规则==
        - ==其中x表示块的起点（遍历过的i）==
- ==题解：第i个元素等于前i个元素最大值，则说明到此的元素可分割==
    1. ==设定一个从左到右的动态最大值max==
    2. ==当下标等于max时，说明可分割为块，res累加==
    3. ==返回res==

### 搜索二维矩阵2 q240 减而治之
- ==思路：由于行和列升序的性质。查找需要从【左下】或【右上】出发。原因是，在[i][j]与target比较时，才可以选择是增大还是减小，而只有左下和右上符合==
    - ==左上是同时递增，右下是同时递减
- 题解：假定出发点选左下，遍历矩阵==
    1. ==当[i][j]==target，返回true==
    2. ==当[i][j]>target，减小值，即i--==
    3. ==当[i][j]<target，增大值，即j++==

#### 方法二：二分法
- 每行或列都采用二分查找，或同时采用
- 略

##### 比较：
1. 区别于q378，q378的矩阵二分查找是通过 累计小于mid的数量与第k小及位置进行比较，从而得出第k小位于哪一边，最后的查找结果是该位置的值是多少
2. 而q240，则是根据值来查找是否存在于矩阵

### 数组中的重复数字 剑03
#### 方法一：intMap
- O(N) O(N) 时间优先
- 注意：由于题目限制了元素值<n，所以可以使用intMap
- ==题解：统计数字频率，当频率>1时返回数字==

#### 方法二：排序
- O(OlogN) O(1) 空间优先

#### 方法三：交换法
- ==前提：根据题意，元素值<n，所以交换不会导致数组越界问题==
- ==抽屉原理：当元素对应下标存放时，会导致值重复而无法交换==
- ==题解：将【值】与【以值为下标】的值进行交换，相等时即为重复元素==
    1. 遍历所有元素
        - 值不等于下标，【值】与【以值为下标】交换
        - 相等说明为重复值，返回值
        - [2]=6,[6]=8，变成[2]=8,[6]=6

### 顺时针打印矩阵 剑29
#### 方法一：边界法
- ==思路：设定上下左右四个边界，控制元素的遍历以顺时针的方式遍历，使用四个循环实现：==
    - ==左到右：top(行)不变，left到right==
    - ==上到下：right(列)不变，top到bottom==
    - ==右到左：bottom(行)不变，right到Left==
    - ==下到上：left(列)不变，bottom到top==
- 方案：
    1. 初始化
        - 设定left,top为0，right,bottom为length-1，
        - 初始化一位数组下标计数器
    2. 判断是否到边界的方法是
        1. 左到右：left<=right,++
        - 判断上到下边界：++top>bottom则break;
        2. 上到下：top<=bottom,i++
        - 判断右到左边界：--right<left则break;
        3. 右到左，right>=left,i---
        - 判断下到上边界：--bottom<top则break;
        4. 下到上，bottom>=top,i--
        - 判断左到右边界：++left>right则break;
    3. 返回结果

### 第一个只出现一次的字符 剑50
#### 方法一：intMap
- ==题解：==
    1. ==遍历s，使用intMap统计字符频率==
    2. ==遍历s，找到频率为1的字符返回==
    3. 不存在频率为1的字符返回' '

