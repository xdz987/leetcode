## 数组tag总结
### q303 设计
- 重点：要求一次实例化 多次调用
  - 即要求尽可能的节省运行时间
- 方案：实例化时就进行计算并存储结果

### q766 找规律
- 重点：每条对角线相等=>行或列均成相等规则
- 上下行比较

##### 如图，此类矩阵存在以下性质
![image](E0857B829B57418090547DFDC6DDDF36)

### q566 重塑矩阵
- 重点：将不同长宽的矩阵进行重新赋值
- 方案：判断长x宽是否相等
  - 第x个 / 新宽 ==>行坐标
  - 第x个 % 新宽 ==>纵坐标

### q283 双指针
- 重点：实际0元素可以不移动留到最后填充
- 方案：双指针。指针1判断数组元素是否为0元素，指针2将非0元素向左覆盖，最后填充数组右边为0
- 移动≠“移动操作”

### q697 集合中元素出现次数
- 重点：容器复合使用
- 方案：
  1. 三个map，分别元素key及对应存储度、第一次出现位置、最后一次出现位置
  2. 一个map+数组，存储元素key，而数组前三位赋予度、第一次出现位置、最后一次出现位置的存储意义

### q485 "双指针"
- 重点：动态更新变量 临时最大值+计数器
- 方案：循环中，动态保存当前最大连续1的值+当前连续1的计数器

### q645 数组去重
- 重点：两个重复数但其索引下标不同
- 方案：
  - 额外数组
  1. 使用一个额外数组，以原数组元素作为索引判定是否为重复，查到重复的数
  2. 再循环额外数组，通过查0(形式)找到其索引值，索引即为丢失的值(因为元素为1~n且数组的长度为n)

### q287 数组去重 抽屉原理 二分查找
- 方案：
  - 同q645额外数组
    - 时O(n) 空O(n)
  - 二分查找+抽屉原理
    - 时O(nlogn) 空O(1)

### q378 矩阵二分查找
- 重点：(1)注意是位置值还是元素值(2)有序矩阵可存在重复数
  - 注意是查第k位置的数字，而不是查数字k
- 方案：利用有序矩阵的性质：行列升序
  1. left为左上，right为右下，取mid
  2. 从左下到右上与中间数比较，调整横纵坐标，始终定位到mid位于列的位置，而该位置的上方则都是小mid数(累加给数字作为确定k位置的依据)
  3. 累加数量小于k，说明在左上，反之在右下
  4. 最后left即为第k位置的数字

##### 如图，从左下到右上(行升序)，实际为查找mid位于列的位置(列升序)
![image](AC888FC0BB3340859EAB16C42FA1ECE4)

### q667 找规律 构建法
- 重点：数组相邻差值
- 方案：前面元素直接构建符合k个相邻不同差值的数，后面元素直接填充
  1. [|a1-a2|,|a2-a3|,...]，可发现1~n个数中，最多可得相邻不同差值数量为n-1个
  2. 填充规则为，由于为绝对值，k个值由大至小为**k~1**
    - [1,k,2,k-1,3,k-4,...,k/2,k/2-1]
    - 即k/2个升序放奇数位置 与 k/2个降序放偶数位
    - **注意数组下标从0开始**
  3. 填充第k+1位置往后所有数，值为k+1+1开始到n，PS：原先|1-(k+1)|才能到k的最大值

##### 规律如下
```
当n = 50， k = 20时：
[1,21,2,20,3,19,4,18,5,17,6,16,7,15,8,14,9,13,10,12,11,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
当n = 50，k = 17时：
[1,18,2,17,3,16,4,15,5,14,6,13,7,12,8,11,9,10,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
```
