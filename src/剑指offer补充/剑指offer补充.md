### 其他题目在学习过程中已经完成
#### 替换空格 剑05
#### 方法一：线性遍历
- O(N) O(N)
- 重点：使用StringBuilder保存结果，将空格替换为%20

#### 机器人的运动范围 剑13
#### 方法一：DFS——泛洪法
- O(NM) O(NM)
- 重点：向四个方向DFS并计数，当越界或者不满足条件时return。同时设visted[][]控制已计数的元素

#### 和为s的连续整数序列 剑57
#### 方法一：滑动窗口
- O(N) O(1)
- 重点：使用left,right指针控制窗口内元素，当满足target时保存

#### 把数字翻译成字符串 剑46
#### 方法一DP——斐波那契问题
- O(N) O(1)
- 状态选择：前一数字+当前数字>26或前一数字为0，则dp[i]=dp[i-1]否则dp[i]=dp[i-1]+dp[i-2]
- 状态压缩：ppre、pre

#### 奇数前偶数后 剑21
#### 方法一：双指针
- 略

#### 限制条件求阶乘 剑64
#### 方法一：递归
- 重点：使用布尔值替代if...else，将递归的basecase放在&&的左边，递归式子放在&&右边

#### 斐波那契数列取模 剑10
#### 方法一：线性遍历
- 重点：两数相加过程中取模，即(a+b)%x

#### 打印从1到最大的n位数 剑17
#### 方法一：线性遍历
- 重点：使用Math.pow或算出最大位置数字。遍历填入数组

#### 合并两个排序的链表 剑25
#### 方法一：线性遍历
- 重点：
  1. 设立新头节点
  2. 设立虚拟节点备份新头节点
  3. 遍历l1和l2，将小的值接入新头节点
  4. 补充遍历l1，将多出的节点插入新头节点
  5. 补充遍历l2，将多出的节点插入新头节点

#### 矩阵中的路径 q12
#### 方法一：回溯——泛洪
- 方案：
  1. 遍历矩阵，查到目标字符串第一个字符，进入回溯
  2. 回溯：
    1. basecase：边界、使用过与否、等于目标字符与否
       2. [x][y]设为已使用
    3. 一个布尔值变量res或运算回溯四个方向
      - 这样当第一个回溯查到值后不会执行另外三个方向
        4. [x][y]设为未使用
    5. 返回 res

#### 扑克牌中的顺子 剑61
#### 方法一：找规律
- 方案：
  1. 排序
  2. 计算joker数量，当有两张牌相等直接返回false(除了joker)
  3. 当最大和最小牌<5时返回true
    - 因为有joker替换

#### 圆圈中最后数字 剑62
#### 方法一：模拟
- 重点：使用ArrayList模拟圆圈删除过程

#### 方法二：数学——约瑟夫环
- 方案：
  1. 遍历[2,n]
  2. 初始化遍历x=0,x=(x+m)%i
  3. 最后x即剩下的第m数

#### 和为s的两个数字 剑57
#### 方法一：哈希表（适合无序）
#### 方法二：指针

#### 将数组排成最小的数 剑45
#### 方法一：快排
- 重点：将数字转换为字符串再比较(a,b)->(ab)>(ba)则交换排序

#### 不用加减乘除左加法 剑65
#### 方法一：位运算
- 重点：
  - 进位：(a&b)<<1;
  - 相加：a^b

#### 减绳子 剑14
#### 方法一：循环取余（找规律）
- 重点：找规律
  - 最好的状态是3*3*3
  - 次好的状态是3*3*2
  - 最差的状态是3*2*2
    - 即当遇到1时1*3换2*2
- 方案：
  1. 边界情况处理：
    1. n<4,返回n-1
    2. n=4,返回n
  2. 初始化保存变量为Long结构
  3. 循环n>4时
    - res*=3,n-=3，为避免越界res%1...7
  4. 返回(res*n)%1..7
    - 此时n<=4

#### n个骰子的点数 剑60
#### 方法一：回溯+哈希表【超时】
- 复杂度：O(6^N)
- 重点：回溯所有可能并记录哈希表，最后计算概率并还原成数组

#### 方法二：DP+找规律
- 复杂度：O(N) O(1)
- DP[x]含义：点数和为x的出现的概率
- DP[x]边界：一个骰子时6个1/6
- 状态选择：当前筛子数量对应点数概率等于前一筛子数量对应-k/6
  - 状态不好，后面再回来理解

#### 构建乘积数组 剑66
#### 方法一：前缀和
- 复杂度：O(N) O(1)
- 方案：
  1. 由于是乘运算，所以所有元素初始值为1
  2. 从前往后前缀和，[0,i-1]赋值给i
  3. 从后往前前缀和，[i,x]赋值给i-1

#### 丑数 剑49
#### 方法一：DP+找规律
- 重点：规律
  1. 设三个指针a,b,c，分别对应着2,3,5的三个位置
  2. 通过dp[a]*2、dp[b]*3、dp[c]*5来控制丑数的值，对应着n2,n3,n5
  3. 找到三者的最小值作为dp[i]的值
  4. 当dp[i]==n2、n3、n5时对应指针++

#### 数值的整数次方 剑16
#### 方法一：快速幂
- 重点：快速幂，从二进制的角度来看就是模仿二进制转十进制的过程
- 方案：
  1. 使用long b替代n避免负数转整数时越界
  2. 当n<0时，x=-x，n=-n
  3. 设res=1
  4. 遍历当b!=0时
    1. 当b%2==1说明从右到左的二进制转十进制遇到了1，res*=x
    2. 否则x*x，就像二进制每往左一位就*2一样,b>>1
  5. 返回res

![image](http://note.youdao.com/yws/res/48408/0EA0F279DEF74146AE3D0BFD937719D4)

#### 逆序对 剑51
#### 方法一：归并排序
- 在合并的过程中，当左元素大于右元素时
  - count+=mid-lIndex+1

#### BST与双向链表 剑36
#### 方法一：递归中序遍历
- 重点：中序遍历，定义pre指针和head指针，在中序遍历中间串联前后实现双链表

#### BST的后序遍历 剑33
#### 方法一：暴力法
- 重点：
  1. 判断每颗子树是否为BST，最差的情况是斜树。BST的左节点一定小于root节点，root节点小于右节点。
  2. 据此找到root节点，当遍历过程中到不了right元素，说明存不符合BST规则的子树，直接返回false。basecase是left>=right说明为一个节点的子树

#### 栈的压入弹出序列 剑31
#### 方法一：模拟
- 方案：
  1. 模拟压栈出栈的过程。当栈顶元素等于要验证的出栈序列左边元素时则出栈，否则持续压栈。
  2. 如果验证的出栈序列可行，那么模拟栈一定为empty，返回stack.empty()即可

#### 1到n中整数中1的次数 剑43
#### 方法一：数位统计
- 重点：公式
  - 初始化
    - cur=n%10
    - low=0
    - digit=1
    - hight=n/10
  1. cur==0
    - res+=high*digit
  2. cur==1
    - res+=high*digit+low+1
  3. 2<=cur<=9
    - res+=(high+1)*digit
  - 更新
    - cur=high%10
    - low+=cur*digit
    - high=n/10
    - digit*=10
