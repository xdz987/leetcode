#### 替换空格 剑05
#### 方法一：线性遍历
- O(N) O(N)
- ==重点：使用StringBuilder保存结果，将空格替换为%20==

#### 机器人的运动范围 剑13
#### 方法一：DFS——泛洪法
- O(NM) O(NM)
- ==重点：向四个方向DFS并计数，当越界或者不满足条件时return。同时设visted[][]控制已计数的元素==

#### 和为s的连续整数序列 剑57
#### 方法一：左右指针
- O(N) O(1)
- ==重点：使用left,right指针指向左右两端，通过sum与target比较，而调整指针，直到满足target==
- 为什么不需要用哈希表？
  - 因为数组有序，无序则需要使用哈希表

#### 把数字翻译成字符串 剑46
#### 方法一：DP——斐波那契问题
- O(N) O(1)
- ==注意：前一数字不能为零才可组成两位数转换的字母==
- 状态选择：
  - ==前后可以组成字母：即前一数字+当前数字<=25且前一数字不为0==
    - dp[i]=dp[i-1]+dp[i-1]
  - ==前后不可以组成字母，如前一数字等于0或>25：==
    - dp[i]=dp[i-1]
- ==状态压缩：ppre、pre==

#### 奇数前偶数后 剑21
#### 方法一：双指针
- ==【q75】颜色分类，三指针题型的简化版==
- 略

#### 限制条件求阶乘 剑64
#### 方法一：与运算替换if...else
- ==重点：使用布尔值与运算替代if...else。==
- ==题解：将递归的basecase放在&&的左边，递归式子放在&&右边==

#### 斐波那契数列取模 剑10
#### 方法一：线性遍历
- ==重点：两数相加过程中取模，即(a+b)%x==

#### 打印从1到最大的n位数 剑17
#### 方法一：线性遍历
- ==重点：使用Math.pow或算出数组长度。遍历填入数组==

#### 合并两个排序的链表 剑25
#### 方法一：线性遍历
- ==题解：==
  1. ==设立新头节点==
  2. ==设立虚拟节点备份新头节点==
  3. ==遍历l1和l2，将小的值接入新头节点==
  4. ==如l1不为空，新偷补充连接l1==
  5. ==如l2不为空，新头补充连接l2==

#### 矩阵中的路径 剑12
#### 方法一：回溯——泛洪
- ==题解：==
  1. ==遍历矩阵，查到目标字符串第一个字符，进入回溯==
  2. ==回溯：==
    1. ==basecase：边界、使用过与否、等于目标字符与否==
       2. [x][y]设为已使用
    3. ==一个布尔值变量res或运算回溯四个方向==
      - 这样当第一个回溯查到值后不会执行另外三个方向
        4. [x][y]设为未使用
    5. 返回 res

#### 扑克牌中的顺子 剑61
#### 方法一：加减计算
- ==题解：==
  1. ==排序==
  2. ==计算joker数量，当有两张牌相等直接返回false(除了joker)==
  3. ==当最大和最小牌<5时返回true==
    - ==既没有牌相等，同时也有有joker替换==

#### 圆圈中最后数字 剑62
#### 方法一：模拟【性能差】
- ==题解：使用ArrayList模拟圆圈删除的过程==
  1. ==将所有元素放入ArrayList==
    - 不能是LinkedList，因为当n数字很大时，LinkedList的删除需要遍历链表。超时
  2. ==按照(m-1)%n找到需要删除的元素，删除之后n--。且以删除后的第二个元素为起点。最后即：==
    - ==(del+m-1)%n==
  3. 返回list.get(0)

#### 方法二：数学——约瑟夫环
- ==约瑟夫环：遍历[2,n]为i，(x+m)%i，最后x即为剩余的元素==
- 题解：
  1. 初始化x=0
  2. 遍历[2,n]为i，执行(x+m)%i
  3. 返回x

#### 将数组排成最小的数 剑45
#### 方法一：快排
- ==重点：将数字转换为字符串进行排序。==
- ==排序规则：(a,b)->(ab)>(ba)交换==

#### 不用加减乘除做加法 剑65
#### 方法一：位运算
- ==思路：==
  - ==a异或b，无进位的求和==
  - ==a与运算b，每一位的进位数==
- 题解：
  1. 循环b!=0
  2. ==使用临时变量c保存(a&b)<<1即进位的结果==
  3. 使用a异或b，将异或结果保存于a
  4. ==b等于临时遍历c==
  5. 最后模拟异或相加，进位

#### 剪绳子 剑14_1
#### 方法一：DP
- ==状态转移公式：dp[n]=max(dp[n],max(i*(i-j),j*dp[i-j])==
- ==状态选择：上一次剪后的最大值乘积、剪成两段、剪成超过两段（即j*dp[i-j]，dp[i-j]意味着至少为两段）==
- ==dp含义：长度为n的绳子剪绳子后的最大乘积为dp[n]==
- ==dp边界：dp[2]=1，最小的情况是绳子为2对半剪后乘积为1==
- 题解：
  1. 当n<4时，返回n-1
    - 只有两个basecase，即2=1和3=2
  2. 初始化边界dp[2]=1
  3. 计算dp数组
    1. 遍历[3,n]为i
    2. 遍历[1,i/2]为j
    3. 状态转移公式计算
  4. 返回dp[n]

#### 方法二：数学
- ==题解：同剑14_2==

#### 剪绳子 剑14_2
- 为什么这题不用DP？
  - ==题目给的范围最高是1000，1000的绳子分割相乘的结果超过了long类型的范围。==
  - 那使用BigInteger？
  - 可以使用，但性能太差，特别是比较方法一

#### 方法一：数学（找规律）
- ==重点：找规律==
  - ==最好的状态是3*3*3==
  - ==次好的状态是3*3*2==
  - 最==差的状态是3*2*2==
    - 即当遇到1时1*3换2*2
- 方案：
  1. ==边界情况处理：==
    1. ==n<4,返回n-1==
    2. ==n=4,返回n==
  2. ==初始化保存变量为Long结构==
  3. 循环n>4时
    - res*=3,n-=3，为避免越界res%1...7
  4. 返回(res*n)%1..7
    - 此时n<=4

#### n个骰子的点数 剑60
#### 方法一：回溯+哈希表【超时】
- 复杂度：O(6^N)
- 重点：回溯所有可能并记录哈希表，最后计算概率并还原成数组

#### 方法二：DP批量赋值
- ==状态转移公式：每增加一个骰子，所有点数概率发生变化==
- ==状态选择：每一层的骰子点数数量为（骰子数量*6-(骰子数量-1)）。越靠近中间的点数概率越高，规律为自最左右端每靠近中间的点数一位，就增加d[j]/6的概率。==
  - 例如：两个他骰子时就不会出现点数为1的情况，所以需要-(骰子数量-1)
- ==dp[i]含义：N个骰子，出现点数点数为i的概率是dp[i]==
- ==dp边界：最小一个骰子，一个骰子有6个点数，即均为1/6==
- 题解：
  1. 初始化dp边界，即dp[6]，fill为1/6.0
  2. 遍历骰子数即[2,n]为i
  3. ==遍历dp点数数量即[0,dp.length]为j。初始化newDp[i*6-(i-1)]==
  4. 遍历骰子面即[0,6)为k
    - ==从0开始是因为j与k在此作为数组下标==
    - ==状态转移公式计算即newDp[j+k]+=dp[j]/6.0==
  5. 更新dp变量为newDp地址，即dp=newDp
  6. 返回dp

#### 构建乘积数组 剑66
#### 方法一：前缀和
- 复杂度：O(N) O(1)
- ==题解：==
  1. ==由于是乘运算，所以所有元素初始值为1。==
    - 或者初始化res[0]=1即可，因为在第一轮前缀和是只有它没有参与计算即为0
  2. ==从前往后前缀和，[0,i-1]赋值给i==
  3. ==从后往前前缀和，[i,x]赋值给i-1==

#### 丑数 剑49
#### 方法一：DP或三指针
- ==状态转移公式：dp[i]=Min(ug2,Min(ug3,ug5))==
- ==状态选择：2，3，5对应的丑数计数为上一个丑数乘以质因子（如质因子3则为dp[ug3]*3）。第i个丑数为三个丑数计算结果中的最小==
- ==dp含义：第i个丑数为dp[i]==
- ==dp边界：最小的丑数为1，也是dp的丑数计算的边界==
- ==题解：==
  1. 初始化p1,p2,p3=0，分别对应质因子为2,3,5的丑数计数器
  2. 遍历第二到第n个丑数进行计算
    1. 计算2,3,5对应的丑数
    2. 状态转移公式
    3. 更新2,3,5对应丑数计数器，更新条件是等于第i个丑数
  3. 返回第n个丑数即dp[n-1]

#### 数值的整数次方 剑16
#### 方法一：快速幂
- ==重点：快速幂，就是将【次方】以二进制的形式看待，当次方对应的位为1时保存乘积X，否则不保存==
  - 如：如18（10010），x一边相乘一边右位移，当为1时x保存进res
- 方案：
  1. ==初始化res=1，使用long b替代n避免负数转整数时越界==
  2. ==当次方为负数时需要做转换==
    1. x=1/x
    2. n=-n
  3. ==当次方n不为0时==
    1. ==n最右位为1时保存进res==
    2. ==x相乘，b右位移==
  4. 返回res

![image](http://note.youdao.com/yws/res/48408/0EA0F279DEF74146AE3D0BFD937719D4)

#### 逆序对 剑51
#### 方法一：归并排序
- ==在合并的过程中，当左元素大于右元素时==
  - ==count+=mid-lIndex+1，因为右边的元素都小于lIndex位的元素==

#### BST与双向链表 剑36
#### 方法一：递归中序遍历
- 重点：中序遍历，定义全局pre指针，使得在中序遍历时串联前后节点，实现双向
- 方案：
  1. 初始化pre、head
  2. 中序遍历开始
  3. ==中序遍历第一次执行时保存链表的头节点，即pre=null时，此时中序正在执行节点cur即为head==
  4. ==将节点转换为双链表，即pre.right指向cur，cur.left指向pre，更新pre为cur==
  5. 中序遍历结束
  5. ==将头节点head与尾结点pre进行头尾相连，即head.left执行pre，pre.right指向head==

#### BST的后序遍历 剑33
#### 方法一：暴力法（遍历判断所有子树）
- ==重点：判断每颗子树是否为BST：左<父，父<右==
- 方案：
  1. 设定p=left
  2. ==遍历nums[p]<nums[right]，满足则p++，找到当前子树root节点==
  3. ==遍历nums[p]>nums[right]，满足则p++，判断是否为BST，如p=right说明符合BST性质，否则说明存在节点不满足BST性质==
    1. 当p=right时，递归左右区间
    2. 当p!=right直接返回false

#### 栈的压入弹出序列 剑31
#### 方法一：模拟
- 方案：
  1. ==模拟压栈出栈的过程。当栈顶元素等于要验证的出栈序列左边元素时则出栈，否则持续压栈。==
  2. ==如果验证的出栈序列可行，那么模拟栈一定为empty，返回stack.empty()即可==

#### 1到n中整数中1的次数 剑43
#### 方法一：数位统计
- ==数位统计：遍历十进制所有位，从右往左，进行统计计算：==
  - 当cur=0时，此时1的出现次数由高位high决定：high*digit
  - 当cur=1时，此时1的出现次数由高位high和低位low决定：high*digit+low+1
  - 当cur>1时，此时1的出现次数由高位high决定：(high+1)*digit
  - 初始化：
    - cur：n%10，对应当前位置，初始化为最右位
    - low：0，低位，即cur右边的数字
    - digit：1，对应着cur当前的位置，1即个位数
    - hight：n/10，对应着高位，初始化即为除了cur之外的左边数
- 重点：公式
  - 初始化
    - cur=n%10
    - low=0
    - digit=1
    - hight=n/10
  1. while判断high!=0或者cur!=0，则进行数位统计
    1. 判定cur
      1. cur==0
        - res+=high*digit
      2. cur==1
        - res+=high*digit+low+1
      3. cur>1
        - res+=(high+1)*digit
    2. 更新
      - cur=high%10
      - low+=cur*digit
      - high=n/10
      - digit*=10
  2. 返回res

