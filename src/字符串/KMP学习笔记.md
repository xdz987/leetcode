### 一、前缀表next/prefix
- 描述：每个元素对应着记录每个字符的前缀相同的数量
- 实现：
    1. 初始化next/prefix数组全为0，即对应着前后缀不相同的情况
    2. 遍历needle字符串
        1. i初始化指向第二个字符，j指向第一个字符
            - i为前缀末尾，j为后缀末尾
        2. 情况一：前后缀不相同的情况。j回退到字符相同的情况，否则一直回退到0，即while(j>0&&s[i]!=s[j])，则j回退j=next[j-1]
        3. 情况二：前后缀相同的情况，j++，即指向下一个字符
        4. 更新next[i]=j;

##### next/prefix数组实现流程例子：
```
 - 例子：
needle：aabaaf
next：  010120

 - 过程：
初始：j=0,i=1

i=0,[a]：没有前缀，所以0
next[000000]

i=1,a[a]：前缀相同，j++即j=1，即next[1]=j
next[010000]

i=2,aa[b]：
 (1)a[a][b]：不相同此时j=1，回退j=next[j-1]即j=next[0]=0
 (2)即next[i]=j=0
next[010000]

i=3,aab[a]：
 (1)[a]ab[a]：此时j=0，不进入while
 (2)[a]ab[a]：if判断相同，j++即j=1，
 (3)next[i]=j=1
next[010100]

i=4,aaba[a]：
(1)a[a]ba[a]：相同不进while
(2)a[a]ba[a]：if判断相同j++即j=2
(3)next[i]=j=2
next[010120]

i=5,aabaa[f]：
 (1)aa[b]aa[f]：不相同此时j=2，回退j=next[j-1]，即j=1
 (2)a[a]baa[f]：不相同此时j=1，回退j=next[j-1]，即j=0不进while
 (3)[a]abaa[f]：if判断不相等j不变，即为next[i]=j=0
next[010120]
```

### 二、查找needle
- 实现：
    1. 遍历原串，初始化i、j指向原串第1个字符
        1. 初始j为字符的前缀
        2. 情况一：当不相同即while(s[i]!=needle[j]&&j>0)时，j指向它的前缀即j=next[j-1]
        2. 情况二：当s[i]==needle[j]时，j++，i++指向下一个字符
        3. 情况三：当j==m说明匹配成功，返回i-m+1，即为匹配成功的起点位置
- 简述：==与求next过程相同，除了以下三点：==
    1. ==i从0开始，i是<n即主串长度==
    2. ==比较变成sArr[i]与needle[j]==
    3. ==将next[i]赋值换成j=m与否，等于返回true==
        - m为查询的子串长度，相等说明查找成功

##### 查找needle流程例子：
```
 - 例子：
str：   aabaabaaf
needle：aabaaf
next：010120

 - 过程：
初始：j=0,i=0

[aabaa]baaf
[aabaa]f
前5个字符均相等，j=5，i=5

aabaa[b]aaf
aabaa[f]
第6个字符不匹配，j指向前缀即j=next[5-1]=next[4]=2

aabaa[b]aaf
aa[b]aaf
指向前缀后发现匹配，j和i继续向前

aabaa[baaf]
aa[baaf]
匹配成功j=6=m，此时i=8，返回i-m+1即8-6+1=3，即needle匹配的位置从3到m+3
```

### 三、KMP的性质
#### 性质一：由重复子串组成
#### 描述：当数组长度-最长相等前后缀的长度正好可以被数组的长度整除，说明有该字符串由重复子字符串拼接而成
- ==公式：next[len-1]!=0&&len%(len-(next[len-1]))=0==
    - ==next[len-1]不为0，因为0%任何数都为0==
    1. 首先next的最后一位不为0
    2. 其次只有全部由重复子串组成时最后取%才为0。
        - 如果由重复子串组成，从第二个重复子串开始j将不断奇数，因为前缀一直相等
- 例题：重复的子字符串q459

##### 性质一例子
```
asdfasdfasdf
000012345678
其中len=12

next[len-1]不为0，因为0%任何数都为0

即：next[12-1]=8
公式：12%(12-8)==0
结论：该字符串全部由子串组成
```
