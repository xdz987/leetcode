### 一、前缀表next/prefix
- 描述：每个元素对应着记录每个字符的前缀相同的数量
- 实现：
    1. 初始化next/prefix数组全为0，即对应着前后缀不相同的情况
    2. 遍历needle字符串
        1. i初始化指向第二个字符，j指向第一个字符
            - i为前缀末尾，j为后缀末尾
        2. 情况一：前后缀不相同的情况。j回退到字符相同的情况，否则一直回退到0，即while(j>0&&s[i]!=s[j])，则j回退j=next[j-1]
        3. 情况二：前后缀相同的情况，j++，即指向下一个字符
        4. 更新next[i]=j;

##### next/prefix数组实现流程例子：
```
 - 例子：
needle：aabaaf
next：  010120

 - 过程：
[a]：没有前缀，所以0
a[a]：前缀相同，j++，所以为j即1
aa[b]：
 (1)a[a][b]：不相同且j=1，回退j=next[j-1]，即j=0
 (2)即next[i]为0
aab[a]：
 (1)aa[b][a]：不相同且j=2，回退j=next[j-1]，即j=1
 (2)a[a]b[a]：相同，j=1，所以位j即为1
aaba[a]：相同，j++，所以为j即2
aabaa[f]：
 (1)aaba[a][f]：不相同且j=2，回退j=next[j-1]，即j=1
 (2)aab[a]a[f]：不相同且j=1，回退j=next[j-1]，即j=0
 (3)aa[b]aa[f]：即为next[i]为0
```

### 二、查找needle
- 实现：
    1. 遍历原串，初始化i、j指向原串第1个字符
        1. 初始j为字符的前缀
        2. 情况一：当不相同即while(s[i]!=needle[j]&&j>0)时，j指向它的前缀即j=next[j-1]
        2. 情况二：当s[i]==needle[j]时，j++，i++指向下一个字符
        3. 情况三：当j==m说明匹配成功，返回i-m+1，即为匹配成功的起点位置

##### 查找needle流程例子：
```
 - 例子：
str：   aabaabaaf
needle：aabaaf
next：010120

 - 过程：
[aabaa]b
[aabaa]f
前5个字符均匹配，j=5，i=5

aabaa[b]
aabaa[f]
第6个字符不匹配，j指向前缀，j=next[j-1]，即j=2
aabaa[b]aaf
aa[b]aaf
指向前缀后发现匹配，j和i继续向前

aabaa[baaf]
aa[baaf]
匹配成功j=6=m，此时i=8，返回i-m+1即8-6+1=3，刚好对应位置
```

### 三、KMP的性质
#### 性质一：由重复子串组成
#### 描述：当数组长度-最长相等前后缀的长度正好可以被数组的长度整除，说明有该字符串有重复的子字符串
- 公式：next[len-1]!=0&&len%(len-(next[len-1]))==0
    1. 首先next的最后一位不为0
    2. 其次只有全部由重复子串组成时最后取%才为0。
        - 如果由重复子串组成，从第二个重复子串开始j将不断奇数，因为前缀一直相等
- 例题：重复的子字符串q459

##### 性质一例子
```
asdfasdfasdf
000012345678
其中len=12

即：next[12-1]=8
公式：12%(12-8)==0
结论：该字符串全部由子串组成
```