- 部分字符串题目在数组、双指针那

## 字符串刷题笔记
### 一、一般题型
- 一般题型：双指针、处理边界

#### 翻转单词顺序 剑58_1
- ==二刷：双指针多此一举。直接线性遍历即可==

#### 方法一：线性遍历
- ==题解：==
    1. ==s.trim()==
    2. ==s.split(" ");==
    3. ==遍历单词，当单词不为空时，倒叙放入StringBuilder==
    4. ==返回结果去掉最后一个字符即空格==

#### 方法二：双指针/模拟法
- 方案：
    1. 初始化sb、双指针。双指针指向s最后一个字符
    2. s.trim()
    2. p1--往回走，直到遇到空格，sb添加(p1,p2+1)单词和空格
    3. p1往回走，遇到空格则p1--，直到不是空格跳出循环
    4. p2=p1
    5. 返回sb.toString.trim();

#### 把字符串转换成整数 剑67
- ==题解：模拟二进制的计算==
    1. ==初始化sb、双指针、carry==
        - ==双指针指向最后一个进制位==
    2. ==当p1>=0时并且b1指向为'1'，则carry++。p2同==
        - ==p1--==
        - ==p2--==
    3. ==最后结果反转==
- 重点：边界处理
- 方案：
    1. 掉空格后长度为0直接返回0
    2. 初始化索引下标、正负符合sign、最值边界/10的bndry、存放结果res
    3. ==正负号处理==
        1. 如为'-'：sign为-1，i从1开始
        2. 如为'+'：sign为1，i从1开始
        3. 如都不是：sign从1开始，i从0开始
    4. ==从i开始遍历每个元素==
        1. ==字符必须是数字==
        2. ==如累加的res超过了int的边界，直接返回最值==
            - ==通过Integer.MAX_VALUE/10进行比较判断==
        3. res累加计算
    5. ==到此说明不是最值，根据sign正负返回值==

#### 反转字符串2 q541
- ==题解：==
    1. ==将s转换为数组，遍历每个字符，i+=2*k==
    2. ==将[i,min(i+k-1,n-1)]内的字符反转==
- 重点：奇数k需要反转
- 方案：
    1. 循环以偶数k作为递增，即start=0，start<length，start += 2 * k
    2. 反转起点i=start，终点j=min(max+k-1,s.length-1)
        - 限制了j不超过字符串长度
        1. 最左最右相互交换实现反转

#### 变为词组 面10.02
#### 方法一：暴力法
- Java：5% 56%
- 复杂度：O(26*n*K) O(n^2) （其中K对应字符串长度）
- 重点：使用int[][]记录每个字符串字符出现的频率，比较是否重复
- 方案：
    1. 遍历strs数组，记录每个字符串的频率。初始化used[]，用于剪枝（已添加进res的不用再比较频率）
    2. 以所有字符串为起点遍历strs数组[0,n)。当used为false，则创建list保存结果
    3. 以i+1为起点遍历strs数组[i+1,n)
    4. 遍历频率，当频率相同时保存进list
    5. 将list保存进res

#### 方法二：排序+哈希表
- Java：96% 56%
- 复杂度：O(nKlogK) O(nKlogK)（其中K对应字符串长度）
- 重点：==对字符串进行字典排序，使得具有相同字母的字符串相等，通过哈希表进行保存==
- 方案：
    1. 初始化哈希表<String,List<String>
    2. 遍历strs数组
    3. ==将str转为char[]再按字典排序，再转回字符串sStr==
    4. 判断map是否存在sStr，不存在则添加ArrayList，将str添加进map对应着key为sStr
    5. 将map转换为list，返回

#### 方法三：计数+哈希表+StringBuilder
- Java：24% 10%
- 复杂度：O(26*K*n)
- 【思路基本同方法二，只是将排序换成频率，哈希表的key：排序结果——>频率结果】

#### 学生出勤记录 q551
- 题解：使用两个变量记录缺勤数或连续迟到记录
    - 遍历字符串：
        - 缺勤数>=2或连续迟到>=3时返回false
        - 否则循环结束返回true

#### 压缩字符串 q443
#### 方法一：StringBuilder
#### 方法二：原地替换

### 二、技巧型题
- intMap、位运算、反转等方式直接解题

#### 最长回文串 q409
#### 方法一：intMap统计
- 题解：
    1. ==统计字母出现次数==
        - 大写小写字母之间存在6位特殊符号，所以intMap[58]
    2. ==能够组成回文的字符必定是偶数位（除了中间的字符），计算偶数部分频率==
- 方案：
    1. 使用intMap[56]称freq存储所有字母出现的频率
        - 52个大小字母，中间还有6位特殊符号
    2. 遍历freq，res+=freq为奇数则-1
    3. 返回如果res<s.len说明存在奇数位字母，res+1，否则说明全部都是偶数位字母，返回res即可

#### 左旋转字符串 剑58_2
- ==题解：==
    1. ==StringBuilder拼接==
    2. ==先append需要旋转字符后的字符==
    3. ==再append需要旋转的字符==

#### 有效字符异位词 q242
#### 方法一：intMap统计
- ==题解：==
    - ==注意：不能使用或运算，因为存在重复字母==
    1. ==统计s和t各字符的频率==
    2. ==判断s和t各字符频率是否相等==

#### 同构字符串 q205
#### 方法一：Map双射
- ==题解：==
    1. ==通过Map存储两单词字符的映射==
    2. ==sMap.get(ss)!=tt或者tMap.get(tt)!=ss说明不同构，返回false==
    3. ==动态更新sMap与tMap==
- 重点：先get再put
    - 即最后一个字符不用put进map也可
    - 能够get到ss/tt，说明保存过/更新过该字符，如果同构那么另一边也【必定】能够get到。否则说明一边未存过或未更新，即不同构
- 方案：
    1. 初始化双Map
    2. 遍历所有字符
    3. 先get判断是否能get到，不为空且能get说明同构
    4. 再put到双map
    4. 到结尾说明同构，返回true

#### 单词规律 290
- ==题解：【同q205同构字符串】==

#### 计数二进制子串 q696
- ==题解：==
    1. ==统计上一重复字符与当前重复字符数量==
        - 如00111，lastSize=2,size=3
    2. ==累加相同数量的次数，即min(lastSize,size)==
- 重点：相邻不同字符重复数量的组合即为Min(a重复次数，b重复次数)
- 方案：
    1. 初始化当前字符次数count为1，lastCount=0
    2. 遍历0~n-1
        1. 当i==i+1时，count++，continue
        2. 否则比较res+=min(count,lastCount)
        3. lastCount=count，size=1
    3. 最后补充res+=min..多一次

#### 回文子串 647
#### 方法一：DSF+回文判定（淘汰）
- 复杂度：O(n^3) O(1)(不算递归)
- 方案：DFS所有字符串按顺序的子串，是否为回文子串，是则+1
    - 判断是否回文子串：左右指针
    - DFS：
        1. 循环，以传递start作为遍历i的起点，终点为len
        2. 判断i~len是否为回文
        3. 循环结束，dfs(start+1)

#### 方法二：中心拓展法
- 复杂度：O(n^2) O(1)
- ==重点：回文子串的中心点存在两种可能即单字符中心和双字符中心==
    - 三字符中心可由单字符中序推导出，以此类推
- 方案：遍历所有中心点
    1. 遍历0~n*2-1
        - 取单字符中心时只需要i/2即可
    2. 中心点left=i/2，right=i/2+(i&1)
        1. 当i为偶数时，中心点left、right为当前字符
        2. 当i为奇数时，中心点left前一字符、right为当前字符
    3. 从left、right向左右拓展
        - left、right不越界
        - [left]=[right]，回文子串数+1
    4. 返回回文子串数

#### 方法三：Manacher算法
- 复杂度：O(n) O(1)
- 略

#### 方法四：DP
- 复杂度：O(n^2) O(n^2)

#### 最长回文子串 q5
#### 方法一：中心拓展法
- ==同647解法，改成动态保存right-left的最大值，最后返回substr(left,right+1)==

### 三、KMP应用
#### 实现strstr q28
- 略

#### 字符串循环位移包含 编程之美
- 重点：位移即原字符串复制多一份，即str=str+str
- 方案：
    1. 当目标字符串target.length>str.length时，直接返回false
        - 不管怎么位移都无法为true
    2. 建立next数组
    3. str=str+str，查找target字符串

#### 重复的子字符串 q459
- ==重点：利用KMP重复子串的性质，如由重复子串组成，那么从第二个重复子串开始j将不断递增（next数组）==
- 方案：
    1. 生成前缀表next数组
    2. 返回next[len-1]!=0&&len%(len-(next[len-1]))==0
        - 可当做公式

