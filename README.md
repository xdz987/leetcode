## 算法与数据结构学习&刷题记录
- 题目数：400道
- 选题标准：经典学习题、高频重点题
- 包含内容：算法学习笔记、算法刷题笔记、一题多解
- 后续更新：每日签到题...
    - PS：思路笔记录入对应模块刷题总结
    
---
- 今日签到题：
    - 日期：8.14
    - 题型：数组/矩阵/模拟
    - 难度：中等
    - 题号：q1583
    - 解题思路：
        1. 整理preferences表：整理权重
            - weights[n][n]：记录i与其他朋友的关系亲密度权重表weights
        2. 整理pairs表：根据paris队友记录对应权重值
            - teams[n][2]：i当前的队友为teams[i][0]，关系亲密度的权重为teams[i][1]
        3. 统计不开心的朋友：满足不等式即累加
            - contiue：当朋友是自己或朋友为队友时，不需要进行比较
            - 剪枝break：当paris中队友的亲密度为最高时，直接不需要比较，res++
            - 满足不等式break：res++
```java
/**
 * q1583
 * 方法一：数组/模拟
 */
class Solution {
    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {
        //(1)整理preferences表：整理权重
        //记录i与其他朋友的关系亲密度权重表weights
        int[][] weights = new int[n][n];
        for(int i=0;i<n;i++){
            int weight = n-1;
            for(int fre:preferences[i]){
                weights[i][fre] = weight--;
            }
        }
        //(2)整理pairs表：根据paris队友记录对应权重值
        //将当前配对的朋友保存进teams表。i当前的队友为teams[i][0]，关系亲密度的权重为teams[i][1]
        int[][] teams = new int[n][2];
        for(int[] pair:pairs){
            teams[pair[0]][0] = pair[1];
            teams[pair[0]][1] = weights[pair[0]][pair[1]];
            teams[pair[1]][0] = pair[0];
            teams[pair[1]][1] = weights[pair[1]][pair[0]];
        }
        //(3)统计不开心的朋友：满足不等式即累加
        //将题目的不等式代入，成立时res++
        int res = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                //当朋友是自己或朋友为队友时，不需要进行比较，continue
                if(i==j || j == teams[i][0]){
                    continue;
                }
                int x_y = teams[i][1];
                int x_u = weights[i][j];
                int u_v = teams[j][1];
                int u_x = weights[j][i];
                //剪枝：当paris中队友的亲密度为最高时，直接不需要比较
                if(x_y == n-1)
                    break;
                //当满足不等式时，i为不开心的朋友
                if(x_y < x_u && u_v < u_x){
                    res++;
                    break;
                }
            }
        }
        return res;
    }
}
```

### 数组与矩阵
### 双指针
- 快慢指针
- 左右指针
- 二分查找：二分、左侧边界二分、右侧边界二分

### 区间
- 滑动窗口：固定窗口、可变窗口(满足条件最小/最大窗口)
- 前缀和

### 分治
### 排序
- 堆排、归并、快排、选排、冒泡

### 栈与队列

- 栈与队列转换
- 单调栈/辅助栈
- 单调队列

### 堆/优先队列

- 固定堆
- 双堆

### 字符串

- KMP应用
- 一般型题
- 技巧型题

### 链表

- 链表节点批量操作
- 单节点查找/操作

### 树

- 二叉树
  1. 修改二叉树
  2. 构建二叉树
  3. 搜索二叉树
  4. 层序遍历二叉树
  - 递归前、后、层序等
  - 迭代前、中、后序
- 二叉搜索树
  1. 构架BST
  2. 修改BST
  3. 搜索BST
  4. 其他算法
    - 中序遍历、二分法等
- 字典树/前、后缀树/Trie
- Morris前、中、后序遍历

### 图论

- 并查集
    - 路径压缩、平衡性优化/条件选择
- 拓扑排序
    - 邻接表
        1. BFS+入度表
        2. DFS+标记表
- 二分图
    - 邻接表
        1. DFS+标记表
        2. BFS+标记表
        3. 并查集
- 最小生成树【未】

### 其他算法

- 位运算
    - 位移、异或、与运算
    - 综合统计
    - 有限自动状态机
    - 摩尔投票法
- 数学题型
    - 质数、最大公约数最小公倍数、进制转换、阶乘、字符串加法减法、相遇问题、多数投票问题
    - 其他算法

### 回溯

- 排列
- 组合
- 子集
- Flood Fill
    - DFS/回溯(可相互转)
- 字符串问题
- 游戏问题

### 贪心

- 传递法
- 取差值法
- 枚举排除法
- 拆分法
- 范围覆盖法
- 元组/双维度/区间

### 动态规划

1. 斐波那契类型问题
    1. 斐波那契数列
    2. 打家劫舍题型
2. 分割整数问题【子问题纵向传递】
3. 矩阵路径问题【方向选择】
    1. 矩阵路径——组合问题
    2. 矩阵路径——最值问题
4. 背包问题
    1. 0/1背包——最值问题
    2. 0/1背包——元素和
    3. 0/1背包——元素和的组合
    4. 完全背包——最值问题
    5. 完全背包——组合问题
    6. 完全背包——排列问题
5. 股票买卖问题【多状态转移】
6. 最长xx子序列
    1. 最长公共子序列【元素相等】
    2. 最长递增子序列【元素递增/减】
    3. 最长回文子序列【回文串】
    4. xx子序列的数量
7. 区间计算
